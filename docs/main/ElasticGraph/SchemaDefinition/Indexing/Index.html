<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>
  Class: ElasticGraph::SchemaDefinition::Indexing::Index
  
    &mdash; Documentation by YARD 0.9.37
  
</title>

  <link rel="stylesheet" href="../../../css/style.css" type="text/css" />

  <link rel="stylesheet" href="../../../css/common.css" type="text/css" />

<script type="text/javascript">
  pathId = "ElasticGraph::SchemaDefinition::Indexing::Index";
  relpath = '../../../';
</script>


  <script type="text/javascript" charset="utf-8" src="../../../js/jquery.js"></script>

  <script type="text/javascript" charset="utf-8" src="../../../js/app.js"></script>


  </head>
  <body>
    <div class="nav_wrap">
      <iframe id="nav" src="../../../class_list.html?1"></iframe>
      <div id="resizer"></div>
    </div>

    <div id="main" tabindex="-1">
      <div id="header">
        <div id="menu">
  
    <a href="../../../_index.html">Index (I)</a> &raquo;
    <span class='title'><span class='object_link'><a href="../../../ElasticGraph.html" title="ElasticGraph (module)">ElasticGraph</a></span></span> &raquo; <span class='title'><span class='object_link'><a href="../../SchemaDefinition.html" title="ElasticGraph::SchemaDefinition (module)">SchemaDefinition</a></span></span> &raquo; <span class='title'><span class='object_link'><a href="../Indexing.html" title="ElasticGraph::SchemaDefinition::Indexing (module)">Indexing</a></span></span>
     &raquo; 
    <span class="title">Index</span>
  
</div>

        <div id="search">
  
    <a class="full_list_link" id="class_list_link"
        href="../../../class_list.html">

        <svg width="24" height="24">
          <rect x="0" y="4" width="24" height="4" rx="1" ry="1"></rect>
          <rect x="0" y="12" width="24" height="4" rx="1" ry="1"></rect>
          <rect x="0" y="20" width="24" height="4" rx="1" ry="1"></rect>
        </svg>
    </a>
  
</div>
        <div class="clear"></div>
      </div>

      <div id="content"><h1>Class: ElasticGraph::SchemaDefinition::Indexing::Index
  
  
  
</h1>
<div class="box_info">
  
  <dl>
    <dt>Inherits:</dt>
    <dd>
      <span class="inheritName">Struct</span>
      
        <ul class="fullTree">
          <li>Object</li>
          
            <li class="next">Struct</li>
          
            <li class="next">ElasticGraph::SchemaDefinition::Indexing::Index</li>
          
        </ul>
        <a href="#" class="inheritanceTree">show all</a>
      
    </dd>
  </dl>
  

  
  
  
  
  

  

  
  <dl>
    <dt>Defined in:</dt>
    <dd>elasticgraph-schema_definition/lib/elastic_graph/schema_definition/indexing/index.rb</dd>
  </dl>
  
</div>

<h2>Overview</h2><div class="docstring">
  <div class="discussion">
    <p>Represents an index in a datastore. Defined within an indexed type. Modeled as a separate object to facilitate
further customization of the index.</p>


  </div>
</div>
<div class="tags">
  

</div>



  <h2>Instance Attribute Summary <small><a href="#" class="summary_toggle">collapse</a></small></h2>
  <ul class="summary">
    
      <li class="public ">
  <span class="summary_signature">
    
      <a href="#default_sort_pairs-instance_method" title="#default_sort_pairs (instance method)">#<strong>default_sort_pairs</strong>  &#x21d2; Array&lt;(String, Symbol)&gt; </a>
    

    
  </span>
  
  
  
    
      <span class="note title readonly">readonly</span>
    
    
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>(field name, direction) pairs for the default sort.</p>
</div></span>
  
</li>

    
      <li class="public ">
  <span class="summary_signature">
    
      <a href="#indexed_type-instance_method" title="#indexed_type (instance method)">#<strong>indexed_type</strong>  &#x21d2; SchemaElements::ObjectType, ... </a>
    

    
  </span>
  
  
  
    
      <span class="note title readonly">readonly</span>
    
    
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>Type backed by this index.</p>
</div></span>
  
</li>

    
      <li class="public ">
  <span class="summary_signature">
    
      <a href="#name-instance_method" title="#name (instance method)">#<strong>name</strong>  &#x21d2; String </a>
    

    
  </span>
  
  
  
    
      <span class="note title readonly">readonly</span>
    
    
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>Name of the index.</p>
</div></span>
  
</li>

    
      <li class="public ">
  <span class="summary_signature">
    
      <a href="#rollover_config-instance_method" title="#rollover_config (instance method)">#<strong>rollover_config</strong>  &#x21d2; RolloverConfig<sup>?</sup> </a>
    

    
  </span>
  
  
  
    
      <span class="note title readonly">readonly</span>
    
    
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>Rollover configuration for the index.</p>
</div></span>
  
</li>

    
      <li class="public ">
  <span class="summary_signature">
    
      <a href="#routing_field_path-instance_method" title="#routing_field_path (instance method)">#<strong>routing_field_path</strong>  &#x21d2; Array&lt;String&gt; </a>
    

    
  </span>
  
  
  
    
      <span class="note title readonly">readonly</span>
    
    
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>Path to the field used for shard routing.</p>
</div></span>
  
</li>

    
      <li class="public ">
  <span class="summary_signature">
    
      <a href="#schema_def_state-instance_method" title="#schema_def_state (instance method)">#<strong>schema_def_state</strong>  &#x21d2; State </a>
    

    
  </span>
  
  
  
    
      <span class="note title readonly">readonly</span>
    
    
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>Schema definition state.</p>
</div></span>
  
</li>

    
      <li class="public ">
  <span class="summary_signature">
    
      <a href="#settings-instance_method" title="#settings (instance method)">#<strong>settings</strong>  &#x21d2; Hash&lt;(String, Object)&gt; </a>
    

    
  </span>
  
  
  
    
      <span class="note title readonly">readonly</span>
    
    
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>Datastore settings for the index.</p>
</div></span>
  
</li>

    
  </ul>




  
    <h2>
      Instance Method Summary
      <small><a href="#" class="summary_toggle">collapse</a></small>
    </h2>

    <ul class="summary">
      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#default_sort-instance_method" title="#default_sort (instance method)">#<strong>default_sort</strong>(*field_name_direction_pairs)  &#x21d2; void </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>Specifies how documents in this index should sort by default, when no <code>orderBy</code> argument is provided to the GraphQL query.</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#initialize-instance_method" title="#initialize (instance method)">#<strong>initialize</strong>(name, settings, schema_def_state, indexed_type) {|Index| ... } &#x21d2; Index </a>
    

    
  </span>
  
  
    <span class="note title constructor">constructor</span>
  
  
  
  
  
  <span class="private note title">private</span>

  
    <span class="summary_desc"><div class='inline'><p>A new instance of Index.</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#rollover-instance_method" title="#rollover (instance method)">#<strong>rollover</strong>(frequency, timestamp_field_path_name)  &#x21d2; void </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>Causes this index to “rollover” at the provided <code>frequency</code> based on the value of the provided <code>timestamp_field_path_name</code>.</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#route_with-instance_method" title="#route_with (instance method)">#<strong>route_with</strong>(routing_field_path_name)  &#x21d2; void </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>Configures the index to <a href="https://www.elastic.co/guide/en/elasticsearch/reference/8.15/mapping-routing-field.html">route documents to shards</a> based on the specified field.</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#runtime_metadata-instance_method" title="#runtime_metadata (instance method)">#<strong>runtime_metadata</strong>  &#x21d2; SchemaArtifacts::RuntimeMetadata::IndexDefinition </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>Runtime metadata for this index.</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#to_index_config-instance_method" title="#to_index_config (instance method)">#<strong>to_index_config</strong>  &#x21d2; Hash&lt;String, Object&gt; </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>Datastore configuration for this index for when it does not use rollover.</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#to_index_template_config-instance_method" title="#to_index_template_config (instance method)">#<strong>to_index_template_config</strong>  &#x21d2; Hash&lt;String, Object&gt; </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>Datastore configuration for the index template that will be defined if rollover is used.</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#uses_custom_routing%3F-instance_method" title="#uses_custom_routing? (instance method)">#<strong>uses_custom_routing?</strong>  &#x21d2; Boolean </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>Whether or not this index uses custom shard routing.</p>
</div></span>
  
</li>

      
    </ul>
  


  <div id="constructor_details" class="method_details_list">
  <h2>Constructor Details</h2>
  
    <div class="method_details first">
  <h3 class="signature first" id="initialize-instance_method">
  
    #<strong>initialize</strong>(name, settings, schema_def_state, indexed_type) {|Index| ... } &#x21d2; <tt><span class='object_link'><a href="" title="ElasticGraph::SchemaDefinition::Indexing::Index (class)">Index</a></span></tt> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    <p class="note private">
  <strong>This method is part of a private API.</strong>
  You should avoid using this method if possible, as it may be removed or be changed in the future.
</p>
<p>Returns a new instance of Index.</p>


  </div>
</div>
<div class="tags">
  <p class="tag_title">Parameters:</p>
<ul class="param">
  
    <li>
      
        <span class='name'>name</span>
      
      
        <span class='type'>(<tt>String</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>name of the index</p>
</div>
      
    </li>
  
    <li>
      
        <span class='name'>settings</span>
      
      
        <span class='type'>(<tt>Hash&lt;(String, Object)&gt;</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>datastore settings for the index</p>
</div>
      
    </li>
  
    <li>
      
        <span class='name'>schema_def_state</span>
      
      
        <span class='type'>(<tt><span class='object_link'>State</span></tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>schema definition state</p>
</div>
      
    </li>
  
    <li>
      
        <span class='name'>indexed_type</span>
      
      
        <span class='type'>(<tt><span class='object_link'><a href="../SchemaElements/ObjectType.html" title="ElasticGraph::SchemaDefinition::SchemaElements::ObjectType (class)">SchemaElements::ObjectType</a></span></tt>, <tt><span class='object_link'><a href="../SchemaElements/InterfaceType.html" title="ElasticGraph::SchemaDefinition::SchemaElements::InterfaceType (class)">SchemaElements::InterfaceType</a></span></tt>, <tt><span class='object_link'><a href="../SchemaElements/UnionType.html" title="ElasticGraph::SchemaDefinition::SchemaElements::UnionType (class)">SchemaElements::UnionType</a></span></tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>type backed by this index</p>
</div>
      
    </li>
  
</ul>

<p class="tag_title">Yields:</p>
<ul class="yield">
  
    <li>
      
      
        <span class='type'>(<tt><span class='object_link'><a href="" title="ElasticGraph::SchemaDefinition::Indexing::Index (class)">Index</a></span></tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>the index, for further customization</p>
</div>
      
    </li>
  
</ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


48
49
50
51
52
53
54
55
56
57
58
59
60
61
62
63
64
65
66</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'elasticgraph-schema_definition/lib/elastic_graph/schema_definition/indexing/index.rb', line 48</span>

<span class='kw'>def</span> <span class='id identifier rubyid_initialize'>initialize</span><span class='lparen'>(</span><span class='id identifier rubyid_name'>name</span><span class='comma'>,</span> <span class='id identifier rubyid_settings'>settings</span><span class='comma'>,</span> <span class='id identifier rubyid_schema_def_state'>schema_def_state</span><span class='comma'>,</span> <span class='id identifier rubyid_indexed_type'>indexed_type</span><span class='rparen'>)</span>
  <span class='kw'>if</span> <span class='id identifier rubyid_name'>name</span><span class='period'>.</span><span class='id identifier rubyid_include?'>include?</span><span class='lparen'>(</span><span class='const'>ROLLOVER_INDEX_INFIX_MARKER</span><span class='rparen'>)</span>
    <span class='id identifier rubyid_raise'>raise</span> <span class='const'>Errors</span><span class='op'>::</span><span class='const'>SchemaError</span><span class='comma'>,</span> <span class='tstring'><span class='tstring_beg'>&quot;</span><span class='tstring_content'>`</span><span class='embexpr_beg'>#{</span><span class='id identifier rubyid_name'>name</span><span class='embexpr_end'>}</span><span class='tstring_content'>` is an invalid index definition name since it contains </span><span class='tstring_end'>&quot;</span></span> \
      <span class='tstring'><span class='tstring_beg'>&quot;</span><span class='tstring_content'>`</span><span class='embexpr_beg'>#{</span><span class='const'>ROLLOVER_INDEX_INFIX_MARKER</span><span class='embexpr_end'>}</span><span class='tstring_content'>` which ElasticGraph treats as special.</span><span class='tstring_end'>&quot;</span></span>
  <span class='kw'>end</span>

  <span class='id identifier rubyid_settings'>settings</span> <span class='op'>=</span> <span class='const'>DEFAULT_SETTINGS</span><span class='period'>.</span><span class='id identifier rubyid_merge'>merge</span><span class='lparen'>(</span><span class='const'><span class='object_link'><a href="../../Support.html" title="ElasticGraph::Support (module)">Support</a></span></span><span class='op'>::</span><span class='const'>HashUtil</span><span class='period'>.</span><span class='id identifier rubyid_flatten_and_stringify_keys'>flatten_and_stringify_keys</span><span class='lparen'>(</span><span class='id identifier rubyid_settings'>settings</span><span class='comma'>,</span> <span class='label'>prefix:</span> <span class='tstring'><span class='tstring_beg'>&quot;</span><span class='tstring_content'>index</span><span class='tstring_end'>&quot;</span></span><span class='rparen'>)</span><span class='rparen'>)</span>

  <span class='kw'>super</span><span class='lparen'>(</span><span class='id identifier rubyid_name'>name</span><span class='comma'>,</span> <span class='lbracket'>[</span><span class='rbracket'>]</span><span class='comma'>,</span> <span class='id identifier rubyid_settings'>settings</span><span class='comma'>,</span> <span class='id identifier rubyid_schema_def_state'>schema_def_state</span><span class='comma'>,</span> <span class='id identifier rubyid_indexed_type'>indexed_type</span><span class='comma'>,</span> <span class='lbracket'>[</span><span class='rbracket'>]</span><span class='comma'>,</span> <span class='kw'>nil</span><span class='rparen'>)</span>

  <span class='comment'># `id` is the field Elasticsearch/OpenSearch use for routing by default:
</span>  <span class='comment'># https://www.elastic.co/guide/en/elasticsearch/reference/current/mapping-routing-field.html
</span>  <span class='comment'># By using it here, it will cause queries to pass a `routing` parameter when
</span>  <span class='comment'># searching with id filtering on an index that does not use custom shard routing, giving
</span>  <span class='comment'># us a nice efficiency boost.
</span>  <span class='kw'>self</span><span class='period'>.</span><span class='id identifier rubyid_routing_field_path'>routing_field_path</span> <span class='op'>=</span> <span class='id identifier rubyid_public_field_path'>public_field_path</span><span class='lparen'>(</span><span class='tstring'><span class='tstring_beg'>&quot;</span><span class='tstring_content'>id</span><span class='tstring_end'>&quot;</span></span><span class='comma'>,</span> <span class='label'>explanation:</span> <span class='tstring'><span class='tstring_beg'>&quot;</span><span class='tstring_content'>indexed types must have an `id` field</span><span class='tstring_end'>&quot;</span></span><span class='rparen'>)</span>

  <span class='kw'>yield</span> <span class='kw'>self</span> <span class='kw'>if</span> <span class='id identifier rubyid_block_given?'>block_given?</span>
<span class='kw'>end</span></pre>
    </td>
  </tr>
</table>
</div>
  
</div>

  <div id="instance_attr_details" class="attr_details">
    <h2>Instance Attribute Details</h2>
    
      
      <span id=""></span>
      <div class="method_details first">
  <h3 class="signature first" id="default_sort_pairs-instance_method">
  
    #<strong>default_sort_pairs</strong>  &#x21d2; <tt>Array&lt;(String, Symbol)&gt;</tt>  <span class="extras">(readonly)</span>
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    <p>Returns (field name, direction) pairs for the default sort.</p>


  </div>
</div>
<div class="tags">
  
<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt>Array&lt;(String, Symbol)&gt;</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>(field name, direction) pairs for the default sort</p>
</div>
      
    </li>
  
</ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
55
56
57
58
59
60
61
62
63
64
65
66
67
68
69
70
71
72
73
74
75
76
77
78
79
80
81
82
83
84
85
86
87
88
89
90
91
92
93
94
95
96
97
98
99
100
101
102
103
104
105
106
107
108
109
110
111
112
113
114
115
116
117
118
119
120
121
122
123
124
125
126
127
128
129
130
131
132
133
134
135
136
137
138
139
140
141
142
143
144
145
146
147
148
149
150
151
152
153
154
155
156
157
158
159
160
161
162
163
164
165
166
167
168
169
170
171
172
173
174
175
176
177
178
179
180
181
182
183
184
185
186
187
188
189
190
191
192
193
194
195
196
197
198
199
200
201
202
203
204
205
206
207
208
209
210
211
212
213
214
215
216
217
218
219
220
221
222
223
224
225
226
227
228
229
230
231
232
233
234
235
236
237
238
239
240
241
242
243
244
245
246
247
248
249
250
251
252
253
254
255
256
257
258
259
260
261
262
263
264
265
266
267
268
269
270
271
272
273
274
275
276
277
278
279
280
281
282
283
284
285
286
287
288
289
290
291
292
293
294
295
296
297
298
299
300
301
302
303
304
305
306
307
308
309
310
311
312
313
314
315</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'elasticgraph-schema_definition/lib/elastic_graph/schema_definition/indexing/index.rb', line 39</span>

<span class='kw'>class</span> <span class='const'><span class='object_link'><a href="" title="ElasticGraph::SchemaDefinition::Indexing::Index (class)">Index</a></span></span> <span class='op'>&lt;</span> <span class='const'>Struct</span><span class='period'>.</span><span class='id identifier rubyid_new'>new</span><span class='lparen'>(</span><span class='symbol'>:name</span><span class='comma'>,</span> <span class='symbol'>:default_sort_pairs</span><span class='comma'>,</span> <span class='symbol'>:settings</span><span class='comma'>,</span> <span class='symbol'>:schema_def_state</span><span class='comma'>,</span> <span class='symbol'>:indexed_type</span><span class='comma'>,</span> <span class='symbol'>:routing_field_path</span><span class='comma'>,</span> <span class='symbol'>:rollover_config</span><span class='rparen'>)</span>
  <span class='id identifier rubyid_include'>include</span> <span class='const'><span class='object_link'><a href="../Mixins.html" title="ElasticGraph::SchemaDefinition::Mixins (module)">Mixins</a></span></span><span class='op'>::</span><span class='const'>HasReadableToSAndInspect</span><span class='period'>.</span><span class='id identifier rubyid_new'>new</span> <span class='lbrace'>{</span> <span class='op'>|</span><span class='id identifier rubyid_i'>i</span><span class='op'>|</span> <span class='id identifier rubyid_i'>i</span><span class='period'>.</span><span class='id identifier rubyid_name'>name</span> <span class='rbrace'>}</span>

  <span class='comment'># @param name [String] name of the index
</span>  <span class='comment'># @param settings [Hash&lt;(String, Object)&gt;] datastore settings for the index
</span>  <span class='comment'># @param schema_def_state [State] schema definition state
</span>  <span class='comment'># @param indexed_type [SchemaElements::ObjectType, SchemaElements::InterfaceType, SchemaElements::UnionType] type backed by this index
</span>  <span class='comment'># @yield [Index] the index, for further customization
</span>  <span class='comment'># @api private
</span>  <span class='kw'>def</span> <span class='id identifier rubyid_initialize'>initialize</span><span class='lparen'>(</span><span class='id identifier rubyid_name'>name</span><span class='comma'>,</span> <span class='id identifier rubyid_settings'>settings</span><span class='comma'>,</span> <span class='id identifier rubyid_schema_def_state'>schema_def_state</span><span class='comma'>,</span> <span class='id identifier rubyid_indexed_type'>indexed_type</span><span class='rparen'>)</span>
    <span class='kw'>if</span> <span class='id identifier rubyid_name'>name</span><span class='period'>.</span><span class='id identifier rubyid_include?'>include?</span><span class='lparen'>(</span><span class='const'>ROLLOVER_INDEX_INFIX_MARKER</span><span class='rparen'>)</span>
      <span class='id identifier rubyid_raise'>raise</span> <span class='const'>Errors</span><span class='op'>::</span><span class='const'>SchemaError</span><span class='comma'>,</span> <span class='tstring'><span class='tstring_beg'>&quot;</span><span class='tstring_content'>`</span><span class='embexpr_beg'>#{</span><span class='id identifier rubyid_name'>name</span><span class='embexpr_end'>}</span><span class='tstring_content'>` is an invalid index definition name since it contains </span><span class='tstring_end'>&quot;</span></span> \
        <span class='tstring'><span class='tstring_beg'>&quot;</span><span class='tstring_content'>`</span><span class='embexpr_beg'>#{</span><span class='const'>ROLLOVER_INDEX_INFIX_MARKER</span><span class='embexpr_end'>}</span><span class='tstring_content'>` which ElasticGraph treats as special.</span><span class='tstring_end'>&quot;</span></span>
    <span class='kw'>end</span>

    <span class='id identifier rubyid_settings'>settings</span> <span class='op'>=</span> <span class='const'>DEFAULT_SETTINGS</span><span class='period'>.</span><span class='id identifier rubyid_merge'>merge</span><span class='lparen'>(</span><span class='const'><span class='object_link'><a href="../../Support.html" title="ElasticGraph::Support (module)">Support</a></span></span><span class='op'>::</span><span class='const'>HashUtil</span><span class='period'>.</span><span class='id identifier rubyid_flatten_and_stringify_keys'>flatten_and_stringify_keys</span><span class='lparen'>(</span><span class='id identifier rubyid_settings'>settings</span><span class='comma'>,</span> <span class='label'>prefix:</span> <span class='tstring'><span class='tstring_beg'>&quot;</span><span class='tstring_content'>index</span><span class='tstring_end'>&quot;</span></span><span class='rparen'>)</span><span class='rparen'>)</span>

    <span class='kw'>super</span><span class='lparen'>(</span><span class='id identifier rubyid_name'>name</span><span class='comma'>,</span> <span class='lbracket'>[</span><span class='rbracket'>]</span><span class='comma'>,</span> <span class='id identifier rubyid_settings'>settings</span><span class='comma'>,</span> <span class='id identifier rubyid_schema_def_state'>schema_def_state</span><span class='comma'>,</span> <span class='id identifier rubyid_indexed_type'>indexed_type</span><span class='comma'>,</span> <span class='lbracket'>[</span><span class='rbracket'>]</span><span class='comma'>,</span> <span class='kw'>nil</span><span class='rparen'>)</span>

    <span class='comment'># `id` is the field Elasticsearch/OpenSearch use for routing by default:
</span>    <span class='comment'># https://www.elastic.co/guide/en/elasticsearch/reference/current/mapping-routing-field.html
</span>    <span class='comment'># By using it here, it will cause queries to pass a `routing` parameter when
</span>    <span class='comment'># searching with id filtering on an index that does not use custom shard routing, giving
</span>    <span class='comment'># us a nice efficiency boost.
</span>    <span class='kw'>self</span><span class='period'>.</span><span class='id identifier rubyid_routing_field_path'>routing_field_path</span> <span class='op'>=</span> <span class='id identifier rubyid_public_field_path'>public_field_path</span><span class='lparen'>(</span><span class='tstring'><span class='tstring_beg'>&quot;</span><span class='tstring_content'>id</span><span class='tstring_end'>&quot;</span></span><span class='comma'>,</span> <span class='label'>explanation:</span> <span class='tstring'><span class='tstring_beg'>&quot;</span><span class='tstring_content'>indexed types must have an `id` field</span><span class='tstring_end'>&quot;</span></span><span class='rparen'>)</span>

    <span class='kw'>yield</span> <span class='kw'>self</span> <span class='kw'>if</span> <span class='id identifier rubyid_block_given?'>block_given?</span>
  <span class='kw'>end</span>

  <span class='comment'># Specifies how documents in this index should sort by default, when no `orderBy` argument is provided to the GraphQL query.
</span>  <span class='comment'>#
</span>  <span class='comment'># @note the field name strings can be a dot-separated nested fields, but all referenced
</span>  <span class='comment'>#   fields must exist when this is called.
</span>  <span class='comment'>#
</span>  <span class='comment'># @param field_name_direction_pairs [Array&lt;(String, Symbol)&gt;] pairs of field names and `:asc` or `:desc`
</span>  <span class='comment'># @return [void]
</span>  <span class='comment'>#
</span>  <span class='comment'># @example Sort on `name` (ascending) with `createdAt` (descending) as a tie-breaker
</span>  <span class='comment'>#   ElasticGraph.define_schema do |schema|
</span>  <span class='comment'>#     schema.object_type &quot;Campaign&quot; do |t|
</span>  <span class='comment'>#       t.field &quot;id&quot;, &quot;ID!&quot;
</span>  <span class='comment'>#       t.field &quot;name&quot;, &quot;String&quot;
</span>  <span class='comment'>#       t.field &quot;createdAt&quot;, &quot;DateTime&quot;
</span>  <span class='comment'>#
</span>  <span class='comment'>#       t.index &quot;campaigns&quot;do |i|
</span>  <span class='comment'>#         i.default_sort &quot;name&quot;, :asc, &quot;createdAt&quot;, :desc
</span>  <span class='comment'>#       end
</span>  <span class='comment'>#     end
</span>  <span class='comment'>#   end
</span>  <span class='kw'>def</span> <span class='id identifier rubyid_default_sort'>default_sort</span><span class='lparen'>(</span><span class='op'>*</span><span class='id identifier rubyid_field_name_direction_pairs'>field_name_direction_pairs</span><span class='rparen'>)</span>
    <span class='kw'>self</span><span class='period'>.</span><span class='id identifier rubyid_default_sort_pairs'>default_sort_pairs</span> <span class='op'>=</span> <span class='id identifier rubyid_field_name_direction_pairs'>field_name_direction_pairs</span>
  <span class='kw'>end</span>

  <span class='comment'># Causes this index to &quot;rollover&quot; at the provided `frequency` based on the value of the provided `timestamp_field_path_name`.
</span>  <span class='comment'># This is particularly useful for time-series data. Partitioning the data into `hourly`, `daily`, `monthly` or `yearly` buckets
</span>  <span class='comment'># allows for different index configurations, and can be necessary when a dataset is too large to fit in one dataset given
</span>  <span class='comment'># Elasticsearch/OpenSearch limitations on the number of shards in one index. In addition, ElasticGraph optimizes queries which
</span>  <span class='comment'># filter on the timestamp field to target the subset of the indices in which matching documents could reside.
</span>  <span class='comment'>#
</span>  <span class='comment'># @note the timestamp field specified here **must be immutable**. To understand why, consider a `:yearly` rollover
</span>  <span class='comment'>#   index used for data based on `createdAt`; if ElasticGraph ingests record `123` with a createdAt of `2023-12-31T23:59:59Z`, it
</span>  <span class='comment'>#   will be indexed in the `2023` index. Later if it receives an update event for record `123` with a `createdAt` of
</span>  <span class='comment'>#   `2024-01-01T00:00:00Z` (a mere one second later!), ElasticGraph will store the new version of the payment in the `2024` index,
</span>  <span class='comment'>#   and leave the old copy of the payment in the `2023` index unchanged. It’ll have duplicates for that document.
</span>  <span class='comment'># @note changing the `rollover` configuration on an existing index that already has data will result in duplicate documents
</span>  <span class='comment'>#
</span>  <span class='comment'># @param frequency [:yearly, :monthly, :daily, :hourly] how often to rollover the index
</span>  <span class='comment'># @param timestamp_field_path_name [String] dot-separated path to the timestamp field used for rollover. Note: all referenced
</span>  <span class='comment'>#   fields must exist when this is called.
</span>  <span class='comment'># @return [void]
</span>  <span class='comment'>#
</span>  <span class='comment'># @example Define a `campaigns` index to rollover yearly based on `createdAt`
</span>  <span class='comment'>#   ElasticGraph.define_schema do |schema|
</span>  <span class='comment'>#     schema.object_type &quot;Campaign&quot; do |t|
</span>  <span class='comment'>#       t.field &quot;id&quot;, &quot;ID!&quot;
</span>  <span class='comment'>#       t.field &quot;name&quot;, &quot;String&quot;
</span>  <span class='comment'>#       t.field &quot;createdAt&quot;, &quot;DateTime&quot;
</span>  <span class='comment'>#
</span>  <span class='comment'>#       t.index &quot;campaigns&quot;do |i|
</span>  <span class='comment'>#         i.rollover :yearly, &quot;createdAt&quot;
</span>  <span class='comment'>#       end
</span>  <span class='comment'>#     end
</span>  <span class='comment'>#   end
</span>  <span class='kw'>def</span> <span class='id identifier rubyid_rollover'>rollover</span><span class='lparen'>(</span><span class='id identifier rubyid_frequency'>frequency</span><span class='comma'>,</span> <span class='id identifier rubyid_timestamp_field_path_name'>timestamp_field_path_name</span><span class='rparen'>)</span>
    <span class='id identifier rubyid_timestamp_field_path'>timestamp_field_path</span> <span class='op'>=</span> <span class='id identifier rubyid_public_field_path'>public_field_path</span><span class='lparen'>(</span><span class='id identifier rubyid_timestamp_field_path_name'>timestamp_field_path_name</span><span class='comma'>,</span> <span class='label'>explanation:</span> <span class='tstring'><span class='tstring_beg'>&quot;</span><span class='tstring_content'>it is referenced as an index `rollover` field</span><span class='tstring_end'>&quot;</span></span><span class='rparen'>)</span>

    <span class='kw'>unless</span> <span class='id identifier rubyid_date_and_datetime_types'>date_and_datetime_types</span><span class='period'>.</span><span class='id identifier rubyid_include?'>include?</span><span class='lparen'>(</span><span class='id identifier rubyid_timestamp_field_path'>timestamp_field_path</span><span class='period'>.</span><span class='id identifier rubyid_type'>type</span><span class='period'>.</span><span class='id identifier rubyid_fully_unwrapped'>fully_unwrapped</span><span class='period'>.</span><span class='id identifier rubyid_name'>name</span><span class='rparen'>)</span>
      <span class='id identifier rubyid_date_or_datetime_description'>date_or_datetime_description</span> <span class='op'>=</span> <span class='id identifier rubyid_date_and_datetime_types'>date_and_datetime_types</span><span class='period'>.</span><span class='id identifier rubyid_map'>map</span> <span class='lbrace'>{</span> <span class='op'>|</span><span class='id identifier rubyid_t'>t</span><span class='op'>|</span> <span class='tstring'><span class='tstring_beg'>&quot;</span><span class='tstring_content'>`</span><span class='embexpr_beg'>#{</span><span class='id identifier rubyid_t'>t</span><span class='embexpr_end'>}</span><span class='tstring_content'>`</span><span class='tstring_end'>&quot;</span></span> <span class='rbrace'>}</span><span class='period'>.</span><span class='id identifier rubyid_join'>join</span><span class='lparen'>(</span><span class='tstring'><span class='tstring_beg'>&quot;</span><span class='tstring_content'> or </span><span class='tstring_end'>&quot;</span></span><span class='rparen'>)</span>
      <span class='id identifier rubyid_raise'>raise</span> <span class='const'>Errors</span><span class='op'>::</span><span class='const'>SchemaError</span><span class='comma'>,</span> <span class='tstring'><span class='tstring_beg'>&quot;</span><span class='tstring_content'>rollover field `</span><span class='embexpr_beg'>#{</span><span class='id identifier rubyid_timestamp_field_path'>timestamp_field_path</span><span class='period'>.</span><span class='id identifier rubyid_full_description'>full_description</span><span class='embexpr_end'>}</span><span class='tstring_content'>` cannot be used for rollover since it is not a </span><span class='embexpr_beg'>#{</span><span class='id identifier rubyid_date_or_datetime_description'>date_or_datetime_description</span><span class='embexpr_end'>}</span><span class='tstring_content'> field.</span><span class='tstring_end'>&quot;</span></span>
    <span class='kw'>end</span>

    <span class='kw'>if</span> <span class='id identifier rubyid_timestamp_field_path'>timestamp_field_path</span><span class='period'>.</span><span class='id identifier rubyid_type'>type</span><span class='period'>.</span><span class='id identifier rubyid_list?'>list?</span>
      <span class='id identifier rubyid_raise'>raise</span> <span class='const'>Errors</span><span class='op'>::</span><span class='const'>SchemaError</span><span class='comma'>,</span> <span class='tstring'><span class='tstring_beg'>&quot;</span><span class='tstring_content'>rollover field `</span><span class='embexpr_beg'>#{</span><span class='id identifier rubyid_timestamp_field_path'>timestamp_field_path</span><span class='period'>.</span><span class='id identifier rubyid_full_description'>full_description</span><span class='embexpr_end'>}</span><span class='tstring_content'>` cannot be used for rollover since it is a list field.</span><span class='tstring_end'>&quot;</span></span>
    <span class='kw'>end</span>

    <span class='id identifier rubyid_timestamp_field_path'>timestamp_field_path</span><span class='period'>.</span><span class='id identifier rubyid_path_parts'>path_parts</span><span class='period'>.</span><span class='id identifier rubyid_each'>each</span> <span class='lbrace'>{</span> <span class='op'>|</span><span class='id identifier rubyid_f'>f</span><span class='op'>|</span> <span class='id identifier rubyid_f'>f</span><span class='period'>.</span><span class='id identifier rubyid_json_schema'>json_schema</span> <span class='label'>nullable:</span> <span class='kw'>false</span> <span class='rbrace'>}</span>

    <span class='kw'>self</span><span class='period'>.</span><span class='id identifier rubyid_rollover_config'>rollover_config</span> <span class='op'>=</span> <span class='const'>RolloverConfig</span><span class='period'>.</span><span class='id identifier rubyid_new'>new</span><span class='lparen'>(</span>
      <span class='label'>frequency:</span> <span class='id identifier rubyid_frequency'>frequency</span><span class='comma'>,</span>
      <span class='label'>timestamp_field_path:</span> <span class='id identifier rubyid_timestamp_field_path'>timestamp_field_path</span>
    <span class='rparen'>)</span>
  <span class='kw'>end</span>

  <span class='comment'># Configures the index to [route documents to shards](https://www.elastic.co/guide/en/elasticsearch/reference/8.15/mapping-routing-field.html)
</span>  <span class='comment'># based on the specified field. ElasticGraph optimizes queries that filter on the shard routing field so that they only run on a
</span>  <span class='comment'># subset of nodes instead of all nodes. This can make a big difference in query performance if queries usually filter on a certain
</span>  <span class='comment'># field. Using an appropriate field for shard routing is often essential for horizontal scaling, as it avoids having every query
</span>  <span class='comment'># hit every node, allowing additional nodes to increase query throughput.
</span>  <span class='comment'>#
</span>  <span class='comment'># @note it is essential that the shards are well-balanced. If the data’s distribution is lopsided, using this feature can make
</span>  <span class='comment'>#   performance worse.
</span>  <span class='comment'># @note the routing field specified here **must be immutable**. If ElasticGraph receives an updated version of a document with a
</span>  <span class='comment'>#   different routing value, it’ll write the new version of the document to a different shard and leave the copy on the old shard
</span>  <span class='comment'>#   unchanged, leading to duplicates.
</span>  <span class='comment'># @note changing the shard routing configuration on an existing index that already has data will result in duplicate documents
</span>  <span class='comment'>#
</span>  <span class='comment'># @param routing_field_path_name [String] dot-separated path to the field used for shard routing. Note: all referenced
</span>  <span class='comment'>#   fields must exist when this is called.
</span>  <span class='comment'># @return [void]
</span>  <span class='comment'>#
</span>  <span class='comment'># @example Define a `campaigns` index to shard on `organizationId`
</span>  <span class='comment'>#   ElasticGraph.define_schema do |schema|
</span>  <span class='comment'>#     schema.object_type &quot;Campaign&quot; do |t|
</span>  <span class='comment'>#       t.field &quot;id&quot;, &quot;ID!&quot;
</span>  <span class='comment'>#       t.field &quot;name&quot;, &quot;String&quot;
</span>  <span class='comment'>#       t.field &quot;organizationId&quot;, &quot;ID&quot;
</span>  <span class='comment'>#
</span>  <span class='comment'>#       t.index &quot;campaigns&quot;do |i|
</span>  <span class='comment'>#         i.route_with &quot;organizationId&quot;
</span>  <span class='comment'>#       end
</span>  <span class='comment'>#     end
</span>  <span class='comment'>#   end
</span>  <span class='kw'>def</span> <span class='id identifier rubyid_route_with'>route_with</span><span class='lparen'>(</span><span class='id identifier rubyid_routing_field_path_name'>routing_field_path_name</span><span class='rparen'>)</span>
    <span class='id identifier rubyid_routing_field_path'>routing_field_path</span> <span class='op'>=</span> <span class='id identifier rubyid_public_field_path'>public_field_path</span><span class='lparen'>(</span><span class='id identifier rubyid_routing_field_path_name'>routing_field_path_name</span><span class='comma'>,</span> <span class='label'>explanation:</span> <span class='tstring'><span class='tstring_beg'>&quot;</span><span class='tstring_content'>it is referenced as an index `route_with` field</span><span class='tstring_end'>&quot;</span></span><span class='rparen'>)</span>

    <span class='kw'>unless</span> <span class='id identifier rubyid_routing_field_path'>routing_field_path</span><span class='period'>.</span><span class='id identifier rubyid_type'>type</span><span class='period'>.</span><span class='id identifier rubyid_leaf?'>leaf?</span>
      <span class='id identifier rubyid_raise'>raise</span> <span class='const'>Errors</span><span class='op'>::</span><span class='const'>SchemaError</span><span class='comma'>,</span> <span class='tstring'><span class='tstring_beg'>&quot;</span><span class='tstring_content'>shard routing field `</span><span class='embexpr_beg'>#{</span><span class='id identifier rubyid_routing_field_path'>routing_field_path</span><span class='period'>.</span><span class='id identifier rubyid_full_description'>full_description</span><span class='embexpr_end'>}</span><span class='tstring_content'>` cannot be used for routing since it is not a leaf field.</span><span class='tstring_end'>&quot;</span></span>
    <span class='kw'>end</span>

    <span class='kw'>self</span><span class='period'>.</span><span class='id identifier rubyid_routing_field_path'>routing_field_path</span> <span class='op'>=</span> <span class='id identifier rubyid_routing_field_path'>routing_field_path</span>

    <span class='id identifier rubyid_routing_field_path'>routing_field_path</span><span class='period'>.</span><span class='id identifier rubyid_path_parts'>path_parts</span><span class='lbracket'>[</span><span class='int'>0</span><span class='op'>..</span><span class='op'>-</span><span class='int'>2</span><span class='rbracket'>]</span><span class='period'>.</span><span class='id identifier rubyid_each'>each</span> <span class='lbrace'>{</span> <span class='op'>|</span><span class='id identifier rubyid_f'>f</span><span class='op'>|</span> <span class='id identifier rubyid_f'>f</span><span class='period'>.</span><span class='id identifier rubyid_json_schema'>json_schema</span> <span class='label'>nullable:</span> <span class='kw'>false</span> <span class='rbrace'>}</span>
    <span class='id identifier rubyid_routing_field_path'>routing_field_path</span><span class='period'>.</span><span class='id identifier rubyid_last_part'>last_part</span><span class='period'>.</span><span class='id identifier rubyid_json_schema'>json_schema</span> <span class='label'>nullable:</span> <span class='kw'>false</span><span class='comma'>,</span> <span class='label'>pattern:</span> <span class='const'>HAS_NON_WHITE_SPACE_REGEX</span>
    <span class='id identifier rubyid_indexed_type'>indexed_type</span><span class='period'>.</span><span class='id identifier rubyid_append_to_documentation'>append_to_documentation</span> <span class='tstring'><span class='tstring_beg'>&quot;</span><span class='tstring_content'>For more performant queries on this type, please filter on `</span><span class='embexpr_beg'>#{</span><span class='id identifier rubyid_routing_field_path_name'>routing_field_path_name</span><span class='embexpr_end'>}</span><span class='tstring_content'>` if possible.</span><span class='tstring_end'>&quot;</span></span>
  <span class='kw'>end</span>

  <span class='comment'># @see #route_with
</span>  <span class='comment'># @return [Boolean] whether or not this index uses custom shard routing
</span>  <span class='kw'>def</span> <span class='id identifier rubyid_uses_custom_routing?'>uses_custom_routing?</span>
    <span class='id identifier rubyid_routing_field_path'>routing_field_path</span><span class='period'>.</span><span class='id identifier rubyid_path_in_index'>path_in_index</span> <span class='op'>!=</span> <span class='tstring'><span class='tstring_beg'>&quot;</span><span class='tstring_content'>id</span><span class='tstring_end'>&quot;</span></span>
  <span class='kw'>end</span>

  <span class='comment'># @return [Hash&lt;String, Object&gt;] datastore configuration for this index for when it does not use rollover
</span>  <span class='kw'>def</span> <span class='id identifier rubyid_to_index_config'>to_index_config</span>
    <span class='lbrace'>{</span>
      <span class='tstring'><span class='tstring_beg'>&quot;</span><span class='tstring_content'>aliases</span><span class='tstring_end'>&quot;</span></span> <span class='op'>=&gt;</span> <span class='lbrace'>{</span><span class='rbrace'>}</span><span class='comma'>,</span>
      <span class='tstring'><span class='tstring_beg'>&quot;</span><span class='tstring_content'>mappings</span><span class='tstring_end'>&quot;</span></span> <span class='op'>=&gt;</span> <span class='id identifier rubyid_mappings'>mappings</span><span class='comma'>,</span>
      <span class='tstring'><span class='tstring_beg'>&quot;</span><span class='tstring_content'>settings</span><span class='tstring_end'>&quot;</span></span> <span class='op'>=&gt;</span> <span class='id identifier rubyid_settings'>settings</span>
    <span class='rbrace'>}</span><span class='period'>.</span><span class='id identifier rubyid_compact'>compact</span>
  <span class='kw'>end</span>

  <span class='comment'># @return [Hash&lt;String, Object&gt;] datastore configuration for the index template that will be defined if rollover is used
</span>  <span class='kw'>def</span> <span class='id identifier rubyid_to_index_template_config'>to_index_template_config</span>
    <span class='lbrace'>{</span>
      <span class='tstring'><span class='tstring_beg'>&quot;</span><span class='tstring_content'>index_patterns</span><span class='tstring_end'>&quot;</span></span> <span class='op'>=&gt;</span> <span class='lbracket'>[</span><span class='tstring'><span class='tstring_beg'>&quot;</span><span class='embexpr_beg'>#{</span><span class='id identifier rubyid_name'>name</span><span class='embexpr_end'>}</span><span class='embexpr_beg'>#{</span><span class='const'>ROLLOVER_INDEX_INFIX_MARKER</span><span class='embexpr_end'>}</span><span class='tstring_content'>*</span><span class='tstring_end'>&quot;</span></span><span class='rbracket'>]</span><span class='comma'>,</span>
      <span class='tstring'><span class='tstring_beg'>&quot;</span><span class='tstring_content'>template</span><span class='tstring_end'>&quot;</span></span> <span class='op'>=&gt;</span> <span class='lbrace'>{</span>
        <span class='tstring'><span class='tstring_beg'>&quot;</span><span class='tstring_content'>aliases</span><span class='tstring_end'>&quot;</span></span> <span class='op'>=&gt;</span> <span class='lbrace'>{</span><span class='rbrace'>}</span><span class='comma'>,</span>
        <span class='tstring'><span class='tstring_beg'>&quot;</span><span class='tstring_content'>mappings</span><span class='tstring_end'>&quot;</span></span> <span class='op'>=&gt;</span> <span class='id identifier rubyid_mappings'>mappings</span><span class='comma'>,</span>
        <span class='tstring'><span class='tstring_beg'>&quot;</span><span class='tstring_content'>settings</span><span class='tstring_end'>&quot;</span></span> <span class='op'>=&gt;</span> <span class='id identifier rubyid_settings'>settings</span>
      <span class='rbrace'>}</span>
    <span class='rbrace'>}</span>
  <span class='kw'>end</span>

  <span class='comment'># @return [SchemaArtifacts::RuntimeMetadata::IndexDefinition] runtime metadata for this index
</span>  <span class='kw'>def</span> <span class='id identifier rubyid_runtime_metadata'>runtime_metadata</span>
    <span class='const'>SchemaArtifacts</span><span class='op'>::</span><span class='const'>RuntimeMetadata</span><span class='op'>::</span><span class='const'>IndexDefinition</span><span class='period'>.</span><span class='id identifier rubyid_new'>new</span><span class='lparen'>(</span>
      <span class='label'>route_with:</span> <span class='id identifier rubyid_routing_field_path'>routing_field_path</span><span class='period'>.</span><span class='id identifier rubyid_path_in_index'>path_in_index</span><span class='comma'>,</span>
      <span class='label'>rollover:</span> <span class='id identifier rubyid_rollover_config'>rollover_config</span><span class='op'>&amp;.</span><span class='id identifier rubyid_runtime_metadata'>runtime_metadata</span><span class='comma'>,</span>
      <span class='label'>current_sources:</span> <span class='id identifier rubyid_indexed_type'>indexed_type</span><span class='period'>.</span><span class='id identifier rubyid_current_sources'>current_sources</span><span class='comma'>,</span>
      <span class='label'>fields_by_path:</span> <span class='id identifier rubyid_indexed_type'>indexed_type</span><span class='period'>.</span><span class='id identifier rubyid_index_field_runtime_metadata_tuples'>index_field_runtime_metadata_tuples</span><span class='period'>.</span><span class='id identifier rubyid_to_h'>to_h</span><span class='comma'>,</span>
      <span class='label'>default_sort_fields:</span> <span class='id identifier rubyid_default_sort_pairs'>default_sort_pairs</span><span class='period'>.</span><span class='id identifier rubyid_each_slice'>each_slice</span><span class='lparen'>(</span><span class='int'>2</span><span class='rparen'>)</span><span class='period'>.</span><span class='id identifier rubyid_map'>map</span> <span class='kw'>do</span> <span class='op'>|</span><span class='lparen'>(</span><span class='id identifier rubyid_graphql_field_path_name'>graphql_field_path_name</span><span class='comma'>,</span> <span class='id identifier rubyid_direction'>direction</span><span class='rparen'>)</span><span class='op'>|</span>
        <span class='const'>SchemaArtifacts</span><span class='op'>::</span><span class='const'>RuntimeMetadata</span><span class='op'>::</span><span class='const'>SortField</span><span class='period'>.</span><span class='id identifier rubyid_new'>new</span><span class='lparen'>(</span>
          <span class='label'>field_path:</span> <span class='id identifier rubyid_public_field_path'>public_field_path</span><span class='lparen'>(</span><span class='id identifier rubyid_graphql_field_path_name'>graphql_field_path_name</span><span class='comma'>,</span> <span class='label'>explanation:</span> <span class='tstring'><span class='tstring_beg'>&quot;</span><span class='tstring_content'>it is referenced as an index `default_sort` field</span><span class='tstring_end'>&quot;</span></span><span class='rparen'>)</span><span class='period'>.</span><span class='id identifier rubyid_path_in_index'>path_in_index</span><span class='comma'>,</span>
          <span class='label'>direction:</span> <span class='id identifier rubyid_direction'>direction</span>
        <span class='rparen'>)</span>
      <span class='kw'>end</span>
    <span class='rparen'>)</span>
  <span class='kw'>end</span>

  <span class='id identifier rubyid_private'>private</span>

  <span class='comment'># A regex that requires at least one non-whitespace character.
</span>  <span class='comment'># Note: this does not use the `/S` character class because it&#39;s recommended to use a small subset
</span>  <span class='comment'># of Regex syntax:
</span>  <span class='comment'>#
</span>  <span class='comment'># &gt; The regular expression syntax used is from JavaScript (ECMA 262, specifically). However, that
</span>  <span class='comment'># &gt; complete syntax is not widely supported, therefore it is recommended that you stick to the subset
</span>  <span class='comment'># &gt; of that syntax described below.
</span>  <span class='comment'>#
</span>  <span class='comment'># (From https://json-schema.org/understanding-json-schema/reference/regular_expressions.html)
</span>  <span class='const'>HAS_NON_WHITE_SPACE_REGEX</span> <span class='op'>=</span> <span class='tstring'><span class='tstring_beg'>&quot;</span><span class='tstring_content'>[^ \t\n]+</span><span class='tstring_end'>&quot;</span></span>

  <span class='const'>DEFAULT_SETTINGS</span> <span class='op'>=</span> <span class='lbrace'>{</span>
    <span class='tstring'><span class='tstring_beg'>&quot;</span><span class='tstring_content'>index.mapping.ignore_malformed</span><span class='tstring_end'>&quot;</span></span> <span class='op'>=&gt;</span> <span class='kw'>false</span><span class='comma'>,</span>
    <span class='tstring'><span class='tstring_beg'>&quot;</span><span class='tstring_content'>index.mapping.coerce</span><span class='tstring_end'>&quot;</span></span> <span class='op'>=&gt;</span> <span class='kw'>false</span><span class='comma'>,</span>
    <span class='tstring'><span class='tstring_beg'>&quot;</span><span class='tstring_content'>index.number_of_replicas</span><span class='tstring_end'>&quot;</span></span> <span class='op'>=&gt;</span> <span class='int'>1</span><span class='comma'>,</span>
    <span class='tstring'><span class='tstring_beg'>&quot;</span><span class='tstring_content'>index.number_of_shards</span><span class='tstring_end'>&quot;</span></span> <span class='op'>=&gt;</span> <span class='int'>1</span>
  <span class='rbrace'>}</span>

  <span class='kw'>def</span> <span class='id identifier rubyid_mappings'>mappings</span>
    <span class='id identifier rubyid_field_mappings'>field_mappings</span> <span class='op'>=</span> <span class='id identifier rubyid_indexed_type'>indexed_type</span>
      <span class='period'>.</span><span class='id identifier rubyid_to_indexing_field_type'>to_indexing_field_type</span>
      <span class='period'>.</span><span class='id identifier rubyid_to_mapping'>to_mapping</span>
      <span class='period'>.</span><span class='id identifier rubyid_except'>except</span><span class='lparen'>(</span><span class='tstring'><span class='tstring_beg'>&quot;</span><span class='tstring_content'>type</span><span class='tstring_end'>&quot;</span></span><span class='rparen'>)</span> <span class='comment'># `type` is invalid at the mapping root because it always has to be an object.
</span>      <span class='period'>.</span><span class='id identifier rubyid_then'>then</span> <span class='lbrace'>{</span> <span class='op'>|</span><span class='id identifier rubyid_mapping'>mapping</span><span class='op'>|</span> <span class='const'>ListCountsMapping</span><span class='period'>.</span><span class='id identifier rubyid_merged_into'>merged_into</span><span class='lparen'>(</span><span class='id identifier rubyid_mapping'>mapping</span><span class='comma'>,</span> <span class='label'>for_type:</span> <span class='id identifier rubyid_indexed_type'>indexed_type</span><span class='rparen'>)</span> <span class='rbrace'>}</span>
      <span class='period'>.</span><span class='id identifier rubyid_then'>then</span> <span class='kw'>do</span> <span class='op'>|</span><span class='id identifier rubyid_fm'>fm</span><span class='op'>|</span>
        <span class='const'><span class='object_link'><a href="../../Support.html" title="ElasticGraph::Support (module)">Support</a></span></span><span class='op'>::</span><span class='const'>HashUtil</span><span class='period'>.</span><span class='id identifier rubyid_deep_merge'>deep_merge</span><span class='lparen'>(</span><span class='id identifier rubyid_fm'>fm</span><span class='comma'>,</span> <span class='lbrace'>{</span><span class='tstring'><span class='tstring_beg'>&quot;</span><span class='tstring_content'>properties</span><span class='tstring_end'>&quot;</span></span> <span class='op'>=&gt;</span> <span class='lbrace'>{</span>
          <span class='tstring'><span class='tstring_beg'>&quot;</span><span class='tstring_content'>__sources</span><span class='tstring_end'>&quot;</span></span> <span class='op'>=&gt;</span> <span class='lbrace'>{</span><span class='tstring'><span class='tstring_beg'>&quot;</span><span class='tstring_content'>type</span><span class='tstring_end'>&quot;</span></span> <span class='op'>=&gt;</span> <span class='tstring'><span class='tstring_beg'>&quot;</span><span class='tstring_content'>keyword</span><span class='tstring_end'>&quot;</span></span><span class='rbrace'>}</span><span class='comma'>,</span>
          <span class='tstring'><span class='tstring_beg'>&quot;</span><span class='tstring_content'>__versions</span><span class='tstring_end'>&quot;</span></span> <span class='op'>=&gt;</span> <span class='lbrace'>{</span>
            <span class='tstring'><span class='tstring_beg'>&quot;</span><span class='tstring_content'>type</span><span class='tstring_end'>&quot;</span></span> <span class='op'>=&gt;</span> <span class='tstring'><span class='tstring_beg'>&quot;</span><span class='tstring_content'>object</span><span class='tstring_end'>&quot;</span></span><span class='comma'>,</span>
            <span class='comment'># __versions is map keyed by relationship name, with values that are maps keyed by id. Since it&#39;s not
</span>            <span class='comment'># a static object with known fields, we need to use dynamic here. Passing `false` allows some level
</span>            <span class='comment'># of dynamicness. As per https://www.elastic.co/guide/en/elasticsearch/reference/8.7/dynamic.html#dynamic-parameters:
</span>            <span class='comment'>#
</span>            <span class='comment'># &gt; New fields are ignored. These fields will not be indexed or searchable, but will still appear in the _source
</span>            <span class='comment'># &gt; field of returned hits. These fields will not be added to the mapping, and new fields must be added explicitly.
</span>            <span class='comment'>#
</span>            <span class='comment'># We need `__versions` to be in `_source` (so that our update scripts can operate on it), but
</span>            <span class='comment'># have no need for it to be searchable (as it&#39;s just an internal data structure used for indexing).
</span>            <span class='comment'>#
</span>            <span class='comment'># Note: we intentionally set false as a string here, because that&#39;s how the datastore echoes it back
</span>            <span class='comment'># to us when you query the mapping (even if you set it as a boolean). Our checks for index mapping
</span>            <span class='comment'># consistency fail validation if we set it as a boolean since the datastore doesn&#39;t echo it back as
</span>            <span class='comment'># a boolean.
</span>            <span class='tstring'><span class='tstring_beg'>&quot;</span><span class='tstring_content'>dynamic</span><span class='tstring_end'>&quot;</span></span> <span class='op'>=&gt;</span> <span class='tstring'><span class='tstring_beg'>&quot;</span><span class='tstring_content'>false</span><span class='tstring_end'>&quot;</span></span>
          <span class='rbrace'>}</span>
        <span class='rbrace'>}</span><span class='rbrace'>}</span><span class='rparen'>)</span>
      <span class='kw'>end</span>

    <span class='lbrace'>{</span><span class='tstring'><span class='tstring_beg'>&quot;</span><span class='tstring_content'>dynamic</span><span class='tstring_end'>&quot;</span></span> <span class='op'>=&gt;</span> <span class='tstring'><span class='tstring_beg'>&quot;</span><span class='tstring_content'>strict</span><span class='tstring_end'>&quot;</span></span><span class='rbrace'>}</span><span class='period'>.</span><span class='id identifier rubyid_merge'>merge</span><span class='lparen'>(</span><span class='id identifier rubyid_field_mappings'>field_mappings</span><span class='rparen'>)</span><span class='period'>.</span><span class='id identifier rubyid_tap'>tap</span> <span class='kw'>do</span> <span class='op'>|</span><span class='id identifier rubyid_hash'>hash</span><span class='op'>|</span>
      <span class='comment'># If we are using custom shard routing, we want to require a `routing` value to be provided
</span>      <span class='comment'># in every single index, get, delete or update request; otherwise the request might be
</span>      <span class='comment'># made against the wrong shard.
</span>      <span class='id identifier rubyid_hash'>hash</span><span class='lbracket'>[</span><span class='tstring'><span class='tstring_beg'>&quot;</span><span class='tstring_content'>_routing</span><span class='tstring_end'>&quot;</span></span><span class='rbracket'>]</span> <span class='op'>=</span> <span class='lbrace'>{</span><span class='tstring'><span class='tstring_beg'>&quot;</span><span class='tstring_content'>required</span><span class='tstring_end'>&quot;</span></span> <span class='op'>=&gt;</span> <span class='kw'>true</span><span class='rbrace'>}</span> <span class='kw'>if</span> <span class='id identifier rubyid_uses_custom_routing?'>uses_custom_routing?</span>
      <span class='id identifier rubyid_hash'>hash</span><span class='lbracket'>[</span><span class='tstring'><span class='tstring_beg'>&quot;</span><span class='tstring_content'>_size</span><span class='tstring_end'>&quot;</span></span><span class='rbracket'>]</span> <span class='op'>=</span> <span class='lbrace'>{</span><span class='tstring'><span class='tstring_beg'>&quot;</span><span class='tstring_content'>enabled</span><span class='tstring_end'>&quot;</span></span> <span class='op'>=&gt;</span> <span class='kw'>true</span><span class='rbrace'>}</span> <span class='kw'>if</span> <span class='id identifier rubyid_schema_def_state'>schema_def_state</span><span class='period'>.</span><span class='id identifier rubyid_index_document_sizes?'>index_document_sizes?</span>
    <span class='kw'>end</span>
  <span class='kw'>end</span>

  <span class='kw'>def</span> <span class='id identifier rubyid_public_field_path'>public_field_path</span><span class='lparen'>(</span><span class='id identifier rubyid_public_path_string'>public_path_string</span><span class='comma'>,</span> <span class='label'>explanation:</span><span class='rparen'>)</span>
    <span class='id identifier rubyid_parent_is_not_list'>parent_is_not_list</span> <span class='op'>=</span> <span class='tlambda'>-&gt;</span><span class='lparen'>(</span><span class='id identifier rubyid_parent_field'>parent_field</span><span class='rparen'>)</span> <span class='tlambeg'>{</span> <span class='op'>!</span><span class='id identifier rubyid_parent_field'>parent_field</span><span class='period'>.</span><span class='id identifier rubyid_type'>type</span><span class='period'>.</span><span class='id identifier rubyid_list?'>list?</span> <span class='rbrace'>}</span>
    <span class='id identifier rubyid_resolver'>resolver</span> <span class='op'>=</span> <span class='const'><span class='object_link'><a href="../SchemaElements.html" title="ElasticGraph::SchemaDefinition::SchemaElements (module)">SchemaElements</a></span></span><span class='op'>::</span><span class='const'>FieldPath</span><span class='op'>::</span><span class='const'>Resolver</span><span class='period'>.</span><span class='id identifier rubyid_new'>new</span>
    <span class='id identifier rubyid_resolved_path'>resolved_path</span> <span class='op'>=</span> <span class='id identifier rubyid_resolver'>resolver</span><span class='period'>.</span><span class='id identifier rubyid_resolve_public_path'>resolve_public_path</span><span class='lparen'>(</span><span class='id identifier rubyid_indexed_type'>indexed_type</span><span class='comma'>,</span> <span class='id identifier rubyid_public_path_string'>public_path_string</span><span class='comma'>,</span> <span class='op'>&amp;</span><span class='id identifier rubyid_parent_is_not_list'>parent_is_not_list</span><span class='rparen'>)</span>
    <span class='kw'>return</span> <span class='id identifier rubyid_resolved_path'>resolved_path</span> <span class='kw'>if</span> <span class='id identifier rubyid_resolved_path'>resolved_path</span>

    <span class='id identifier rubyid_path_parts'>path_parts</span> <span class='op'>=</span> <span class='id identifier rubyid_public_path_string'>public_path_string</span><span class='period'>.</span><span class='id identifier rubyid_split'>split</span><span class='lparen'>(</span><span class='tstring'><span class='tstring_beg'>&quot;</span><span class='tstring_content'>.</span><span class='tstring_end'>&quot;</span></span><span class='rparen'>)</span>
    <span class='id identifier rubyid_error_msg'>error_msg</span> <span class='op'>=</span> <span class='tstring'><span class='tstring_beg'>&quot;</span><span class='tstring_content'>Field `</span><span class='embexpr_beg'>#{</span><span class='id identifier rubyid_indexed_type'>indexed_type</span><span class='period'>.</span><span class='id identifier rubyid_name'>name</span><span class='embexpr_end'>}</span><span class='tstring_content'>.</span><span class='embexpr_beg'>#{</span><span class='id identifier rubyid_public_path_string'>public_path_string</span><span class='embexpr_end'>}</span><span class='tstring_content'>` cannot be resolved, but </span><span class='embexpr_beg'>#{</span><span class='id identifier rubyid_explanation'>explanation</span><span class='embexpr_end'>}</span><span class='tstring_content'>.</span><span class='tstring_end'>&quot;</span></span>

    <span class='comment'># If it is a nested field path, the problem could be that a type has been referenced which does not exist, so mention that.
</span>    <span class='kw'>if</span> <span class='id identifier rubyid_path_parts'>path_parts</span><span class='period'>.</span><span class='id identifier rubyid_size'>size</span> <span class='op'>&gt;</span> <span class='int'>1</span>
      <span class='id identifier rubyid_error_msg'>error_msg</span> <span class='op'>+=</span> <span class='tstring'><span class='tstring_beg'>&quot;</span><span class='tstring_content'> Verify that all fields and types referenced by `</span><span class='embexpr_beg'>#{</span><span class='id identifier rubyid_public_path_string'>public_path_string</span><span class='embexpr_end'>}</span><span class='tstring_content'>` are defined.</span><span class='tstring_end'>&quot;</span></span>
    <span class='kw'>end</span>

    <span class='comment'># If the first part of the path doesn&#39;t resolve, the problem could be that the field is defined after the `index` call
</span>    <span class='comment'># but it needs to be defined before it, so mention that.
</span>    <span class='kw'>if</span> <span class='id identifier rubyid_resolver'>resolver</span><span class='period'>.</span><span class='id identifier rubyid_resolve_public_path'>resolve_public_path</span><span class='lparen'>(</span><span class='id identifier rubyid_indexed_type'>indexed_type</span><span class='comma'>,</span> <span class='id identifier rubyid_path_parts'>path_parts</span><span class='period'>.</span><span class='id identifier rubyid_first'>first</span><span class='comma'>,</span> <span class='op'>&amp;</span><span class='id identifier rubyid_parent_is_not_list'>parent_is_not_list</span><span class='rparen'>)</span><span class='period'>.</span><span class='id identifier rubyid_nil?'>nil?</span>
      <span class='id identifier rubyid_error_msg'>error_msg</span> <span class='op'>+=</span> <span class='tstring'><span class='tstring_beg'>&quot;</span><span class='tstring_content'> Note: the `</span><span class='embexpr_beg'>#{</span><span class='id identifier rubyid_indexed_type'>indexed_type</span><span class='period'>.</span><span class='id identifier rubyid_name'>name</span><span class='embexpr_end'>}</span><span class='tstring_content'>.</span><span class='embexpr_beg'>#{</span><span class='id identifier rubyid_path_parts'>path_parts</span><span class='period'>.</span><span class='id identifier rubyid_first'>first</span><span class='embexpr_end'>}</span><span class='tstring_content'>` definition must come before the `index` call.</span><span class='tstring_end'>&quot;</span></span>
    <span class='kw'>end</span>

    <span class='id identifier rubyid_raise'>raise</span> <span class='const'>Errors</span><span class='op'>::</span><span class='const'>SchemaError</span><span class='comma'>,</span> <span class='id identifier rubyid_error_msg'>error_msg</span>
  <span class='kw'>end</span>

  <span class='kw'>def</span> <span class='id identifier rubyid_date_and_datetime_types'>date_and_datetime_types</span>
    <span class='ivar'>@date_and_datetime_types</span> <span class='op'>||=</span> <span class='qwords_beg'>%w[</span><span class='tstring_content'>Date</span><span class='words_sep'> </span><span class='tstring_content'>DateTime</span><span class='tstring_end'>]</span></span><span class='period'>.</span><span class='id identifier rubyid_map'>map</span> <span class='kw'>do</span> <span class='op'>|</span><span class='id identifier rubyid_type'>type</span><span class='op'>|</span>
      <span class='id identifier rubyid_schema_def_state'>schema_def_state</span><span class='period'>.</span><span class='id identifier rubyid_type_namer'>type_namer</span><span class='period'>.</span><span class='id identifier rubyid_name_for'>name_for</span><span class='lparen'>(</span><span class='id identifier rubyid_type'>type</span><span class='rparen'>)</span>
    <span class='kw'>end</span>
  <span class='kw'>end</span>
<span class='kw'>end</span></pre>
    </td>
  </tr>
</table>
</div>
    
      
      <span id=""></span>
      <div class="method_details ">
  <h3 class="signature " id="indexed_type-instance_method">
  
    #<strong>indexed_type</strong>  &#x21d2; <tt><span class='object_link'><a href="../SchemaElements/ObjectType.html" title="ElasticGraph::SchemaDefinition::SchemaElements::ObjectType (class)">SchemaElements::ObjectType</a></span></tt>, ...  <span class="extras">(readonly)</span>
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    <p>Returns type backed by this index.</p>


  </div>
</div>
<div class="tags">
  
<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt><span class='object_link'><a href="../SchemaElements/ObjectType.html" title="ElasticGraph::SchemaDefinition::SchemaElements::ObjectType (class)">SchemaElements::ObjectType</a></span></tt>, <tt><span class='object_link'><a href="../SchemaElements/InterfaceType.html" title="ElasticGraph::SchemaDefinition::SchemaElements::InterfaceType (class)">SchemaElements::InterfaceType</a></span></tt>, <tt><span class='object_link'><a href="../SchemaElements/UnionType.html" title="ElasticGraph::SchemaDefinition::SchemaElements::UnionType (class)">SchemaElements::UnionType</a></span></tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>type backed by this index</p>
</div>
      
    </li>
  
</ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
55
56
57
58
59
60
61
62
63
64
65
66
67
68
69
70
71
72
73
74
75
76
77
78
79
80
81
82
83
84
85
86
87
88
89
90
91
92
93
94
95
96
97
98
99
100
101
102
103
104
105
106
107
108
109
110
111
112
113
114
115
116
117
118
119
120
121
122
123
124
125
126
127
128
129
130
131
132
133
134
135
136
137
138
139
140
141
142
143
144
145
146
147
148
149
150
151
152
153
154
155
156
157
158
159
160
161
162
163
164
165
166
167
168
169
170
171
172
173
174
175
176
177
178
179
180
181
182
183
184
185
186
187
188
189
190
191
192
193
194
195
196
197
198
199
200
201
202
203
204
205
206
207
208
209
210
211
212
213
214
215
216
217
218
219
220
221
222
223
224
225
226
227
228
229
230
231
232
233
234
235
236
237
238
239
240
241
242
243
244
245
246
247
248
249
250
251
252
253
254
255
256
257
258
259
260
261
262
263
264
265
266
267
268
269
270
271
272
273
274
275
276
277
278
279
280
281
282
283
284
285
286
287
288
289
290
291
292
293
294
295
296
297
298
299
300
301
302
303
304
305
306
307
308
309
310
311
312
313
314
315</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'elasticgraph-schema_definition/lib/elastic_graph/schema_definition/indexing/index.rb', line 39</span>

<span class='kw'>class</span> <span class='const'><span class='object_link'><a href="" title="ElasticGraph::SchemaDefinition::Indexing::Index (class)">Index</a></span></span> <span class='op'>&lt;</span> <span class='const'>Struct</span><span class='period'>.</span><span class='id identifier rubyid_new'>new</span><span class='lparen'>(</span><span class='symbol'>:name</span><span class='comma'>,</span> <span class='symbol'>:default_sort_pairs</span><span class='comma'>,</span> <span class='symbol'>:settings</span><span class='comma'>,</span> <span class='symbol'>:schema_def_state</span><span class='comma'>,</span> <span class='symbol'>:indexed_type</span><span class='comma'>,</span> <span class='symbol'>:routing_field_path</span><span class='comma'>,</span> <span class='symbol'>:rollover_config</span><span class='rparen'>)</span>
  <span class='id identifier rubyid_include'>include</span> <span class='const'><span class='object_link'><a href="../Mixins.html" title="ElasticGraph::SchemaDefinition::Mixins (module)">Mixins</a></span></span><span class='op'>::</span><span class='const'>HasReadableToSAndInspect</span><span class='period'>.</span><span class='id identifier rubyid_new'>new</span> <span class='lbrace'>{</span> <span class='op'>|</span><span class='id identifier rubyid_i'>i</span><span class='op'>|</span> <span class='id identifier rubyid_i'>i</span><span class='period'>.</span><span class='id identifier rubyid_name'>name</span> <span class='rbrace'>}</span>

  <span class='comment'># @param name [String] name of the index
</span>  <span class='comment'># @param settings [Hash&lt;(String, Object)&gt;] datastore settings for the index
</span>  <span class='comment'># @param schema_def_state [State] schema definition state
</span>  <span class='comment'># @param indexed_type [SchemaElements::ObjectType, SchemaElements::InterfaceType, SchemaElements::UnionType] type backed by this index
</span>  <span class='comment'># @yield [Index] the index, for further customization
</span>  <span class='comment'># @api private
</span>  <span class='kw'>def</span> <span class='id identifier rubyid_initialize'>initialize</span><span class='lparen'>(</span><span class='id identifier rubyid_name'>name</span><span class='comma'>,</span> <span class='id identifier rubyid_settings'>settings</span><span class='comma'>,</span> <span class='id identifier rubyid_schema_def_state'>schema_def_state</span><span class='comma'>,</span> <span class='id identifier rubyid_indexed_type'>indexed_type</span><span class='rparen'>)</span>
    <span class='kw'>if</span> <span class='id identifier rubyid_name'>name</span><span class='period'>.</span><span class='id identifier rubyid_include?'>include?</span><span class='lparen'>(</span><span class='const'>ROLLOVER_INDEX_INFIX_MARKER</span><span class='rparen'>)</span>
      <span class='id identifier rubyid_raise'>raise</span> <span class='const'>Errors</span><span class='op'>::</span><span class='const'>SchemaError</span><span class='comma'>,</span> <span class='tstring'><span class='tstring_beg'>&quot;</span><span class='tstring_content'>`</span><span class='embexpr_beg'>#{</span><span class='id identifier rubyid_name'>name</span><span class='embexpr_end'>}</span><span class='tstring_content'>` is an invalid index definition name since it contains </span><span class='tstring_end'>&quot;</span></span> \
        <span class='tstring'><span class='tstring_beg'>&quot;</span><span class='tstring_content'>`</span><span class='embexpr_beg'>#{</span><span class='const'>ROLLOVER_INDEX_INFIX_MARKER</span><span class='embexpr_end'>}</span><span class='tstring_content'>` which ElasticGraph treats as special.</span><span class='tstring_end'>&quot;</span></span>
    <span class='kw'>end</span>

    <span class='id identifier rubyid_settings'>settings</span> <span class='op'>=</span> <span class='const'>DEFAULT_SETTINGS</span><span class='period'>.</span><span class='id identifier rubyid_merge'>merge</span><span class='lparen'>(</span><span class='const'><span class='object_link'><a href="../../Support.html" title="ElasticGraph::Support (module)">Support</a></span></span><span class='op'>::</span><span class='const'>HashUtil</span><span class='period'>.</span><span class='id identifier rubyid_flatten_and_stringify_keys'>flatten_and_stringify_keys</span><span class='lparen'>(</span><span class='id identifier rubyid_settings'>settings</span><span class='comma'>,</span> <span class='label'>prefix:</span> <span class='tstring'><span class='tstring_beg'>&quot;</span><span class='tstring_content'>index</span><span class='tstring_end'>&quot;</span></span><span class='rparen'>)</span><span class='rparen'>)</span>

    <span class='kw'>super</span><span class='lparen'>(</span><span class='id identifier rubyid_name'>name</span><span class='comma'>,</span> <span class='lbracket'>[</span><span class='rbracket'>]</span><span class='comma'>,</span> <span class='id identifier rubyid_settings'>settings</span><span class='comma'>,</span> <span class='id identifier rubyid_schema_def_state'>schema_def_state</span><span class='comma'>,</span> <span class='id identifier rubyid_indexed_type'>indexed_type</span><span class='comma'>,</span> <span class='lbracket'>[</span><span class='rbracket'>]</span><span class='comma'>,</span> <span class='kw'>nil</span><span class='rparen'>)</span>

    <span class='comment'># `id` is the field Elasticsearch/OpenSearch use for routing by default:
</span>    <span class='comment'># https://www.elastic.co/guide/en/elasticsearch/reference/current/mapping-routing-field.html
</span>    <span class='comment'># By using it here, it will cause queries to pass a `routing` parameter when
</span>    <span class='comment'># searching with id filtering on an index that does not use custom shard routing, giving
</span>    <span class='comment'># us a nice efficiency boost.
</span>    <span class='kw'>self</span><span class='period'>.</span><span class='id identifier rubyid_routing_field_path'>routing_field_path</span> <span class='op'>=</span> <span class='id identifier rubyid_public_field_path'>public_field_path</span><span class='lparen'>(</span><span class='tstring'><span class='tstring_beg'>&quot;</span><span class='tstring_content'>id</span><span class='tstring_end'>&quot;</span></span><span class='comma'>,</span> <span class='label'>explanation:</span> <span class='tstring'><span class='tstring_beg'>&quot;</span><span class='tstring_content'>indexed types must have an `id` field</span><span class='tstring_end'>&quot;</span></span><span class='rparen'>)</span>

    <span class='kw'>yield</span> <span class='kw'>self</span> <span class='kw'>if</span> <span class='id identifier rubyid_block_given?'>block_given?</span>
  <span class='kw'>end</span>

  <span class='comment'># Specifies how documents in this index should sort by default, when no `orderBy` argument is provided to the GraphQL query.
</span>  <span class='comment'>#
</span>  <span class='comment'># @note the field name strings can be a dot-separated nested fields, but all referenced
</span>  <span class='comment'>#   fields must exist when this is called.
</span>  <span class='comment'>#
</span>  <span class='comment'># @param field_name_direction_pairs [Array&lt;(String, Symbol)&gt;] pairs of field names and `:asc` or `:desc`
</span>  <span class='comment'># @return [void]
</span>  <span class='comment'>#
</span>  <span class='comment'># @example Sort on `name` (ascending) with `createdAt` (descending) as a tie-breaker
</span>  <span class='comment'>#   ElasticGraph.define_schema do |schema|
</span>  <span class='comment'>#     schema.object_type &quot;Campaign&quot; do |t|
</span>  <span class='comment'>#       t.field &quot;id&quot;, &quot;ID!&quot;
</span>  <span class='comment'>#       t.field &quot;name&quot;, &quot;String&quot;
</span>  <span class='comment'>#       t.field &quot;createdAt&quot;, &quot;DateTime&quot;
</span>  <span class='comment'>#
</span>  <span class='comment'>#       t.index &quot;campaigns&quot;do |i|
</span>  <span class='comment'>#         i.default_sort &quot;name&quot;, :asc, &quot;createdAt&quot;, :desc
</span>  <span class='comment'>#       end
</span>  <span class='comment'>#     end
</span>  <span class='comment'>#   end
</span>  <span class='kw'>def</span> <span class='id identifier rubyid_default_sort'>default_sort</span><span class='lparen'>(</span><span class='op'>*</span><span class='id identifier rubyid_field_name_direction_pairs'>field_name_direction_pairs</span><span class='rparen'>)</span>
    <span class='kw'>self</span><span class='period'>.</span><span class='id identifier rubyid_default_sort_pairs'>default_sort_pairs</span> <span class='op'>=</span> <span class='id identifier rubyid_field_name_direction_pairs'>field_name_direction_pairs</span>
  <span class='kw'>end</span>

  <span class='comment'># Causes this index to &quot;rollover&quot; at the provided `frequency` based on the value of the provided `timestamp_field_path_name`.
</span>  <span class='comment'># This is particularly useful for time-series data. Partitioning the data into `hourly`, `daily`, `monthly` or `yearly` buckets
</span>  <span class='comment'># allows for different index configurations, and can be necessary when a dataset is too large to fit in one dataset given
</span>  <span class='comment'># Elasticsearch/OpenSearch limitations on the number of shards in one index. In addition, ElasticGraph optimizes queries which
</span>  <span class='comment'># filter on the timestamp field to target the subset of the indices in which matching documents could reside.
</span>  <span class='comment'>#
</span>  <span class='comment'># @note the timestamp field specified here **must be immutable**. To understand why, consider a `:yearly` rollover
</span>  <span class='comment'>#   index used for data based on `createdAt`; if ElasticGraph ingests record `123` with a createdAt of `2023-12-31T23:59:59Z`, it
</span>  <span class='comment'>#   will be indexed in the `2023` index. Later if it receives an update event for record `123` with a `createdAt` of
</span>  <span class='comment'>#   `2024-01-01T00:00:00Z` (a mere one second later!), ElasticGraph will store the new version of the payment in the `2024` index,
</span>  <span class='comment'>#   and leave the old copy of the payment in the `2023` index unchanged. It’ll have duplicates for that document.
</span>  <span class='comment'># @note changing the `rollover` configuration on an existing index that already has data will result in duplicate documents
</span>  <span class='comment'>#
</span>  <span class='comment'># @param frequency [:yearly, :monthly, :daily, :hourly] how often to rollover the index
</span>  <span class='comment'># @param timestamp_field_path_name [String] dot-separated path to the timestamp field used for rollover. Note: all referenced
</span>  <span class='comment'>#   fields must exist when this is called.
</span>  <span class='comment'># @return [void]
</span>  <span class='comment'>#
</span>  <span class='comment'># @example Define a `campaigns` index to rollover yearly based on `createdAt`
</span>  <span class='comment'>#   ElasticGraph.define_schema do |schema|
</span>  <span class='comment'>#     schema.object_type &quot;Campaign&quot; do |t|
</span>  <span class='comment'>#       t.field &quot;id&quot;, &quot;ID!&quot;
</span>  <span class='comment'>#       t.field &quot;name&quot;, &quot;String&quot;
</span>  <span class='comment'>#       t.field &quot;createdAt&quot;, &quot;DateTime&quot;
</span>  <span class='comment'>#
</span>  <span class='comment'>#       t.index &quot;campaigns&quot;do |i|
</span>  <span class='comment'>#         i.rollover :yearly, &quot;createdAt&quot;
</span>  <span class='comment'>#       end
</span>  <span class='comment'>#     end
</span>  <span class='comment'>#   end
</span>  <span class='kw'>def</span> <span class='id identifier rubyid_rollover'>rollover</span><span class='lparen'>(</span><span class='id identifier rubyid_frequency'>frequency</span><span class='comma'>,</span> <span class='id identifier rubyid_timestamp_field_path_name'>timestamp_field_path_name</span><span class='rparen'>)</span>
    <span class='id identifier rubyid_timestamp_field_path'>timestamp_field_path</span> <span class='op'>=</span> <span class='id identifier rubyid_public_field_path'>public_field_path</span><span class='lparen'>(</span><span class='id identifier rubyid_timestamp_field_path_name'>timestamp_field_path_name</span><span class='comma'>,</span> <span class='label'>explanation:</span> <span class='tstring'><span class='tstring_beg'>&quot;</span><span class='tstring_content'>it is referenced as an index `rollover` field</span><span class='tstring_end'>&quot;</span></span><span class='rparen'>)</span>

    <span class='kw'>unless</span> <span class='id identifier rubyid_date_and_datetime_types'>date_and_datetime_types</span><span class='period'>.</span><span class='id identifier rubyid_include?'>include?</span><span class='lparen'>(</span><span class='id identifier rubyid_timestamp_field_path'>timestamp_field_path</span><span class='period'>.</span><span class='id identifier rubyid_type'>type</span><span class='period'>.</span><span class='id identifier rubyid_fully_unwrapped'>fully_unwrapped</span><span class='period'>.</span><span class='id identifier rubyid_name'>name</span><span class='rparen'>)</span>
      <span class='id identifier rubyid_date_or_datetime_description'>date_or_datetime_description</span> <span class='op'>=</span> <span class='id identifier rubyid_date_and_datetime_types'>date_and_datetime_types</span><span class='period'>.</span><span class='id identifier rubyid_map'>map</span> <span class='lbrace'>{</span> <span class='op'>|</span><span class='id identifier rubyid_t'>t</span><span class='op'>|</span> <span class='tstring'><span class='tstring_beg'>&quot;</span><span class='tstring_content'>`</span><span class='embexpr_beg'>#{</span><span class='id identifier rubyid_t'>t</span><span class='embexpr_end'>}</span><span class='tstring_content'>`</span><span class='tstring_end'>&quot;</span></span> <span class='rbrace'>}</span><span class='period'>.</span><span class='id identifier rubyid_join'>join</span><span class='lparen'>(</span><span class='tstring'><span class='tstring_beg'>&quot;</span><span class='tstring_content'> or </span><span class='tstring_end'>&quot;</span></span><span class='rparen'>)</span>
      <span class='id identifier rubyid_raise'>raise</span> <span class='const'>Errors</span><span class='op'>::</span><span class='const'>SchemaError</span><span class='comma'>,</span> <span class='tstring'><span class='tstring_beg'>&quot;</span><span class='tstring_content'>rollover field `</span><span class='embexpr_beg'>#{</span><span class='id identifier rubyid_timestamp_field_path'>timestamp_field_path</span><span class='period'>.</span><span class='id identifier rubyid_full_description'>full_description</span><span class='embexpr_end'>}</span><span class='tstring_content'>` cannot be used for rollover since it is not a </span><span class='embexpr_beg'>#{</span><span class='id identifier rubyid_date_or_datetime_description'>date_or_datetime_description</span><span class='embexpr_end'>}</span><span class='tstring_content'> field.</span><span class='tstring_end'>&quot;</span></span>
    <span class='kw'>end</span>

    <span class='kw'>if</span> <span class='id identifier rubyid_timestamp_field_path'>timestamp_field_path</span><span class='period'>.</span><span class='id identifier rubyid_type'>type</span><span class='period'>.</span><span class='id identifier rubyid_list?'>list?</span>
      <span class='id identifier rubyid_raise'>raise</span> <span class='const'>Errors</span><span class='op'>::</span><span class='const'>SchemaError</span><span class='comma'>,</span> <span class='tstring'><span class='tstring_beg'>&quot;</span><span class='tstring_content'>rollover field `</span><span class='embexpr_beg'>#{</span><span class='id identifier rubyid_timestamp_field_path'>timestamp_field_path</span><span class='period'>.</span><span class='id identifier rubyid_full_description'>full_description</span><span class='embexpr_end'>}</span><span class='tstring_content'>` cannot be used for rollover since it is a list field.</span><span class='tstring_end'>&quot;</span></span>
    <span class='kw'>end</span>

    <span class='id identifier rubyid_timestamp_field_path'>timestamp_field_path</span><span class='period'>.</span><span class='id identifier rubyid_path_parts'>path_parts</span><span class='period'>.</span><span class='id identifier rubyid_each'>each</span> <span class='lbrace'>{</span> <span class='op'>|</span><span class='id identifier rubyid_f'>f</span><span class='op'>|</span> <span class='id identifier rubyid_f'>f</span><span class='period'>.</span><span class='id identifier rubyid_json_schema'>json_schema</span> <span class='label'>nullable:</span> <span class='kw'>false</span> <span class='rbrace'>}</span>

    <span class='kw'>self</span><span class='period'>.</span><span class='id identifier rubyid_rollover_config'>rollover_config</span> <span class='op'>=</span> <span class='const'>RolloverConfig</span><span class='period'>.</span><span class='id identifier rubyid_new'>new</span><span class='lparen'>(</span>
      <span class='label'>frequency:</span> <span class='id identifier rubyid_frequency'>frequency</span><span class='comma'>,</span>
      <span class='label'>timestamp_field_path:</span> <span class='id identifier rubyid_timestamp_field_path'>timestamp_field_path</span>
    <span class='rparen'>)</span>
  <span class='kw'>end</span>

  <span class='comment'># Configures the index to [route documents to shards](https://www.elastic.co/guide/en/elasticsearch/reference/8.15/mapping-routing-field.html)
</span>  <span class='comment'># based on the specified field. ElasticGraph optimizes queries that filter on the shard routing field so that they only run on a
</span>  <span class='comment'># subset of nodes instead of all nodes. This can make a big difference in query performance if queries usually filter on a certain
</span>  <span class='comment'># field. Using an appropriate field for shard routing is often essential for horizontal scaling, as it avoids having every query
</span>  <span class='comment'># hit every node, allowing additional nodes to increase query throughput.
</span>  <span class='comment'>#
</span>  <span class='comment'># @note it is essential that the shards are well-balanced. If the data’s distribution is lopsided, using this feature can make
</span>  <span class='comment'>#   performance worse.
</span>  <span class='comment'># @note the routing field specified here **must be immutable**. If ElasticGraph receives an updated version of a document with a
</span>  <span class='comment'>#   different routing value, it’ll write the new version of the document to a different shard and leave the copy on the old shard
</span>  <span class='comment'>#   unchanged, leading to duplicates.
</span>  <span class='comment'># @note changing the shard routing configuration on an existing index that already has data will result in duplicate documents
</span>  <span class='comment'>#
</span>  <span class='comment'># @param routing_field_path_name [String] dot-separated path to the field used for shard routing. Note: all referenced
</span>  <span class='comment'>#   fields must exist when this is called.
</span>  <span class='comment'># @return [void]
</span>  <span class='comment'>#
</span>  <span class='comment'># @example Define a `campaigns` index to shard on `organizationId`
</span>  <span class='comment'>#   ElasticGraph.define_schema do |schema|
</span>  <span class='comment'>#     schema.object_type &quot;Campaign&quot; do |t|
</span>  <span class='comment'>#       t.field &quot;id&quot;, &quot;ID!&quot;
</span>  <span class='comment'>#       t.field &quot;name&quot;, &quot;String&quot;
</span>  <span class='comment'>#       t.field &quot;organizationId&quot;, &quot;ID&quot;
</span>  <span class='comment'>#
</span>  <span class='comment'>#       t.index &quot;campaigns&quot;do |i|
</span>  <span class='comment'>#         i.route_with &quot;organizationId&quot;
</span>  <span class='comment'>#       end
</span>  <span class='comment'>#     end
</span>  <span class='comment'>#   end
</span>  <span class='kw'>def</span> <span class='id identifier rubyid_route_with'>route_with</span><span class='lparen'>(</span><span class='id identifier rubyid_routing_field_path_name'>routing_field_path_name</span><span class='rparen'>)</span>
    <span class='id identifier rubyid_routing_field_path'>routing_field_path</span> <span class='op'>=</span> <span class='id identifier rubyid_public_field_path'>public_field_path</span><span class='lparen'>(</span><span class='id identifier rubyid_routing_field_path_name'>routing_field_path_name</span><span class='comma'>,</span> <span class='label'>explanation:</span> <span class='tstring'><span class='tstring_beg'>&quot;</span><span class='tstring_content'>it is referenced as an index `route_with` field</span><span class='tstring_end'>&quot;</span></span><span class='rparen'>)</span>

    <span class='kw'>unless</span> <span class='id identifier rubyid_routing_field_path'>routing_field_path</span><span class='period'>.</span><span class='id identifier rubyid_type'>type</span><span class='period'>.</span><span class='id identifier rubyid_leaf?'>leaf?</span>
      <span class='id identifier rubyid_raise'>raise</span> <span class='const'>Errors</span><span class='op'>::</span><span class='const'>SchemaError</span><span class='comma'>,</span> <span class='tstring'><span class='tstring_beg'>&quot;</span><span class='tstring_content'>shard routing field `</span><span class='embexpr_beg'>#{</span><span class='id identifier rubyid_routing_field_path'>routing_field_path</span><span class='period'>.</span><span class='id identifier rubyid_full_description'>full_description</span><span class='embexpr_end'>}</span><span class='tstring_content'>` cannot be used for routing since it is not a leaf field.</span><span class='tstring_end'>&quot;</span></span>
    <span class='kw'>end</span>

    <span class='kw'>self</span><span class='period'>.</span><span class='id identifier rubyid_routing_field_path'>routing_field_path</span> <span class='op'>=</span> <span class='id identifier rubyid_routing_field_path'>routing_field_path</span>

    <span class='id identifier rubyid_routing_field_path'>routing_field_path</span><span class='period'>.</span><span class='id identifier rubyid_path_parts'>path_parts</span><span class='lbracket'>[</span><span class='int'>0</span><span class='op'>..</span><span class='op'>-</span><span class='int'>2</span><span class='rbracket'>]</span><span class='period'>.</span><span class='id identifier rubyid_each'>each</span> <span class='lbrace'>{</span> <span class='op'>|</span><span class='id identifier rubyid_f'>f</span><span class='op'>|</span> <span class='id identifier rubyid_f'>f</span><span class='period'>.</span><span class='id identifier rubyid_json_schema'>json_schema</span> <span class='label'>nullable:</span> <span class='kw'>false</span> <span class='rbrace'>}</span>
    <span class='id identifier rubyid_routing_field_path'>routing_field_path</span><span class='period'>.</span><span class='id identifier rubyid_last_part'>last_part</span><span class='period'>.</span><span class='id identifier rubyid_json_schema'>json_schema</span> <span class='label'>nullable:</span> <span class='kw'>false</span><span class='comma'>,</span> <span class='label'>pattern:</span> <span class='const'>HAS_NON_WHITE_SPACE_REGEX</span>
    <span class='id identifier rubyid_indexed_type'>indexed_type</span><span class='period'>.</span><span class='id identifier rubyid_append_to_documentation'>append_to_documentation</span> <span class='tstring'><span class='tstring_beg'>&quot;</span><span class='tstring_content'>For more performant queries on this type, please filter on `</span><span class='embexpr_beg'>#{</span><span class='id identifier rubyid_routing_field_path_name'>routing_field_path_name</span><span class='embexpr_end'>}</span><span class='tstring_content'>` if possible.</span><span class='tstring_end'>&quot;</span></span>
  <span class='kw'>end</span>

  <span class='comment'># @see #route_with
</span>  <span class='comment'># @return [Boolean] whether or not this index uses custom shard routing
</span>  <span class='kw'>def</span> <span class='id identifier rubyid_uses_custom_routing?'>uses_custom_routing?</span>
    <span class='id identifier rubyid_routing_field_path'>routing_field_path</span><span class='period'>.</span><span class='id identifier rubyid_path_in_index'>path_in_index</span> <span class='op'>!=</span> <span class='tstring'><span class='tstring_beg'>&quot;</span><span class='tstring_content'>id</span><span class='tstring_end'>&quot;</span></span>
  <span class='kw'>end</span>

  <span class='comment'># @return [Hash&lt;String, Object&gt;] datastore configuration for this index for when it does not use rollover
</span>  <span class='kw'>def</span> <span class='id identifier rubyid_to_index_config'>to_index_config</span>
    <span class='lbrace'>{</span>
      <span class='tstring'><span class='tstring_beg'>&quot;</span><span class='tstring_content'>aliases</span><span class='tstring_end'>&quot;</span></span> <span class='op'>=&gt;</span> <span class='lbrace'>{</span><span class='rbrace'>}</span><span class='comma'>,</span>
      <span class='tstring'><span class='tstring_beg'>&quot;</span><span class='tstring_content'>mappings</span><span class='tstring_end'>&quot;</span></span> <span class='op'>=&gt;</span> <span class='id identifier rubyid_mappings'>mappings</span><span class='comma'>,</span>
      <span class='tstring'><span class='tstring_beg'>&quot;</span><span class='tstring_content'>settings</span><span class='tstring_end'>&quot;</span></span> <span class='op'>=&gt;</span> <span class='id identifier rubyid_settings'>settings</span>
    <span class='rbrace'>}</span><span class='period'>.</span><span class='id identifier rubyid_compact'>compact</span>
  <span class='kw'>end</span>

  <span class='comment'># @return [Hash&lt;String, Object&gt;] datastore configuration for the index template that will be defined if rollover is used
</span>  <span class='kw'>def</span> <span class='id identifier rubyid_to_index_template_config'>to_index_template_config</span>
    <span class='lbrace'>{</span>
      <span class='tstring'><span class='tstring_beg'>&quot;</span><span class='tstring_content'>index_patterns</span><span class='tstring_end'>&quot;</span></span> <span class='op'>=&gt;</span> <span class='lbracket'>[</span><span class='tstring'><span class='tstring_beg'>&quot;</span><span class='embexpr_beg'>#{</span><span class='id identifier rubyid_name'>name</span><span class='embexpr_end'>}</span><span class='embexpr_beg'>#{</span><span class='const'>ROLLOVER_INDEX_INFIX_MARKER</span><span class='embexpr_end'>}</span><span class='tstring_content'>*</span><span class='tstring_end'>&quot;</span></span><span class='rbracket'>]</span><span class='comma'>,</span>
      <span class='tstring'><span class='tstring_beg'>&quot;</span><span class='tstring_content'>template</span><span class='tstring_end'>&quot;</span></span> <span class='op'>=&gt;</span> <span class='lbrace'>{</span>
        <span class='tstring'><span class='tstring_beg'>&quot;</span><span class='tstring_content'>aliases</span><span class='tstring_end'>&quot;</span></span> <span class='op'>=&gt;</span> <span class='lbrace'>{</span><span class='rbrace'>}</span><span class='comma'>,</span>
        <span class='tstring'><span class='tstring_beg'>&quot;</span><span class='tstring_content'>mappings</span><span class='tstring_end'>&quot;</span></span> <span class='op'>=&gt;</span> <span class='id identifier rubyid_mappings'>mappings</span><span class='comma'>,</span>
        <span class='tstring'><span class='tstring_beg'>&quot;</span><span class='tstring_content'>settings</span><span class='tstring_end'>&quot;</span></span> <span class='op'>=&gt;</span> <span class='id identifier rubyid_settings'>settings</span>
      <span class='rbrace'>}</span>
    <span class='rbrace'>}</span>
  <span class='kw'>end</span>

  <span class='comment'># @return [SchemaArtifacts::RuntimeMetadata::IndexDefinition] runtime metadata for this index
</span>  <span class='kw'>def</span> <span class='id identifier rubyid_runtime_metadata'>runtime_metadata</span>
    <span class='const'>SchemaArtifacts</span><span class='op'>::</span><span class='const'>RuntimeMetadata</span><span class='op'>::</span><span class='const'>IndexDefinition</span><span class='period'>.</span><span class='id identifier rubyid_new'>new</span><span class='lparen'>(</span>
      <span class='label'>route_with:</span> <span class='id identifier rubyid_routing_field_path'>routing_field_path</span><span class='period'>.</span><span class='id identifier rubyid_path_in_index'>path_in_index</span><span class='comma'>,</span>
      <span class='label'>rollover:</span> <span class='id identifier rubyid_rollover_config'>rollover_config</span><span class='op'>&amp;.</span><span class='id identifier rubyid_runtime_metadata'>runtime_metadata</span><span class='comma'>,</span>
      <span class='label'>current_sources:</span> <span class='id identifier rubyid_indexed_type'>indexed_type</span><span class='period'>.</span><span class='id identifier rubyid_current_sources'>current_sources</span><span class='comma'>,</span>
      <span class='label'>fields_by_path:</span> <span class='id identifier rubyid_indexed_type'>indexed_type</span><span class='period'>.</span><span class='id identifier rubyid_index_field_runtime_metadata_tuples'>index_field_runtime_metadata_tuples</span><span class='period'>.</span><span class='id identifier rubyid_to_h'>to_h</span><span class='comma'>,</span>
      <span class='label'>default_sort_fields:</span> <span class='id identifier rubyid_default_sort_pairs'>default_sort_pairs</span><span class='period'>.</span><span class='id identifier rubyid_each_slice'>each_slice</span><span class='lparen'>(</span><span class='int'>2</span><span class='rparen'>)</span><span class='period'>.</span><span class='id identifier rubyid_map'>map</span> <span class='kw'>do</span> <span class='op'>|</span><span class='lparen'>(</span><span class='id identifier rubyid_graphql_field_path_name'>graphql_field_path_name</span><span class='comma'>,</span> <span class='id identifier rubyid_direction'>direction</span><span class='rparen'>)</span><span class='op'>|</span>
        <span class='const'>SchemaArtifacts</span><span class='op'>::</span><span class='const'>RuntimeMetadata</span><span class='op'>::</span><span class='const'>SortField</span><span class='period'>.</span><span class='id identifier rubyid_new'>new</span><span class='lparen'>(</span>
          <span class='label'>field_path:</span> <span class='id identifier rubyid_public_field_path'>public_field_path</span><span class='lparen'>(</span><span class='id identifier rubyid_graphql_field_path_name'>graphql_field_path_name</span><span class='comma'>,</span> <span class='label'>explanation:</span> <span class='tstring'><span class='tstring_beg'>&quot;</span><span class='tstring_content'>it is referenced as an index `default_sort` field</span><span class='tstring_end'>&quot;</span></span><span class='rparen'>)</span><span class='period'>.</span><span class='id identifier rubyid_path_in_index'>path_in_index</span><span class='comma'>,</span>
          <span class='label'>direction:</span> <span class='id identifier rubyid_direction'>direction</span>
        <span class='rparen'>)</span>
      <span class='kw'>end</span>
    <span class='rparen'>)</span>
  <span class='kw'>end</span>

  <span class='id identifier rubyid_private'>private</span>

  <span class='comment'># A regex that requires at least one non-whitespace character.
</span>  <span class='comment'># Note: this does not use the `/S` character class because it&#39;s recommended to use a small subset
</span>  <span class='comment'># of Regex syntax:
</span>  <span class='comment'>#
</span>  <span class='comment'># &gt; The regular expression syntax used is from JavaScript (ECMA 262, specifically). However, that
</span>  <span class='comment'># &gt; complete syntax is not widely supported, therefore it is recommended that you stick to the subset
</span>  <span class='comment'># &gt; of that syntax described below.
</span>  <span class='comment'>#
</span>  <span class='comment'># (From https://json-schema.org/understanding-json-schema/reference/regular_expressions.html)
</span>  <span class='const'>HAS_NON_WHITE_SPACE_REGEX</span> <span class='op'>=</span> <span class='tstring'><span class='tstring_beg'>&quot;</span><span class='tstring_content'>[^ \t\n]+</span><span class='tstring_end'>&quot;</span></span>

  <span class='const'>DEFAULT_SETTINGS</span> <span class='op'>=</span> <span class='lbrace'>{</span>
    <span class='tstring'><span class='tstring_beg'>&quot;</span><span class='tstring_content'>index.mapping.ignore_malformed</span><span class='tstring_end'>&quot;</span></span> <span class='op'>=&gt;</span> <span class='kw'>false</span><span class='comma'>,</span>
    <span class='tstring'><span class='tstring_beg'>&quot;</span><span class='tstring_content'>index.mapping.coerce</span><span class='tstring_end'>&quot;</span></span> <span class='op'>=&gt;</span> <span class='kw'>false</span><span class='comma'>,</span>
    <span class='tstring'><span class='tstring_beg'>&quot;</span><span class='tstring_content'>index.number_of_replicas</span><span class='tstring_end'>&quot;</span></span> <span class='op'>=&gt;</span> <span class='int'>1</span><span class='comma'>,</span>
    <span class='tstring'><span class='tstring_beg'>&quot;</span><span class='tstring_content'>index.number_of_shards</span><span class='tstring_end'>&quot;</span></span> <span class='op'>=&gt;</span> <span class='int'>1</span>
  <span class='rbrace'>}</span>

  <span class='kw'>def</span> <span class='id identifier rubyid_mappings'>mappings</span>
    <span class='id identifier rubyid_field_mappings'>field_mappings</span> <span class='op'>=</span> <span class='id identifier rubyid_indexed_type'>indexed_type</span>
      <span class='period'>.</span><span class='id identifier rubyid_to_indexing_field_type'>to_indexing_field_type</span>
      <span class='period'>.</span><span class='id identifier rubyid_to_mapping'>to_mapping</span>
      <span class='period'>.</span><span class='id identifier rubyid_except'>except</span><span class='lparen'>(</span><span class='tstring'><span class='tstring_beg'>&quot;</span><span class='tstring_content'>type</span><span class='tstring_end'>&quot;</span></span><span class='rparen'>)</span> <span class='comment'># `type` is invalid at the mapping root because it always has to be an object.
</span>      <span class='period'>.</span><span class='id identifier rubyid_then'>then</span> <span class='lbrace'>{</span> <span class='op'>|</span><span class='id identifier rubyid_mapping'>mapping</span><span class='op'>|</span> <span class='const'>ListCountsMapping</span><span class='period'>.</span><span class='id identifier rubyid_merged_into'>merged_into</span><span class='lparen'>(</span><span class='id identifier rubyid_mapping'>mapping</span><span class='comma'>,</span> <span class='label'>for_type:</span> <span class='id identifier rubyid_indexed_type'>indexed_type</span><span class='rparen'>)</span> <span class='rbrace'>}</span>
      <span class='period'>.</span><span class='id identifier rubyid_then'>then</span> <span class='kw'>do</span> <span class='op'>|</span><span class='id identifier rubyid_fm'>fm</span><span class='op'>|</span>
        <span class='const'><span class='object_link'><a href="../../Support.html" title="ElasticGraph::Support (module)">Support</a></span></span><span class='op'>::</span><span class='const'>HashUtil</span><span class='period'>.</span><span class='id identifier rubyid_deep_merge'>deep_merge</span><span class='lparen'>(</span><span class='id identifier rubyid_fm'>fm</span><span class='comma'>,</span> <span class='lbrace'>{</span><span class='tstring'><span class='tstring_beg'>&quot;</span><span class='tstring_content'>properties</span><span class='tstring_end'>&quot;</span></span> <span class='op'>=&gt;</span> <span class='lbrace'>{</span>
          <span class='tstring'><span class='tstring_beg'>&quot;</span><span class='tstring_content'>__sources</span><span class='tstring_end'>&quot;</span></span> <span class='op'>=&gt;</span> <span class='lbrace'>{</span><span class='tstring'><span class='tstring_beg'>&quot;</span><span class='tstring_content'>type</span><span class='tstring_end'>&quot;</span></span> <span class='op'>=&gt;</span> <span class='tstring'><span class='tstring_beg'>&quot;</span><span class='tstring_content'>keyword</span><span class='tstring_end'>&quot;</span></span><span class='rbrace'>}</span><span class='comma'>,</span>
          <span class='tstring'><span class='tstring_beg'>&quot;</span><span class='tstring_content'>__versions</span><span class='tstring_end'>&quot;</span></span> <span class='op'>=&gt;</span> <span class='lbrace'>{</span>
            <span class='tstring'><span class='tstring_beg'>&quot;</span><span class='tstring_content'>type</span><span class='tstring_end'>&quot;</span></span> <span class='op'>=&gt;</span> <span class='tstring'><span class='tstring_beg'>&quot;</span><span class='tstring_content'>object</span><span class='tstring_end'>&quot;</span></span><span class='comma'>,</span>
            <span class='comment'># __versions is map keyed by relationship name, with values that are maps keyed by id. Since it&#39;s not
</span>            <span class='comment'># a static object with known fields, we need to use dynamic here. Passing `false` allows some level
</span>            <span class='comment'># of dynamicness. As per https://www.elastic.co/guide/en/elasticsearch/reference/8.7/dynamic.html#dynamic-parameters:
</span>            <span class='comment'>#
</span>            <span class='comment'># &gt; New fields are ignored. These fields will not be indexed or searchable, but will still appear in the _source
</span>            <span class='comment'># &gt; field of returned hits. These fields will not be added to the mapping, and new fields must be added explicitly.
</span>            <span class='comment'>#
</span>            <span class='comment'># We need `__versions` to be in `_source` (so that our update scripts can operate on it), but
</span>            <span class='comment'># have no need for it to be searchable (as it&#39;s just an internal data structure used for indexing).
</span>            <span class='comment'>#
</span>            <span class='comment'># Note: we intentionally set false as a string here, because that&#39;s how the datastore echoes it back
</span>            <span class='comment'># to us when you query the mapping (even if you set it as a boolean). Our checks for index mapping
</span>            <span class='comment'># consistency fail validation if we set it as a boolean since the datastore doesn&#39;t echo it back as
</span>            <span class='comment'># a boolean.
</span>            <span class='tstring'><span class='tstring_beg'>&quot;</span><span class='tstring_content'>dynamic</span><span class='tstring_end'>&quot;</span></span> <span class='op'>=&gt;</span> <span class='tstring'><span class='tstring_beg'>&quot;</span><span class='tstring_content'>false</span><span class='tstring_end'>&quot;</span></span>
          <span class='rbrace'>}</span>
        <span class='rbrace'>}</span><span class='rbrace'>}</span><span class='rparen'>)</span>
      <span class='kw'>end</span>

    <span class='lbrace'>{</span><span class='tstring'><span class='tstring_beg'>&quot;</span><span class='tstring_content'>dynamic</span><span class='tstring_end'>&quot;</span></span> <span class='op'>=&gt;</span> <span class='tstring'><span class='tstring_beg'>&quot;</span><span class='tstring_content'>strict</span><span class='tstring_end'>&quot;</span></span><span class='rbrace'>}</span><span class='period'>.</span><span class='id identifier rubyid_merge'>merge</span><span class='lparen'>(</span><span class='id identifier rubyid_field_mappings'>field_mappings</span><span class='rparen'>)</span><span class='period'>.</span><span class='id identifier rubyid_tap'>tap</span> <span class='kw'>do</span> <span class='op'>|</span><span class='id identifier rubyid_hash'>hash</span><span class='op'>|</span>
      <span class='comment'># If we are using custom shard routing, we want to require a `routing` value to be provided
</span>      <span class='comment'># in every single index, get, delete or update request; otherwise the request might be
</span>      <span class='comment'># made against the wrong shard.
</span>      <span class='id identifier rubyid_hash'>hash</span><span class='lbracket'>[</span><span class='tstring'><span class='tstring_beg'>&quot;</span><span class='tstring_content'>_routing</span><span class='tstring_end'>&quot;</span></span><span class='rbracket'>]</span> <span class='op'>=</span> <span class='lbrace'>{</span><span class='tstring'><span class='tstring_beg'>&quot;</span><span class='tstring_content'>required</span><span class='tstring_end'>&quot;</span></span> <span class='op'>=&gt;</span> <span class='kw'>true</span><span class='rbrace'>}</span> <span class='kw'>if</span> <span class='id identifier rubyid_uses_custom_routing?'>uses_custom_routing?</span>
      <span class='id identifier rubyid_hash'>hash</span><span class='lbracket'>[</span><span class='tstring'><span class='tstring_beg'>&quot;</span><span class='tstring_content'>_size</span><span class='tstring_end'>&quot;</span></span><span class='rbracket'>]</span> <span class='op'>=</span> <span class='lbrace'>{</span><span class='tstring'><span class='tstring_beg'>&quot;</span><span class='tstring_content'>enabled</span><span class='tstring_end'>&quot;</span></span> <span class='op'>=&gt;</span> <span class='kw'>true</span><span class='rbrace'>}</span> <span class='kw'>if</span> <span class='id identifier rubyid_schema_def_state'>schema_def_state</span><span class='period'>.</span><span class='id identifier rubyid_index_document_sizes?'>index_document_sizes?</span>
    <span class='kw'>end</span>
  <span class='kw'>end</span>

  <span class='kw'>def</span> <span class='id identifier rubyid_public_field_path'>public_field_path</span><span class='lparen'>(</span><span class='id identifier rubyid_public_path_string'>public_path_string</span><span class='comma'>,</span> <span class='label'>explanation:</span><span class='rparen'>)</span>
    <span class='id identifier rubyid_parent_is_not_list'>parent_is_not_list</span> <span class='op'>=</span> <span class='tlambda'>-&gt;</span><span class='lparen'>(</span><span class='id identifier rubyid_parent_field'>parent_field</span><span class='rparen'>)</span> <span class='tlambeg'>{</span> <span class='op'>!</span><span class='id identifier rubyid_parent_field'>parent_field</span><span class='period'>.</span><span class='id identifier rubyid_type'>type</span><span class='period'>.</span><span class='id identifier rubyid_list?'>list?</span> <span class='rbrace'>}</span>
    <span class='id identifier rubyid_resolver'>resolver</span> <span class='op'>=</span> <span class='const'><span class='object_link'><a href="../SchemaElements.html" title="ElasticGraph::SchemaDefinition::SchemaElements (module)">SchemaElements</a></span></span><span class='op'>::</span><span class='const'>FieldPath</span><span class='op'>::</span><span class='const'>Resolver</span><span class='period'>.</span><span class='id identifier rubyid_new'>new</span>
    <span class='id identifier rubyid_resolved_path'>resolved_path</span> <span class='op'>=</span> <span class='id identifier rubyid_resolver'>resolver</span><span class='period'>.</span><span class='id identifier rubyid_resolve_public_path'>resolve_public_path</span><span class='lparen'>(</span><span class='id identifier rubyid_indexed_type'>indexed_type</span><span class='comma'>,</span> <span class='id identifier rubyid_public_path_string'>public_path_string</span><span class='comma'>,</span> <span class='op'>&amp;</span><span class='id identifier rubyid_parent_is_not_list'>parent_is_not_list</span><span class='rparen'>)</span>
    <span class='kw'>return</span> <span class='id identifier rubyid_resolved_path'>resolved_path</span> <span class='kw'>if</span> <span class='id identifier rubyid_resolved_path'>resolved_path</span>

    <span class='id identifier rubyid_path_parts'>path_parts</span> <span class='op'>=</span> <span class='id identifier rubyid_public_path_string'>public_path_string</span><span class='period'>.</span><span class='id identifier rubyid_split'>split</span><span class='lparen'>(</span><span class='tstring'><span class='tstring_beg'>&quot;</span><span class='tstring_content'>.</span><span class='tstring_end'>&quot;</span></span><span class='rparen'>)</span>
    <span class='id identifier rubyid_error_msg'>error_msg</span> <span class='op'>=</span> <span class='tstring'><span class='tstring_beg'>&quot;</span><span class='tstring_content'>Field `</span><span class='embexpr_beg'>#{</span><span class='id identifier rubyid_indexed_type'>indexed_type</span><span class='period'>.</span><span class='id identifier rubyid_name'>name</span><span class='embexpr_end'>}</span><span class='tstring_content'>.</span><span class='embexpr_beg'>#{</span><span class='id identifier rubyid_public_path_string'>public_path_string</span><span class='embexpr_end'>}</span><span class='tstring_content'>` cannot be resolved, but </span><span class='embexpr_beg'>#{</span><span class='id identifier rubyid_explanation'>explanation</span><span class='embexpr_end'>}</span><span class='tstring_content'>.</span><span class='tstring_end'>&quot;</span></span>

    <span class='comment'># If it is a nested field path, the problem could be that a type has been referenced which does not exist, so mention that.
</span>    <span class='kw'>if</span> <span class='id identifier rubyid_path_parts'>path_parts</span><span class='period'>.</span><span class='id identifier rubyid_size'>size</span> <span class='op'>&gt;</span> <span class='int'>1</span>
      <span class='id identifier rubyid_error_msg'>error_msg</span> <span class='op'>+=</span> <span class='tstring'><span class='tstring_beg'>&quot;</span><span class='tstring_content'> Verify that all fields and types referenced by `</span><span class='embexpr_beg'>#{</span><span class='id identifier rubyid_public_path_string'>public_path_string</span><span class='embexpr_end'>}</span><span class='tstring_content'>` are defined.</span><span class='tstring_end'>&quot;</span></span>
    <span class='kw'>end</span>

    <span class='comment'># If the first part of the path doesn&#39;t resolve, the problem could be that the field is defined after the `index` call
</span>    <span class='comment'># but it needs to be defined before it, so mention that.
</span>    <span class='kw'>if</span> <span class='id identifier rubyid_resolver'>resolver</span><span class='period'>.</span><span class='id identifier rubyid_resolve_public_path'>resolve_public_path</span><span class='lparen'>(</span><span class='id identifier rubyid_indexed_type'>indexed_type</span><span class='comma'>,</span> <span class='id identifier rubyid_path_parts'>path_parts</span><span class='period'>.</span><span class='id identifier rubyid_first'>first</span><span class='comma'>,</span> <span class='op'>&amp;</span><span class='id identifier rubyid_parent_is_not_list'>parent_is_not_list</span><span class='rparen'>)</span><span class='period'>.</span><span class='id identifier rubyid_nil?'>nil?</span>
      <span class='id identifier rubyid_error_msg'>error_msg</span> <span class='op'>+=</span> <span class='tstring'><span class='tstring_beg'>&quot;</span><span class='tstring_content'> Note: the `</span><span class='embexpr_beg'>#{</span><span class='id identifier rubyid_indexed_type'>indexed_type</span><span class='period'>.</span><span class='id identifier rubyid_name'>name</span><span class='embexpr_end'>}</span><span class='tstring_content'>.</span><span class='embexpr_beg'>#{</span><span class='id identifier rubyid_path_parts'>path_parts</span><span class='period'>.</span><span class='id identifier rubyid_first'>first</span><span class='embexpr_end'>}</span><span class='tstring_content'>` definition must come before the `index` call.</span><span class='tstring_end'>&quot;</span></span>
    <span class='kw'>end</span>

    <span class='id identifier rubyid_raise'>raise</span> <span class='const'>Errors</span><span class='op'>::</span><span class='const'>SchemaError</span><span class='comma'>,</span> <span class='id identifier rubyid_error_msg'>error_msg</span>
  <span class='kw'>end</span>

  <span class='kw'>def</span> <span class='id identifier rubyid_date_and_datetime_types'>date_and_datetime_types</span>
    <span class='ivar'>@date_and_datetime_types</span> <span class='op'>||=</span> <span class='qwords_beg'>%w[</span><span class='tstring_content'>Date</span><span class='words_sep'> </span><span class='tstring_content'>DateTime</span><span class='tstring_end'>]</span></span><span class='period'>.</span><span class='id identifier rubyid_map'>map</span> <span class='kw'>do</span> <span class='op'>|</span><span class='id identifier rubyid_type'>type</span><span class='op'>|</span>
      <span class='id identifier rubyid_schema_def_state'>schema_def_state</span><span class='period'>.</span><span class='id identifier rubyid_type_namer'>type_namer</span><span class='period'>.</span><span class='id identifier rubyid_name_for'>name_for</span><span class='lparen'>(</span><span class='id identifier rubyid_type'>type</span><span class='rparen'>)</span>
    <span class='kw'>end</span>
  <span class='kw'>end</span>
<span class='kw'>end</span></pre>
    </td>
  </tr>
</table>
</div>
    
      
      <span id=""></span>
      <div class="method_details ">
  <h3 class="signature " id="name-instance_method">
  
    #<strong>name</strong>  &#x21d2; <tt>String</tt>  <span class="extras">(readonly)</span>
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    <p>Returns name of the index.</p>


  </div>
</div>
<div class="tags">
  
<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt>String</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>name of the index</p>
</div>
      
    </li>
  
</ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
55
56
57
58
59
60
61
62
63
64
65
66
67
68
69
70
71
72
73
74
75
76
77
78
79
80
81
82
83
84
85
86
87
88
89
90
91
92
93
94
95
96
97
98
99
100
101
102
103
104
105
106
107
108
109
110
111
112
113
114
115
116
117
118
119
120
121
122
123
124
125
126
127
128
129
130
131
132
133
134
135
136
137
138
139
140
141
142
143
144
145
146
147
148
149
150
151
152
153
154
155
156
157
158
159
160
161
162
163
164
165
166
167
168
169
170
171
172
173
174
175
176
177
178
179
180
181
182
183
184
185
186
187
188
189
190
191
192
193
194
195
196
197
198
199
200
201
202
203
204
205
206
207
208
209
210
211
212
213
214
215
216
217
218
219
220
221
222
223
224
225
226
227
228
229
230
231
232
233
234
235
236
237
238
239
240
241
242
243
244
245
246
247
248
249
250
251
252
253
254
255
256
257
258
259
260
261
262
263
264
265
266
267
268
269
270
271
272
273
274
275
276
277
278
279
280
281
282
283
284
285
286
287
288
289
290
291
292
293
294
295
296
297
298
299
300
301
302
303
304
305
306
307
308
309
310
311
312
313
314
315</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'elasticgraph-schema_definition/lib/elastic_graph/schema_definition/indexing/index.rb', line 39</span>

<span class='kw'>class</span> <span class='const'><span class='object_link'><a href="" title="ElasticGraph::SchemaDefinition::Indexing::Index (class)">Index</a></span></span> <span class='op'>&lt;</span> <span class='const'>Struct</span><span class='period'>.</span><span class='id identifier rubyid_new'>new</span><span class='lparen'>(</span><span class='symbol'>:name</span><span class='comma'>,</span> <span class='symbol'>:default_sort_pairs</span><span class='comma'>,</span> <span class='symbol'>:settings</span><span class='comma'>,</span> <span class='symbol'>:schema_def_state</span><span class='comma'>,</span> <span class='symbol'>:indexed_type</span><span class='comma'>,</span> <span class='symbol'>:routing_field_path</span><span class='comma'>,</span> <span class='symbol'>:rollover_config</span><span class='rparen'>)</span>
  <span class='id identifier rubyid_include'>include</span> <span class='const'><span class='object_link'><a href="../Mixins.html" title="ElasticGraph::SchemaDefinition::Mixins (module)">Mixins</a></span></span><span class='op'>::</span><span class='const'>HasReadableToSAndInspect</span><span class='period'>.</span><span class='id identifier rubyid_new'>new</span> <span class='lbrace'>{</span> <span class='op'>|</span><span class='id identifier rubyid_i'>i</span><span class='op'>|</span> <span class='id identifier rubyid_i'>i</span><span class='period'>.</span><span class='id identifier rubyid_name'>name</span> <span class='rbrace'>}</span>

  <span class='comment'># @param name [String] name of the index
</span>  <span class='comment'># @param settings [Hash&lt;(String, Object)&gt;] datastore settings for the index
</span>  <span class='comment'># @param schema_def_state [State] schema definition state
</span>  <span class='comment'># @param indexed_type [SchemaElements::ObjectType, SchemaElements::InterfaceType, SchemaElements::UnionType] type backed by this index
</span>  <span class='comment'># @yield [Index] the index, for further customization
</span>  <span class='comment'># @api private
</span>  <span class='kw'>def</span> <span class='id identifier rubyid_initialize'>initialize</span><span class='lparen'>(</span><span class='id identifier rubyid_name'>name</span><span class='comma'>,</span> <span class='id identifier rubyid_settings'>settings</span><span class='comma'>,</span> <span class='id identifier rubyid_schema_def_state'>schema_def_state</span><span class='comma'>,</span> <span class='id identifier rubyid_indexed_type'>indexed_type</span><span class='rparen'>)</span>
    <span class='kw'>if</span> <span class='id identifier rubyid_name'>name</span><span class='period'>.</span><span class='id identifier rubyid_include?'>include?</span><span class='lparen'>(</span><span class='const'>ROLLOVER_INDEX_INFIX_MARKER</span><span class='rparen'>)</span>
      <span class='id identifier rubyid_raise'>raise</span> <span class='const'>Errors</span><span class='op'>::</span><span class='const'>SchemaError</span><span class='comma'>,</span> <span class='tstring'><span class='tstring_beg'>&quot;</span><span class='tstring_content'>`</span><span class='embexpr_beg'>#{</span><span class='id identifier rubyid_name'>name</span><span class='embexpr_end'>}</span><span class='tstring_content'>` is an invalid index definition name since it contains </span><span class='tstring_end'>&quot;</span></span> \
        <span class='tstring'><span class='tstring_beg'>&quot;</span><span class='tstring_content'>`</span><span class='embexpr_beg'>#{</span><span class='const'>ROLLOVER_INDEX_INFIX_MARKER</span><span class='embexpr_end'>}</span><span class='tstring_content'>` which ElasticGraph treats as special.</span><span class='tstring_end'>&quot;</span></span>
    <span class='kw'>end</span>

    <span class='id identifier rubyid_settings'>settings</span> <span class='op'>=</span> <span class='const'>DEFAULT_SETTINGS</span><span class='period'>.</span><span class='id identifier rubyid_merge'>merge</span><span class='lparen'>(</span><span class='const'><span class='object_link'><a href="../../Support.html" title="ElasticGraph::Support (module)">Support</a></span></span><span class='op'>::</span><span class='const'>HashUtil</span><span class='period'>.</span><span class='id identifier rubyid_flatten_and_stringify_keys'>flatten_and_stringify_keys</span><span class='lparen'>(</span><span class='id identifier rubyid_settings'>settings</span><span class='comma'>,</span> <span class='label'>prefix:</span> <span class='tstring'><span class='tstring_beg'>&quot;</span><span class='tstring_content'>index</span><span class='tstring_end'>&quot;</span></span><span class='rparen'>)</span><span class='rparen'>)</span>

    <span class='kw'>super</span><span class='lparen'>(</span><span class='id identifier rubyid_name'>name</span><span class='comma'>,</span> <span class='lbracket'>[</span><span class='rbracket'>]</span><span class='comma'>,</span> <span class='id identifier rubyid_settings'>settings</span><span class='comma'>,</span> <span class='id identifier rubyid_schema_def_state'>schema_def_state</span><span class='comma'>,</span> <span class='id identifier rubyid_indexed_type'>indexed_type</span><span class='comma'>,</span> <span class='lbracket'>[</span><span class='rbracket'>]</span><span class='comma'>,</span> <span class='kw'>nil</span><span class='rparen'>)</span>

    <span class='comment'># `id` is the field Elasticsearch/OpenSearch use for routing by default:
</span>    <span class='comment'># https://www.elastic.co/guide/en/elasticsearch/reference/current/mapping-routing-field.html
</span>    <span class='comment'># By using it here, it will cause queries to pass a `routing` parameter when
</span>    <span class='comment'># searching with id filtering on an index that does not use custom shard routing, giving
</span>    <span class='comment'># us a nice efficiency boost.
</span>    <span class='kw'>self</span><span class='period'>.</span><span class='id identifier rubyid_routing_field_path'>routing_field_path</span> <span class='op'>=</span> <span class='id identifier rubyid_public_field_path'>public_field_path</span><span class='lparen'>(</span><span class='tstring'><span class='tstring_beg'>&quot;</span><span class='tstring_content'>id</span><span class='tstring_end'>&quot;</span></span><span class='comma'>,</span> <span class='label'>explanation:</span> <span class='tstring'><span class='tstring_beg'>&quot;</span><span class='tstring_content'>indexed types must have an `id` field</span><span class='tstring_end'>&quot;</span></span><span class='rparen'>)</span>

    <span class='kw'>yield</span> <span class='kw'>self</span> <span class='kw'>if</span> <span class='id identifier rubyid_block_given?'>block_given?</span>
  <span class='kw'>end</span>

  <span class='comment'># Specifies how documents in this index should sort by default, when no `orderBy` argument is provided to the GraphQL query.
</span>  <span class='comment'>#
</span>  <span class='comment'># @note the field name strings can be a dot-separated nested fields, but all referenced
</span>  <span class='comment'>#   fields must exist when this is called.
</span>  <span class='comment'>#
</span>  <span class='comment'># @param field_name_direction_pairs [Array&lt;(String, Symbol)&gt;] pairs of field names and `:asc` or `:desc`
</span>  <span class='comment'># @return [void]
</span>  <span class='comment'>#
</span>  <span class='comment'># @example Sort on `name` (ascending) with `createdAt` (descending) as a tie-breaker
</span>  <span class='comment'>#   ElasticGraph.define_schema do |schema|
</span>  <span class='comment'>#     schema.object_type &quot;Campaign&quot; do |t|
</span>  <span class='comment'>#       t.field &quot;id&quot;, &quot;ID!&quot;
</span>  <span class='comment'>#       t.field &quot;name&quot;, &quot;String&quot;
</span>  <span class='comment'>#       t.field &quot;createdAt&quot;, &quot;DateTime&quot;
</span>  <span class='comment'>#
</span>  <span class='comment'>#       t.index &quot;campaigns&quot;do |i|
</span>  <span class='comment'>#         i.default_sort &quot;name&quot;, :asc, &quot;createdAt&quot;, :desc
</span>  <span class='comment'>#       end
</span>  <span class='comment'>#     end
</span>  <span class='comment'>#   end
</span>  <span class='kw'>def</span> <span class='id identifier rubyid_default_sort'>default_sort</span><span class='lparen'>(</span><span class='op'>*</span><span class='id identifier rubyid_field_name_direction_pairs'>field_name_direction_pairs</span><span class='rparen'>)</span>
    <span class='kw'>self</span><span class='period'>.</span><span class='id identifier rubyid_default_sort_pairs'>default_sort_pairs</span> <span class='op'>=</span> <span class='id identifier rubyid_field_name_direction_pairs'>field_name_direction_pairs</span>
  <span class='kw'>end</span>

  <span class='comment'># Causes this index to &quot;rollover&quot; at the provided `frequency` based on the value of the provided `timestamp_field_path_name`.
</span>  <span class='comment'># This is particularly useful for time-series data. Partitioning the data into `hourly`, `daily`, `monthly` or `yearly` buckets
</span>  <span class='comment'># allows for different index configurations, and can be necessary when a dataset is too large to fit in one dataset given
</span>  <span class='comment'># Elasticsearch/OpenSearch limitations on the number of shards in one index. In addition, ElasticGraph optimizes queries which
</span>  <span class='comment'># filter on the timestamp field to target the subset of the indices in which matching documents could reside.
</span>  <span class='comment'>#
</span>  <span class='comment'># @note the timestamp field specified here **must be immutable**. To understand why, consider a `:yearly` rollover
</span>  <span class='comment'>#   index used for data based on `createdAt`; if ElasticGraph ingests record `123` with a createdAt of `2023-12-31T23:59:59Z`, it
</span>  <span class='comment'>#   will be indexed in the `2023` index. Later if it receives an update event for record `123` with a `createdAt` of
</span>  <span class='comment'>#   `2024-01-01T00:00:00Z` (a mere one second later!), ElasticGraph will store the new version of the payment in the `2024` index,
</span>  <span class='comment'>#   and leave the old copy of the payment in the `2023` index unchanged. It’ll have duplicates for that document.
</span>  <span class='comment'># @note changing the `rollover` configuration on an existing index that already has data will result in duplicate documents
</span>  <span class='comment'>#
</span>  <span class='comment'># @param frequency [:yearly, :monthly, :daily, :hourly] how often to rollover the index
</span>  <span class='comment'># @param timestamp_field_path_name [String] dot-separated path to the timestamp field used for rollover. Note: all referenced
</span>  <span class='comment'>#   fields must exist when this is called.
</span>  <span class='comment'># @return [void]
</span>  <span class='comment'>#
</span>  <span class='comment'># @example Define a `campaigns` index to rollover yearly based on `createdAt`
</span>  <span class='comment'>#   ElasticGraph.define_schema do |schema|
</span>  <span class='comment'>#     schema.object_type &quot;Campaign&quot; do |t|
</span>  <span class='comment'>#       t.field &quot;id&quot;, &quot;ID!&quot;
</span>  <span class='comment'>#       t.field &quot;name&quot;, &quot;String&quot;
</span>  <span class='comment'>#       t.field &quot;createdAt&quot;, &quot;DateTime&quot;
</span>  <span class='comment'>#
</span>  <span class='comment'>#       t.index &quot;campaigns&quot;do |i|
</span>  <span class='comment'>#         i.rollover :yearly, &quot;createdAt&quot;
</span>  <span class='comment'>#       end
</span>  <span class='comment'>#     end
</span>  <span class='comment'>#   end
</span>  <span class='kw'>def</span> <span class='id identifier rubyid_rollover'>rollover</span><span class='lparen'>(</span><span class='id identifier rubyid_frequency'>frequency</span><span class='comma'>,</span> <span class='id identifier rubyid_timestamp_field_path_name'>timestamp_field_path_name</span><span class='rparen'>)</span>
    <span class='id identifier rubyid_timestamp_field_path'>timestamp_field_path</span> <span class='op'>=</span> <span class='id identifier rubyid_public_field_path'>public_field_path</span><span class='lparen'>(</span><span class='id identifier rubyid_timestamp_field_path_name'>timestamp_field_path_name</span><span class='comma'>,</span> <span class='label'>explanation:</span> <span class='tstring'><span class='tstring_beg'>&quot;</span><span class='tstring_content'>it is referenced as an index `rollover` field</span><span class='tstring_end'>&quot;</span></span><span class='rparen'>)</span>

    <span class='kw'>unless</span> <span class='id identifier rubyid_date_and_datetime_types'>date_and_datetime_types</span><span class='period'>.</span><span class='id identifier rubyid_include?'>include?</span><span class='lparen'>(</span><span class='id identifier rubyid_timestamp_field_path'>timestamp_field_path</span><span class='period'>.</span><span class='id identifier rubyid_type'>type</span><span class='period'>.</span><span class='id identifier rubyid_fully_unwrapped'>fully_unwrapped</span><span class='period'>.</span><span class='id identifier rubyid_name'>name</span><span class='rparen'>)</span>
      <span class='id identifier rubyid_date_or_datetime_description'>date_or_datetime_description</span> <span class='op'>=</span> <span class='id identifier rubyid_date_and_datetime_types'>date_and_datetime_types</span><span class='period'>.</span><span class='id identifier rubyid_map'>map</span> <span class='lbrace'>{</span> <span class='op'>|</span><span class='id identifier rubyid_t'>t</span><span class='op'>|</span> <span class='tstring'><span class='tstring_beg'>&quot;</span><span class='tstring_content'>`</span><span class='embexpr_beg'>#{</span><span class='id identifier rubyid_t'>t</span><span class='embexpr_end'>}</span><span class='tstring_content'>`</span><span class='tstring_end'>&quot;</span></span> <span class='rbrace'>}</span><span class='period'>.</span><span class='id identifier rubyid_join'>join</span><span class='lparen'>(</span><span class='tstring'><span class='tstring_beg'>&quot;</span><span class='tstring_content'> or </span><span class='tstring_end'>&quot;</span></span><span class='rparen'>)</span>
      <span class='id identifier rubyid_raise'>raise</span> <span class='const'>Errors</span><span class='op'>::</span><span class='const'>SchemaError</span><span class='comma'>,</span> <span class='tstring'><span class='tstring_beg'>&quot;</span><span class='tstring_content'>rollover field `</span><span class='embexpr_beg'>#{</span><span class='id identifier rubyid_timestamp_field_path'>timestamp_field_path</span><span class='period'>.</span><span class='id identifier rubyid_full_description'>full_description</span><span class='embexpr_end'>}</span><span class='tstring_content'>` cannot be used for rollover since it is not a </span><span class='embexpr_beg'>#{</span><span class='id identifier rubyid_date_or_datetime_description'>date_or_datetime_description</span><span class='embexpr_end'>}</span><span class='tstring_content'> field.</span><span class='tstring_end'>&quot;</span></span>
    <span class='kw'>end</span>

    <span class='kw'>if</span> <span class='id identifier rubyid_timestamp_field_path'>timestamp_field_path</span><span class='period'>.</span><span class='id identifier rubyid_type'>type</span><span class='period'>.</span><span class='id identifier rubyid_list?'>list?</span>
      <span class='id identifier rubyid_raise'>raise</span> <span class='const'>Errors</span><span class='op'>::</span><span class='const'>SchemaError</span><span class='comma'>,</span> <span class='tstring'><span class='tstring_beg'>&quot;</span><span class='tstring_content'>rollover field `</span><span class='embexpr_beg'>#{</span><span class='id identifier rubyid_timestamp_field_path'>timestamp_field_path</span><span class='period'>.</span><span class='id identifier rubyid_full_description'>full_description</span><span class='embexpr_end'>}</span><span class='tstring_content'>` cannot be used for rollover since it is a list field.</span><span class='tstring_end'>&quot;</span></span>
    <span class='kw'>end</span>

    <span class='id identifier rubyid_timestamp_field_path'>timestamp_field_path</span><span class='period'>.</span><span class='id identifier rubyid_path_parts'>path_parts</span><span class='period'>.</span><span class='id identifier rubyid_each'>each</span> <span class='lbrace'>{</span> <span class='op'>|</span><span class='id identifier rubyid_f'>f</span><span class='op'>|</span> <span class='id identifier rubyid_f'>f</span><span class='period'>.</span><span class='id identifier rubyid_json_schema'>json_schema</span> <span class='label'>nullable:</span> <span class='kw'>false</span> <span class='rbrace'>}</span>

    <span class='kw'>self</span><span class='period'>.</span><span class='id identifier rubyid_rollover_config'>rollover_config</span> <span class='op'>=</span> <span class='const'>RolloverConfig</span><span class='period'>.</span><span class='id identifier rubyid_new'>new</span><span class='lparen'>(</span>
      <span class='label'>frequency:</span> <span class='id identifier rubyid_frequency'>frequency</span><span class='comma'>,</span>
      <span class='label'>timestamp_field_path:</span> <span class='id identifier rubyid_timestamp_field_path'>timestamp_field_path</span>
    <span class='rparen'>)</span>
  <span class='kw'>end</span>

  <span class='comment'># Configures the index to [route documents to shards](https://www.elastic.co/guide/en/elasticsearch/reference/8.15/mapping-routing-field.html)
</span>  <span class='comment'># based on the specified field. ElasticGraph optimizes queries that filter on the shard routing field so that they only run on a
</span>  <span class='comment'># subset of nodes instead of all nodes. This can make a big difference in query performance if queries usually filter on a certain
</span>  <span class='comment'># field. Using an appropriate field for shard routing is often essential for horizontal scaling, as it avoids having every query
</span>  <span class='comment'># hit every node, allowing additional nodes to increase query throughput.
</span>  <span class='comment'>#
</span>  <span class='comment'># @note it is essential that the shards are well-balanced. If the data’s distribution is lopsided, using this feature can make
</span>  <span class='comment'>#   performance worse.
</span>  <span class='comment'># @note the routing field specified here **must be immutable**. If ElasticGraph receives an updated version of a document with a
</span>  <span class='comment'>#   different routing value, it’ll write the new version of the document to a different shard and leave the copy on the old shard
</span>  <span class='comment'>#   unchanged, leading to duplicates.
</span>  <span class='comment'># @note changing the shard routing configuration on an existing index that already has data will result in duplicate documents
</span>  <span class='comment'>#
</span>  <span class='comment'># @param routing_field_path_name [String] dot-separated path to the field used for shard routing. Note: all referenced
</span>  <span class='comment'>#   fields must exist when this is called.
</span>  <span class='comment'># @return [void]
</span>  <span class='comment'>#
</span>  <span class='comment'># @example Define a `campaigns` index to shard on `organizationId`
</span>  <span class='comment'>#   ElasticGraph.define_schema do |schema|
</span>  <span class='comment'>#     schema.object_type &quot;Campaign&quot; do |t|
</span>  <span class='comment'>#       t.field &quot;id&quot;, &quot;ID!&quot;
</span>  <span class='comment'>#       t.field &quot;name&quot;, &quot;String&quot;
</span>  <span class='comment'>#       t.field &quot;organizationId&quot;, &quot;ID&quot;
</span>  <span class='comment'>#
</span>  <span class='comment'>#       t.index &quot;campaigns&quot;do |i|
</span>  <span class='comment'>#         i.route_with &quot;organizationId&quot;
</span>  <span class='comment'>#       end
</span>  <span class='comment'>#     end
</span>  <span class='comment'>#   end
</span>  <span class='kw'>def</span> <span class='id identifier rubyid_route_with'>route_with</span><span class='lparen'>(</span><span class='id identifier rubyid_routing_field_path_name'>routing_field_path_name</span><span class='rparen'>)</span>
    <span class='id identifier rubyid_routing_field_path'>routing_field_path</span> <span class='op'>=</span> <span class='id identifier rubyid_public_field_path'>public_field_path</span><span class='lparen'>(</span><span class='id identifier rubyid_routing_field_path_name'>routing_field_path_name</span><span class='comma'>,</span> <span class='label'>explanation:</span> <span class='tstring'><span class='tstring_beg'>&quot;</span><span class='tstring_content'>it is referenced as an index `route_with` field</span><span class='tstring_end'>&quot;</span></span><span class='rparen'>)</span>

    <span class='kw'>unless</span> <span class='id identifier rubyid_routing_field_path'>routing_field_path</span><span class='period'>.</span><span class='id identifier rubyid_type'>type</span><span class='period'>.</span><span class='id identifier rubyid_leaf?'>leaf?</span>
      <span class='id identifier rubyid_raise'>raise</span> <span class='const'>Errors</span><span class='op'>::</span><span class='const'>SchemaError</span><span class='comma'>,</span> <span class='tstring'><span class='tstring_beg'>&quot;</span><span class='tstring_content'>shard routing field `</span><span class='embexpr_beg'>#{</span><span class='id identifier rubyid_routing_field_path'>routing_field_path</span><span class='period'>.</span><span class='id identifier rubyid_full_description'>full_description</span><span class='embexpr_end'>}</span><span class='tstring_content'>` cannot be used for routing since it is not a leaf field.</span><span class='tstring_end'>&quot;</span></span>
    <span class='kw'>end</span>

    <span class='kw'>self</span><span class='period'>.</span><span class='id identifier rubyid_routing_field_path'>routing_field_path</span> <span class='op'>=</span> <span class='id identifier rubyid_routing_field_path'>routing_field_path</span>

    <span class='id identifier rubyid_routing_field_path'>routing_field_path</span><span class='period'>.</span><span class='id identifier rubyid_path_parts'>path_parts</span><span class='lbracket'>[</span><span class='int'>0</span><span class='op'>..</span><span class='op'>-</span><span class='int'>2</span><span class='rbracket'>]</span><span class='period'>.</span><span class='id identifier rubyid_each'>each</span> <span class='lbrace'>{</span> <span class='op'>|</span><span class='id identifier rubyid_f'>f</span><span class='op'>|</span> <span class='id identifier rubyid_f'>f</span><span class='period'>.</span><span class='id identifier rubyid_json_schema'>json_schema</span> <span class='label'>nullable:</span> <span class='kw'>false</span> <span class='rbrace'>}</span>
    <span class='id identifier rubyid_routing_field_path'>routing_field_path</span><span class='period'>.</span><span class='id identifier rubyid_last_part'>last_part</span><span class='period'>.</span><span class='id identifier rubyid_json_schema'>json_schema</span> <span class='label'>nullable:</span> <span class='kw'>false</span><span class='comma'>,</span> <span class='label'>pattern:</span> <span class='const'>HAS_NON_WHITE_SPACE_REGEX</span>
    <span class='id identifier rubyid_indexed_type'>indexed_type</span><span class='period'>.</span><span class='id identifier rubyid_append_to_documentation'>append_to_documentation</span> <span class='tstring'><span class='tstring_beg'>&quot;</span><span class='tstring_content'>For more performant queries on this type, please filter on `</span><span class='embexpr_beg'>#{</span><span class='id identifier rubyid_routing_field_path_name'>routing_field_path_name</span><span class='embexpr_end'>}</span><span class='tstring_content'>` if possible.</span><span class='tstring_end'>&quot;</span></span>
  <span class='kw'>end</span>

  <span class='comment'># @see #route_with
</span>  <span class='comment'># @return [Boolean] whether or not this index uses custom shard routing
</span>  <span class='kw'>def</span> <span class='id identifier rubyid_uses_custom_routing?'>uses_custom_routing?</span>
    <span class='id identifier rubyid_routing_field_path'>routing_field_path</span><span class='period'>.</span><span class='id identifier rubyid_path_in_index'>path_in_index</span> <span class='op'>!=</span> <span class='tstring'><span class='tstring_beg'>&quot;</span><span class='tstring_content'>id</span><span class='tstring_end'>&quot;</span></span>
  <span class='kw'>end</span>

  <span class='comment'># @return [Hash&lt;String, Object&gt;] datastore configuration for this index for when it does not use rollover
</span>  <span class='kw'>def</span> <span class='id identifier rubyid_to_index_config'>to_index_config</span>
    <span class='lbrace'>{</span>
      <span class='tstring'><span class='tstring_beg'>&quot;</span><span class='tstring_content'>aliases</span><span class='tstring_end'>&quot;</span></span> <span class='op'>=&gt;</span> <span class='lbrace'>{</span><span class='rbrace'>}</span><span class='comma'>,</span>
      <span class='tstring'><span class='tstring_beg'>&quot;</span><span class='tstring_content'>mappings</span><span class='tstring_end'>&quot;</span></span> <span class='op'>=&gt;</span> <span class='id identifier rubyid_mappings'>mappings</span><span class='comma'>,</span>
      <span class='tstring'><span class='tstring_beg'>&quot;</span><span class='tstring_content'>settings</span><span class='tstring_end'>&quot;</span></span> <span class='op'>=&gt;</span> <span class='id identifier rubyid_settings'>settings</span>
    <span class='rbrace'>}</span><span class='period'>.</span><span class='id identifier rubyid_compact'>compact</span>
  <span class='kw'>end</span>

  <span class='comment'># @return [Hash&lt;String, Object&gt;] datastore configuration for the index template that will be defined if rollover is used
</span>  <span class='kw'>def</span> <span class='id identifier rubyid_to_index_template_config'>to_index_template_config</span>
    <span class='lbrace'>{</span>
      <span class='tstring'><span class='tstring_beg'>&quot;</span><span class='tstring_content'>index_patterns</span><span class='tstring_end'>&quot;</span></span> <span class='op'>=&gt;</span> <span class='lbracket'>[</span><span class='tstring'><span class='tstring_beg'>&quot;</span><span class='embexpr_beg'>#{</span><span class='id identifier rubyid_name'>name</span><span class='embexpr_end'>}</span><span class='embexpr_beg'>#{</span><span class='const'>ROLLOVER_INDEX_INFIX_MARKER</span><span class='embexpr_end'>}</span><span class='tstring_content'>*</span><span class='tstring_end'>&quot;</span></span><span class='rbracket'>]</span><span class='comma'>,</span>
      <span class='tstring'><span class='tstring_beg'>&quot;</span><span class='tstring_content'>template</span><span class='tstring_end'>&quot;</span></span> <span class='op'>=&gt;</span> <span class='lbrace'>{</span>
        <span class='tstring'><span class='tstring_beg'>&quot;</span><span class='tstring_content'>aliases</span><span class='tstring_end'>&quot;</span></span> <span class='op'>=&gt;</span> <span class='lbrace'>{</span><span class='rbrace'>}</span><span class='comma'>,</span>
        <span class='tstring'><span class='tstring_beg'>&quot;</span><span class='tstring_content'>mappings</span><span class='tstring_end'>&quot;</span></span> <span class='op'>=&gt;</span> <span class='id identifier rubyid_mappings'>mappings</span><span class='comma'>,</span>
        <span class='tstring'><span class='tstring_beg'>&quot;</span><span class='tstring_content'>settings</span><span class='tstring_end'>&quot;</span></span> <span class='op'>=&gt;</span> <span class='id identifier rubyid_settings'>settings</span>
      <span class='rbrace'>}</span>
    <span class='rbrace'>}</span>
  <span class='kw'>end</span>

  <span class='comment'># @return [SchemaArtifacts::RuntimeMetadata::IndexDefinition] runtime metadata for this index
</span>  <span class='kw'>def</span> <span class='id identifier rubyid_runtime_metadata'>runtime_metadata</span>
    <span class='const'>SchemaArtifacts</span><span class='op'>::</span><span class='const'>RuntimeMetadata</span><span class='op'>::</span><span class='const'>IndexDefinition</span><span class='period'>.</span><span class='id identifier rubyid_new'>new</span><span class='lparen'>(</span>
      <span class='label'>route_with:</span> <span class='id identifier rubyid_routing_field_path'>routing_field_path</span><span class='period'>.</span><span class='id identifier rubyid_path_in_index'>path_in_index</span><span class='comma'>,</span>
      <span class='label'>rollover:</span> <span class='id identifier rubyid_rollover_config'>rollover_config</span><span class='op'>&amp;.</span><span class='id identifier rubyid_runtime_metadata'>runtime_metadata</span><span class='comma'>,</span>
      <span class='label'>current_sources:</span> <span class='id identifier rubyid_indexed_type'>indexed_type</span><span class='period'>.</span><span class='id identifier rubyid_current_sources'>current_sources</span><span class='comma'>,</span>
      <span class='label'>fields_by_path:</span> <span class='id identifier rubyid_indexed_type'>indexed_type</span><span class='period'>.</span><span class='id identifier rubyid_index_field_runtime_metadata_tuples'>index_field_runtime_metadata_tuples</span><span class='period'>.</span><span class='id identifier rubyid_to_h'>to_h</span><span class='comma'>,</span>
      <span class='label'>default_sort_fields:</span> <span class='id identifier rubyid_default_sort_pairs'>default_sort_pairs</span><span class='period'>.</span><span class='id identifier rubyid_each_slice'>each_slice</span><span class='lparen'>(</span><span class='int'>2</span><span class='rparen'>)</span><span class='period'>.</span><span class='id identifier rubyid_map'>map</span> <span class='kw'>do</span> <span class='op'>|</span><span class='lparen'>(</span><span class='id identifier rubyid_graphql_field_path_name'>graphql_field_path_name</span><span class='comma'>,</span> <span class='id identifier rubyid_direction'>direction</span><span class='rparen'>)</span><span class='op'>|</span>
        <span class='const'>SchemaArtifacts</span><span class='op'>::</span><span class='const'>RuntimeMetadata</span><span class='op'>::</span><span class='const'>SortField</span><span class='period'>.</span><span class='id identifier rubyid_new'>new</span><span class='lparen'>(</span>
          <span class='label'>field_path:</span> <span class='id identifier rubyid_public_field_path'>public_field_path</span><span class='lparen'>(</span><span class='id identifier rubyid_graphql_field_path_name'>graphql_field_path_name</span><span class='comma'>,</span> <span class='label'>explanation:</span> <span class='tstring'><span class='tstring_beg'>&quot;</span><span class='tstring_content'>it is referenced as an index `default_sort` field</span><span class='tstring_end'>&quot;</span></span><span class='rparen'>)</span><span class='period'>.</span><span class='id identifier rubyid_path_in_index'>path_in_index</span><span class='comma'>,</span>
          <span class='label'>direction:</span> <span class='id identifier rubyid_direction'>direction</span>
        <span class='rparen'>)</span>
      <span class='kw'>end</span>
    <span class='rparen'>)</span>
  <span class='kw'>end</span>

  <span class='id identifier rubyid_private'>private</span>

  <span class='comment'># A regex that requires at least one non-whitespace character.
</span>  <span class='comment'># Note: this does not use the `/S` character class because it&#39;s recommended to use a small subset
</span>  <span class='comment'># of Regex syntax:
</span>  <span class='comment'>#
</span>  <span class='comment'># &gt; The regular expression syntax used is from JavaScript (ECMA 262, specifically). However, that
</span>  <span class='comment'># &gt; complete syntax is not widely supported, therefore it is recommended that you stick to the subset
</span>  <span class='comment'># &gt; of that syntax described below.
</span>  <span class='comment'>#
</span>  <span class='comment'># (From https://json-schema.org/understanding-json-schema/reference/regular_expressions.html)
</span>  <span class='const'>HAS_NON_WHITE_SPACE_REGEX</span> <span class='op'>=</span> <span class='tstring'><span class='tstring_beg'>&quot;</span><span class='tstring_content'>[^ \t\n]+</span><span class='tstring_end'>&quot;</span></span>

  <span class='const'>DEFAULT_SETTINGS</span> <span class='op'>=</span> <span class='lbrace'>{</span>
    <span class='tstring'><span class='tstring_beg'>&quot;</span><span class='tstring_content'>index.mapping.ignore_malformed</span><span class='tstring_end'>&quot;</span></span> <span class='op'>=&gt;</span> <span class='kw'>false</span><span class='comma'>,</span>
    <span class='tstring'><span class='tstring_beg'>&quot;</span><span class='tstring_content'>index.mapping.coerce</span><span class='tstring_end'>&quot;</span></span> <span class='op'>=&gt;</span> <span class='kw'>false</span><span class='comma'>,</span>
    <span class='tstring'><span class='tstring_beg'>&quot;</span><span class='tstring_content'>index.number_of_replicas</span><span class='tstring_end'>&quot;</span></span> <span class='op'>=&gt;</span> <span class='int'>1</span><span class='comma'>,</span>
    <span class='tstring'><span class='tstring_beg'>&quot;</span><span class='tstring_content'>index.number_of_shards</span><span class='tstring_end'>&quot;</span></span> <span class='op'>=&gt;</span> <span class='int'>1</span>
  <span class='rbrace'>}</span>

  <span class='kw'>def</span> <span class='id identifier rubyid_mappings'>mappings</span>
    <span class='id identifier rubyid_field_mappings'>field_mappings</span> <span class='op'>=</span> <span class='id identifier rubyid_indexed_type'>indexed_type</span>
      <span class='period'>.</span><span class='id identifier rubyid_to_indexing_field_type'>to_indexing_field_type</span>
      <span class='period'>.</span><span class='id identifier rubyid_to_mapping'>to_mapping</span>
      <span class='period'>.</span><span class='id identifier rubyid_except'>except</span><span class='lparen'>(</span><span class='tstring'><span class='tstring_beg'>&quot;</span><span class='tstring_content'>type</span><span class='tstring_end'>&quot;</span></span><span class='rparen'>)</span> <span class='comment'># `type` is invalid at the mapping root because it always has to be an object.
</span>      <span class='period'>.</span><span class='id identifier rubyid_then'>then</span> <span class='lbrace'>{</span> <span class='op'>|</span><span class='id identifier rubyid_mapping'>mapping</span><span class='op'>|</span> <span class='const'>ListCountsMapping</span><span class='period'>.</span><span class='id identifier rubyid_merged_into'>merged_into</span><span class='lparen'>(</span><span class='id identifier rubyid_mapping'>mapping</span><span class='comma'>,</span> <span class='label'>for_type:</span> <span class='id identifier rubyid_indexed_type'>indexed_type</span><span class='rparen'>)</span> <span class='rbrace'>}</span>
      <span class='period'>.</span><span class='id identifier rubyid_then'>then</span> <span class='kw'>do</span> <span class='op'>|</span><span class='id identifier rubyid_fm'>fm</span><span class='op'>|</span>
        <span class='const'><span class='object_link'><a href="../../Support.html" title="ElasticGraph::Support (module)">Support</a></span></span><span class='op'>::</span><span class='const'>HashUtil</span><span class='period'>.</span><span class='id identifier rubyid_deep_merge'>deep_merge</span><span class='lparen'>(</span><span class='id identifier rubyid_fm'>fm</span><span class='comma'>,</span> <span class='lbrace'>{</span><span class='tstring'><span class='tstring_beg'>&quot;</span><span class='tstring_content'>properties</span><span class='tstring_end'>&quot;</span></span> <span class='op'>=&gt;</span> <span class='lbrace'>{</span>
          <span class='tstring'><span class='tstring_beg'>&quot;</span><span class='tstring_content'>__sources</span><span class='tstring_end'>&quot;</span></span> <span class='op'>=&gt;</span> <span class='lbrace'>{</span><span class='tstring'><span class='tstring_beg'>&quot;</span><span class='tstring_content'>type</span><span class='tstring_end'>&quot;</span></span> <span class='op'>=&gt;</span> <span class='tstring'><span class='tstring_beg'>&quot;</span><span class='tstring_content'>keyword</span><span class='tstring_end'>&quot;</span></span><span class='rbrace'>}</span><span class='comma'>,</span>
          <span class='tstring'><span class='tstring_beg'>&quot;</span><span class='tstring_content'>__versions</span><span class='tstring_end'>&quot;</span></span> <span class='op'>=&gt;</span> <span class='lbrace'>{</span>
            <span class='tstring'><span class='tstring_beg'>&quot;</span><span class='tstring_content'>type</span><span class='tstring_end'>&quot;</span></span> <span class='op'>=&gt;</span> <span class='tstring'><span class='tstring_beg'>&quot;</span><span class='tstring_content'>object</span><span class='tstring_end'>&quot;</span></span><span class='comma'>,</span>
            <span class='comment'># __versions is map keyed by relationship name, with values that are maps keyed by id. Since it&#39;s not
</span>            <span class='comment'># a static object with known fields, we need to use dynamic here. Passing `false` allows some level
</span>            <span class='comment'># of dynamicness. As per https://www.elastic.co/guide/en/elasticsearch/reference/8.7/dynamic.html#dynamic-parameters:
</span>            <span class='comment'>#
</span>            <span class='comment'># &gt; New fields are ignored. These fields will not be indexed or searchable, but will still appear in the _source
</span>            <span class='comment'># &gt; field of returned hits. These fields will not be added to the mapping, and new fields must be added explicitly.
</span>            <span class='comment'>#
</span>            <span class='comment'># We need `__versions` to be in `_source` (so that our update scripts can operate on it), but
</span>            <span class='comment'># have no need for it to be searchable (as it&#39;s just an internal data structure used for indexing).
</span>            <span class='comment'>#
</span>            <span class='comment'># Note: we intentionally set false as a string here, because that&#39;s how the datastore echoes it back
</span>            <span class='comment'># to us when you query the mapping (even if you set it as a boolean). Our checks for index mapping
</span>            <span class='comment'># consistency fail validation if we set it as a boolean since the datastore doesn&#39;t echo it back as
</span>            <span class='comment'># a boolean.
</span>            <span class='tstring'><span class='tstring_beg'>&quot;</span><span class='tstring_content'>dynamic</span><span class='tstring_end'>&quot;</span></span> <span class='op'>=&gt;</span> <span class='tstring'><span class='tstring_beg'>&quot;</span><span class='tstring_content'>false</span><span class='tstring_end'>&quot;</span></span>
          <span class='rbrace'>}</span>
        <span class='rbrace'>}</span><span class='rbrace'>}</span><span class='rparen'>)</span>
      <span class='kw'>end</span>

    <span class='lbrace'>{</span><span class='tstring'><span class='tstring_beg'>&quot;</span><span class='tstring_content'>dynamic</span><span class='tstring_end'>&quot;</span></span> <span class='op'>=&gt;</span> <span class='tstring'><span class='tstring_beg'>&quot;</span><span class='tstring_content'>strict</span><span class='tstring_end'>&quot;</span></span><span class='rbrace'>}</span><span class='period'>.</span><span class='id identifier rubyid_merge'>merge</span><span class='lparen'>(</span><span class='id identifier rubyid_field_mappings'>field_mappings</span><span class='rparen'>)</span><span class='period'>.</span><span class='id identifier rubyid_tap'>tap</span> <span class='kw'>do</span> <span class='op'>|</span><span class='id identifier rubyid_hash'>hash</span><span class='op'>|</span>
      <span class='comment'># If we are using custom shard routing, we want to require a `routing` value to be provided
</span>      <span class='comment'># in every single index, get, delete or update request; otherwise the request might be
</span>      <span class='comment'># made against the wrong shard.
</span>      <span class='id identifier rubyid_hash'>hash</span><span class='lbracket'>[</span><span class='tstring'><span class='tstring_beg'>&quot;</span><span class='tstring_content'>_routing</span><span class='tstring_end'>&quot;</span></span><span class='rbracket'>]</span> <span class='op'>=</span> <span class='lbrace'>{</span><span class='tstring'><span class='tstring_beg'>&quot;</span><span class='tstring_content'>required</span><span class='tstring_end'>&quot;</span></span> <span class='op'>=&gt;</span> <span class='kw'>true</span><span class='rbrace'>}</span> <span class='kw'>if</span> <span class='id identifier rubyid_uses_custom_routing?'>uses_custom_routing?</span>
      <span class='id identifier rubyid_hash'>hash</span><span class='lbracket'>[</span><span class='tstring'><span class='tstring_beg'>&quot;</span><span class='tstring_content'>_size</span><span class='tstring_end'>&quot;</span></span><span class='rbracket'>]</span> <span class='op'>=</span> <span class='lbrace'>{</span><span class='tstring'><span class='tstring_beg'>&quot;</span><span class='tstring_content'>enabled</span><span class='tstring_end'>&quot;</span></span> <span class='op'>=&gt;</span> <span class='kw'>true</span><span class='rbrace'>}</span> <span class='kw'>if</span> <span class='id identifier rubyid_schema_def_state'>schema_def_state</span><span class='period'>.</span><span class='id identifier rubyid_index_document_sizes?'>index_document_sizes?</span>
    <span class='kw'>end</span>
  <span class='kw'>end</span>

  <span class='kw'>def</span> <span class='id identifier rubyid_public_field_path'>public_field_path</span><span class='lparen'>(</span><span class='id identifier rubyid_public_path_string'>public_path_string</span><span class='comma'>,</span> <span class='label'>explanation:</span><span class='rparen'>)</span>
    <span class='id identifier rubyid_parent_is_not_list'>parent_is_not_list</span> <span class='op'>=</span> <span class='tlambda'>-&gt;</span><span class='lparen'>(</span><span class='id identifier rubyid_parent_field'>parent_field</span><span class='rparen'>)</span> <span class='tlambeg'>{</span> <span class='op'>!</span><span class='id identifier rubyid_parent_field'>parent_field</span><span class='period'>.</span><span class='id identifier rubyid_type'>type</span><span class='period'>.</span><span class='id identifier rubyid_list?'>list?</span> <span class='rbrace'>}</span>
    <span class='id identifier rubyid_resolver'>resolver</span> <span class='op'>=</span> <span class='const'><span class='object_link'><a href="../SchemaElements.html" title="ElasticGraph::SchemaDefinition::SchemaElements (module)">SchemaElements</a></span></span><span class='op'>::</span><span class='const'>FieldPath</span><span class='op'>::</span><span class='const'>Resolver</span><span class='period'>.</span><span class='id identifier rubyid_new'>new</span>
    <span class='id identifier rubyid_resolved_path'>resolved_path</span> <span class='op'>=</span> <span class='id identifier rubyid_resolver'>resolver</span><span class='period'>.</span><span class='id identifier rubyid_resolve_public_path'>resolve_public_path</span><span class='lparen'>(</span><span class='id identifier rubyid_indexed_type'>indexed_type</span><span class='comma'>,</span> <span class='id identifier rubyid_public_path_string'>public_path_string</span><span class='comma'>,</span> <span class='op'>&amp;</span><span class='id identifier rubyid_parent_is_not_list'>parent_is_not_list</span><span class='rparen'>)</span>
    <span class='kw'>return</span> <span class='id identifier rubyid_resolved_path'>resolved_path</span> <span class='kw'>if</span> <span class='id identifier rubyid_resolved_path'>resolved_path</span>

    <span class='id identifier rubyid_path_parts'>path_parts</span> <span class='op'>=</span> <span class='id identifier rubyid_public_path_string'>public_path_string</span><span class='period'>.</span><span class='id identifier rubyid_split'>split</span><span class='lparen'>(</span><span class='tstring'><span class='tstring_beg'>&quot;</span><span class='tstring_content'>.</span><span class='tstring_end'>&quot;</span></span><span class='rparen'>)</span>
    <span class='id identifier rubyid_error_msg'>error_msg</span> <span class='op'>=</span> <span class='tstring'><span class='tstring_beg'>&quot;</span><span class='tstring_content'>Field `</span><span class='embexpr_beg'>#{</span><span class='id identifier rubyid_indexed_type'>indexed_type</span><span class='period'>.</span><span class='id identifier rubyid_name'>name</span><span class='embexpr_end'>}</span><span class='tstring_content'>.</span><span class='embexpr_beg'>#{</span><span class='id identifier rubyid_public_path_string'>public_path_string</span><span class='embexpr_end'>}</span><span class='tstring_content'>` cannot be resolved, but </span><span class='embexpr_beg'>#{</span><span class='id identifier rubyid_explanation'>explanation</span><span class='embexpr_end'>}</span><span class='tstring_content'>.</span><span class='tstring_end'>&quot;</span></span>

    <span class='comment'># If it is a nested field path, the problem could be that a type has been referenced which does not exist, so mention that.
</span>    <span class='kw'>if</span> <span class='id identifier rubyid_path_parts'>path_parts</span><span class='period'>.</span><span class='id identifier rubyid_size'>size</span> <span class='op'>&gt;</span> <span class='int'>1</span>
      <span class='id identifier rubyid_error_msg'>error_msg</span> <span class='op'>+=</span> <span class='tstring'><span class='tstring_beg'>&quot;</span><span class='tstring_content'> Verify that all fields and types referenced by `</span><span class='embexpr_beg'>#{</span><span class='id identifier rubyid_public_path_string'>public_path_string</span><span class='embexpr_end'>}</span><span class='tstring_content'>` are defined.</span><span class='tstring_end'>&quot;</span></span>
    <span class='kw'>end</span>

    <span class='comment'># If the first part of the path doesn&#39;t resolve, the problem could be that the field is defined after the `index` call
</span>    <span class='comment'># but it needs to be defined before it, so mention that.
</span>    <span class='kw'>if</span> <span class='id identifier rubyid_resolver'>resolver</span><span class='period'>.</span><span class='id identifier rubyid_resolve_public_path'>resolve_public_path</span><span class='lparen'>(</span><span class='id identifier rubyid_indexed_type'>indexed_type</span><span class='comma'>,</span> <span class='id identifier rubyid_path_parts'>path_parts</span><span class='period'>.</span><span class='id identifier rubyid_first'>first</span><span class='comma'>,</span> <span class='op'>&amp;</span><span class='id identifier rubyid_parent_is_not_list'>parent_is_not_list</span><span class='rparen'>)</span><span class='period'>.</span><span class='id identifier rubyid_nil?'>nil?</span>
      <span class='id identifier rubyid_error_msg'>error_msg</span> <span class='op'>+=</span> <span class='tstring'><span class='tstring_beg'>&quot;</span><span class='tstring_content'> Note: the `</span><span class='embexpr_beg'>#{</span><span class='id identifier rubyid_indexed_type'>indexed_type</span><span class='period'>.</span><span class='id identifier rubyid_name'>name</span><span class='embexpr_end'>}</span><span class='tstring_content'>.</span><span class='embexpr_beg'>#{</span><span class='id identifier rubyid_path_parts'>path_parts</span><span class='period'>.</span><span class='id identifier rubyid_first'>first</span><span class='embexpr_end'>}</span><span class='tstring_content'>` definition must come before the `index` call.</span><span class='tstring_end'>&quot;</span></span>
    <span class='kw'>end</span>

    <span class='id identifier rubyid_raise'>raise</span> <span class='const'>Errors</span><span class='op'>::</span><span class='const'>SchemaError</span><span class='comma'>,</span> <span class='id identifier rubyid_error_msg'>error_msg</span>
  <span class='kw'>end</span>

  <span class='kw'>def</span> <span class='id identifier rubyid_date_and_datetime_types'>date_and_datetime_types</span>
    <span class='ivar'>@date_and_datetime_types</span> <span class='op'>||=</span> <span class='qwords_beg'>%w[</span><span class='tstring_content'>Date</span><span class='words_sep'> </span><span class='tstring_content'>DateTime</span><span class='tstring_end'>]</span></span><span class='period'>.</span><span class='id identifier rubyid_map'>map</span> <span class='kw'>do</span> <span class='op'>|</span><span class='id identifier rubyid_type'>type</span><span class='op'>|</span>
      <span class='id identifier rubyid_schema_def_state'>schema_def_state</span><span class='period'>.</span><span class='id identifier rubyid_type_namer'>type_namer</span><span class='period'>.</span><span class='id identifier rubyid_name_for'>name_for</span><span class='lparen'>(</span><span class='id identifier rubyid_type'>type</span><span class='rparen'>)</span>
    <span class='kw'>end</span>
  <span class='kw'>end</span>
<span class='kw'>end</span></pre>
    </td>
  </tr>
</table>
</div>
    
      
      <span id=""></span>
      <div class="method_details ">
  <h3 class="signature " id="rollover_config-instance_method">
  
    #<strong>rollover_config</strong>  &#x21d2; <tt><span class='object_link'>RolloverConfig</span></tt><sup>?</sup>  <span class="extras">(readonly)</span>
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    <p>Returns rollover configuration for the index.</p>


  </div>
</div>
<div class="tags">
  
<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt><span class='object_link'>RolloverConfig</span></tt>, <tt>nil</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>rollover configuration for the index</p>
</div>
      
    </li>
  
</ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
55
56
57
58
59
60
61
62
63
64
65
66
67
68
69
70
71
72
73
74
75
76
77
78
79
80
81
82
83
84
85
86
87
88
89
90
91
92
93
94
95
96
97
98
99
100
101
102
103
104
105
106
107
108
109
110
111
112
113
114
115
116
117
118
119
120
121
122
123
124
125
126
127
128
129
130
131
132
133
134
135
136
137
138
139
140
141
142
143
144
145
146
147
148
149
150
151
152
153
154
155
156
157
158
159
160
161
162
163
164
165
166
167
168
169
170
171
172
173
174
175
176
177
178
179
180
181
182
183
184
185
186
187
188
189
190
191
192
193
194
195
196
197
198
199
200
201
202
203
204
205
206
207
208
209
210
211
212
213
214
215
216
217
218
219
220
221
222
223
224
225
226
227
228
229
230
231
232
233
234
235
236
237
238
239
240
241
242
243
244
245
246
247
248
249
250
251
252
253
254
255
256
257
258
259
260
261
262
263
264
265
266
267
268
269
270
271
272
273
274
275
276
277
278
279
280
281
282
283
284
285
286
287
288
289
290
291
292
293
294
295
296
297
298
299
300
301
302
303
304
305
306
307
308
309
310
311
312
313
314
315</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'elasticgraph-schema_definition/lib/elastic_graph/schema_definition/indexing/index.rb', line 39</span>

<span class='kw'>class</span> <span class='const'><span class='object_link'><a href="" title="ElasticGraph::SchemaDefinition::Indexing::Index (class)">Index</a></span></span> <span class='op'>&lt;</span> <span class='const'>Struct</span><span class='period'>.</span><span class='id identifier rubyid_new'>new</span><span class='lparen'>(</span><span class='symbol'>:name</span><span class='comma'>,</span> <span class='symbol'>:default_sort_pairs</span><span class='comma'>,</span> <span class='symbol'>:settings</span><span class='comma'>,</span> <span class='symbol'>:schema_def_state</span><span class='comma'>,</span> <span class='symbol'>:indexed_type</span><span class='comma'>,</span> <span class='symbol'>:routing_field_path</span><span class='comma'>,</span> <span class='symbol'>:rollover_config</span><span class='rparen'>)</span>
  <span class='id identifier rubyid_include'>include</span> <span class='const'><span class='object_link'><a href="../Mixins.html" title="ElasticGraph::SchemaDefinition::Mixins (module)">Mixins</a></span></span><span class='op'>::</span><span class='const'>HasReadableToSAndInspect</span><span class='period'>.</span><span class='id identifier rubyid_new'>new</span> <span class='lbrace'>{</span> <span class='op'>|</span><span class='id identifier rubyid_i'>i</span><span class='op'>|</span> <span class='id identifier rubyid_i'>i</span><span class='period'>.</span><span class='id identifier rubyid_name'>name</span> <span class='rbrace'>}</span>

  <span class='comment'># @param name [String] name of the index
</span>  <span class='comment'># @param settings [Hash&lt;(String, Object)&gt;] datastore settings for the index
</span>  <span class='comment'># @param schema_def_state [State] schema definition state
</span>  <span class='comment'># @param indexed_type [SchemaElements::ObjectType, SchemaElements::InterfaceType, SchemaElements::UnionType] type backed by this index
</span>  <span class='comment'># @yield [Index] the index, for further customization
</span>  <span class='comment'># @api private
</span>  <span class='kw'>def</span> <span class='id identifier rubyid_initialize'>initialize</span><span class='lparen'>(</span><span class='id identifier rubyid_name'>name</span><span class='comma'>,</span> <span class='id identifier rubyid_settings'>settings</span><span class='comma'>,</span> <span class='id identifier rubyid_schema_def_state'>schema_def_state</span><span class='comma'>,</span> <span class='id identifier rubyid_indexed_type'>indexed_type</span><span class='rparen'>)</span>
    <span class='kw'>if</span> <span class='id identifier rubyid_name'>name</span><span class='period'>.</span><span class='id identifier rubyid_include?'>include?</span><span class='lparen'>(</span><span class='const'>ROLLOVER_INDEX_INFIX_MARKER</span><span class='rparen'>)</span>
      <span class='id identifier rubyid_raise'>raise</span> <span class='const'>Errors</span><span class='op'>::</span><span class='const'>SchemaError</span><span class='comma'>,</span> <span class='tstring'><span class='tstring_beg'>&quot;</span><span class='tstring_content'>`</span><span class='embexpr_beg'>#{</span><span class='id identifier rubyid_name'>name</span><span class='embexpr_end'>}</span><span class='tstring_content'>` is an invalid index definition name since it contains </span><span class='tstring_end'>&quot;</span></span> \
        <span class='tstring'><span class='tstring_beg'>&quot;</span><span class='tstring_content'>`</span><span class='embexpr_beg'>#{</span><span class='const'>ROLLOVER_INDEX_INFIX_MARKER</span><span class='embexpr_end'>}</span><span class='tstring_content'>` which ElasticGraph treats as special.</span><span class='tstring_end'>&quot;</span></span>
    <span class='kw'>end</span>

    <span class='id identifier rubyid_settings'>settings</span> <span class='op'>=</span> <span class='const'>DEFAULT_SETTINGS</span><span class='period'>.</span><span class='id identifier rubyid_merge'>merge</span><span class='lparen'>(</span><span class='const'><span class='object_link'><a href="../../Support.html" title="ElasticGraph::Support (module)">Support</a></span></span><span class='op'>::</span><span class='const'>HashUtil</span><span class='period'>.</span><span class='id identifier rubyid_flatten_and_stringify_keys'>flatten_and_stringify_keys</span><span class='lparen'>(</span><span class='id identifier rubyid_settings'>settings</span><span class='comma'>,</span> <span class='label'>prefix:</span> <span class='tstring'><span class='tstring_beg'>&quot;</span><span class='tstring_content'>index</span><span class='tstring_end'>&quot;</span></span><span class='rparen'>)</span><span class='rparen'>)</span>

    <span class='kw'>super</span><span class='lparen'>(</span><span class='id identifier rubyid_name'>name</span><span class='comma'>,</span> <span class='lbracket'>[</span><span class='rbracket'>]</span><span class='comma'>,</span> <span class='id identifier rubyid_settings'>settings</span><span class='comma'>,</span> <span class='id identifier rubyid_schema_def_state'>schema_def_state</span><span class='comma'>,</span> <span class='id identifier rubyid_indexed_type'>indexed_type</span><span class='comma'>,</span> <span class='lbracket'>[</span><span class='rbracket'>]</span><span class='comma'>,</span> <span class='kw'>nil</span><span class='rparen'>)</span>

    <span class='comment'># `id` is the field Elasticsearch/OpenSearch use for routing by default:
</span>    <span class='comment'># https://www.elastic.co/guide/en/elasticsearch/reference/current/mapping-routing-field.html
</span>    <span class='comment'># By using it here, it will cause queries to pass a `routing` parameter when
</span>    <span class='comment'># searching with id filtering on an index that does not use custom shard routing, giving
</span>    <span class='comment'># us a nice efficiency boost.
</span>    <span class='kw'>self</span><span class='period'>.</span><span class='id identifier rubyid_routing_field_path'>routing_field_path</span> <span class='op'>=</span> <span class='id identifier rubyid_public_field_path'>public_field_path</span><span class='lparen'>(</span><span class='tstring'><span class='tstring_beg'>&quot;</span><span class='tstring_content'>id</span><span class='tstring_end'>&quot;</span></span><span class='comma'>,</span> <span class='label'>explanation:</span> <span class='tstring'><span class='tstring_beg'>&quot;</span><span class='tstring_content'>indexed types must have an `id` field</span><span class='tstring_end'>&quot;</span></span><span class='rparen'>)</span>

    <span class='kw'>yield</span> <span class='kw'>self</span> <span class='kw'>if</span> <span class='id identifier rubyid_block_given?'>block_given?</span>
  <span class='kw'>end</span>

  <span class='comment'># Specifies how documents in this index should sort by default, when no `orderBy` argument is provided to the GraphQL query.
</span>  <span class='comment'>#
</span>  <span class='comment'># @note the field name strings can be a dot-separated nested fields, but all referenced
</span>  <span class='comment'>#   fields must exist when this is called.
</span>  <span class='comment'>#
</span>  <span class='comment'># @param field_name_direction_pairs [Array&lt;(String, Symbol)&gt;] pairs of field names and `:asc` or `:desc`
</span>  <span class='comment'># @return [void]
</span>  <span class='comment'>#
</span>  <span class='comment'># @example Sort on `name` (ascending) with `createdAt` (descending) as a tie-breaker
</span>  <span class='comment'>#   ElasticGraph.define_schema do |schema|
</span>  <span class='comment'>#     schema.object_type &quot;Campaign&quot; do |t|
</span>  <span class='comment'>#       t.field &quot;id&quot;, &quot;ID!&quot;
</span>  <span class='comment'>#       t.field &quot;name&quot;, &quot;String&quot;
</span>  <span class='comment'>#       t.field &quot;createdAt&quot;, &quot;DateTime&quot;
</span>  <span class='comment'>#
</span>  <span class='comment'>#       t.index &quot;campaigns&quot;do |i|
</span>  <span class='comment'>#         i.default_sort &quot;name&quot;, :asc, &quot;createdAt&quot;, :desc
</span>  <span class='comment'>#       end
</span>  <span class='comment'>#     end
</span>  <span class='comment'>#   end
</span>  <span class='kw'>def</span> <span class='id identifier rubyid_default_sort'>default_sort</span><span class='lparen'>(</span><span class='op'>*</span><span class='id identifier rubyid_field_name_direction_pairs'>field_name_direction_pairs</span><span class='rparen'>)</span>
    <span class='kw'>self</span><span class='period'>.</span><span class='id identifier rubyid_default_sort_pairs'>default_sort_pairs</span> <span class='op'>=</span> <span class='id identifier rubyid_field_name_direction_pairs'>field_name_direction_pairs</span>
  <span class='kw'>end</span>

  <span class='comment'># Causes this index to &quot;rollover&quot; at the provided `frequency` based on the value of the provided `timestamp_field_path_name`.
</span>  <span class='comment'># This is particularly useful for time-series data. Partitioning the data into `hourly`, `daily`, `monthly` or `yearly` buckets
</span>  <span class='comment'># allows for different index configurations, and can be necessary when a dataset is too large to fit in one dataset given
</span>  <span class='comment'># Elasticsearch/OpenSearch limitations on the number of shards in one index. In addition, ElasticGraph optimizes queries which
</span>  <span class='comment'># filter on the timestamp field to target the subset of the indices in which matching documents could reside.
</span>  <span class='comment'>#
</span>  <span class='comment'># @note the timestamp field specified here **must be immutable**. To understand why, consider a `:yearly` rollover
</span>  <span class='comment'>#   index used for data based on `createdAt`; if ElasticGraph ingests record `123` with a createdAt of `2023-12-31T23:59:59Z`, it
</span>  <span class='comment'>#   will be indexed in the `2023` index. Later if it receives an update event for record `123` with a `createdAt` of
</span>  <span class='comment'>#   `2024-01-01T00:00:00Z` (a mere one second later!), ElasticGraph will store the new version of the payment in the `2024` index,
</span>  <span class='comment'>#   and leave the old copy of the payment in the `2023` index unchanged. It’ll have duplicates for that document.
</span>  <span class='comment'># @note changing the `rollover` configuration on an existing index that already has data will result in duplicate documents
</span>  <span class='comment'>#
</span>  <span class='comment'># @param frequency [:yearly, :monthly, :daily, :hourly] how often to rollover the index
</span>  <span class='comment'># @param timestamp_field_path_name [String] dot-separated path to the timestamp field used for rollover. Note: all referenced
</span>  <span class='comment'>#   fields must exist when this is called.
</span>  <span class='comment'># @return [void]
</span>  <span class='comment'>#
</span>  <span class='comment'># @example Define a `campaigns` index to rollover yearly based on `createdAt`
</span>  <span class='comment'>#   ElasticGraph.define_schema do |schema|
</span>  <span class='comment'>#     schema.object_type &quot;Campaign&quot; do |t|
</span>  <span class='comment'>#       t.field &quot;id&quot;, &quot;ID!&quot;
</span>  <span class='comment'>#       t.field &quot;name&quot;, &quot;String&quot;
</span>  <span class='comment'>#       t.field &quot;createdAt&quot;, &quot;DateTime&quot;
</span>  <span class='comment'>#
</span>  <span class='comment'>#       t.index &quot;campaigns&quot;do |i|
</span>  <span class='comment'>#         i.rollover :yearly, &quot;createdAt&quot;
</span>  <span class='comment'>#       end
</span>  <span class='comment'>#     end
</span>  <span class='comment'>#   end
</span>  <span class='kw'>def</span> <span class='id identifier rubyid_rollover'>rollover</span><span class='lparen'>(</span><span class='id identifier rubyid_frequency'>frequency</span><span class='comma'>,</span> <span class='id identifier rubyid_timestamp_field_path_name'>timestamp_field_path_name</span><span class='rparen'>)</span>
    <span class='id identifier rubyid_timestamp_field_path'>timestamp_field_path</span> <span class='op'>=</span> <span class='id identifier rubyid_public_field_path'>public_field_path</span><span class='lparen'>(</span><span class='id identifier rubyid_timestamp_field_path_name'>timestamp_field_path_name</span><span class='comma'>,</span> <span class='label'>explanation:</span> <span class='tstring'><span class='tstring_beg'>&quot;</span><span class='tstring_content'>it is referenced as an index `rollover` field</span><span class='tstring_end'>&quot;</span></span><span class='rparen'>)</span>

    <span class='kw'>unless</span> <span class='id identifier rubyid_date_and_datetime_types'>date_and_datetime_types</span><span class='period'>.</span><span class='id identifier rubyid_include?'>include?</span><span class='lparen'>(</span><span class='id identifier rubyid_timestamp_field_path'>timestamp_field_path</span><span class='period'>.</span><span class='id identifier rubyid_type'>type</span><span class='period'>.</span><span class='id identifier rubyid_fully_unwrapped'>fully_unwrapped</span><span class='period'>.</span><span class='id identifier rubyid_name'>name</span><span class='rparen'>)</span>
      <span class='id identifier rubyid_date_or_datetime_description'>date_or_datetime_description</span> <span class='op'>=</span> <span class='id identifier rubyid_date_and_datetime_types'>date_and_datetime_types</span><span class='period'>.</span><span class='id identifier rubyid_map'>map</span> <span class='lbrace'>{</span> <span class='op'>|</span><span class='id identifier rubyid_t'>t</span><span class='op'>|</span> <span class='tstring'><span class='tstring_beg'>&quot;</span><span class='tstring_content'>`</span><span class='embexpr_beg'>#{</span><span class='id identifier rubyid_t'>t</span><span class='embexpr_end'>}</span><span class='tstring_content'>`</span><span class='tstring_end'>&quot;</span></span> <span class='rbrace'>}</span><span class='period'>.</span><span class='id identifier rubyid_join'>join</span><span class='lparen'>(</span><span class='tstring'><span class='tstring_beg'>&quot;</span><span class='tstring_content'> or </span><span class='tstring_end'>&quot;</span></span><span class='rparen'>)</span>
      <span class='id identifier rubyid_raise'>raise</span> <span class='const'>Errors</span><span class='op'>::</span><span class='const'>SchemaError</span><span class='comma'>,</span> <span class='tstring'><span class='tstring_beg'>&quot;</span><span class='tstring_content'>rollover field `</span><span class='embexpr_beg'>#{</span><span class='id identifier rubyid_timestamp_field_path'>timestamp_field_path</span><span class='period'>.</span><span class='id identifier rubyid_full_description'>full_description</span><span class='embexpr_end'>}</span><span class='tstring_content'>` cannot be used for rollover since it is not a </span><span class='embexpr_beg'>#{</span><span class='id identifier rubyid_date_or_datetime_description'>date_or_datetime_description</span><span class='embexpr_end'>}</span><span class='tstring_content'> field.</span><span class='tstring_end'>&quot;</span></span>
    <span class='kw'>end</span>

    <span class='kw'>if</span> <span class='id identifier rubyid_timestamp_field_path'>timestamp_field_path</span><span class='period'>.</span><span class='id identifier rubyid_type'>type</span><span class='period'>.</span><span class='id identifier rubyid_list?'>list?</span>
      <span class='id identifier rubyid_raise'>raise</span> <span class='const'>Errors</span><span class='op'>::</span><span class='const'>SchemaError</span><span class='comma'>,</span> <span class='tstring'><span class='tstring_beg'>&quot;</span><span class='tstring_content'>rollover field `</span><span class='embexpr_beg'>#{</span><span class='id identifier rubyid_timestamp_field_path'>timestamp_field_path</span><span class='period'>.</span><span class='id identifier rubyid_full_description'>full_description</span><span class='embexpr_end'>}</span><span class='tstring_content'>` cannot be used for rollover since it is a list field.</span><span class='tstring_end'>&quot;</span></span>
    <span class='kw'>end</span>

    <span class='id identifier rubyid_timestamp_field_path'>timestamp_field_path</span><span class='period'>.</span><span class='id identifier rubyid_path_parts'>path_parts</span><span class='period'>.</span><span class='id identifier rubyid_each'>each</span> <span class='lbrace'>{</span> <span class='op'>|</span><span class='id identifier rubyid_f'>f</span><span class='op'>|</span> <span class='id identifier rubyid_f'>f</span><span class='period'>.</span><span class='id identifier rubyid_json_schema'>json_schema</span> <span class='label'>nullable:</span> <span class='kw'>false</span> <span class='rbrace'>}</span>

    <span class='kw'>self</span><span class='period'>.</span><span class='id identifier rubyid_rollover_config'>rollover_config</span> <span class='op'>=</span> <span class='const'>RolloverConfig</span><span class='period'>.</span><span class='id identifier rubyid_new'>new</span><span class='lparen'>(</span>
      <span class='label'>frequency:</span> <span class='id identifier rubyid_frequency'>frequency</span><span class='comma'>,</span>
      <span class='label'>timestamp_field_path:</span> <span class='id identifier rubyid_timestamp_field_path'>timestamp_field_path</span>
    <span class='rparen'>)</span>
  <span class='kw'>end</span>

  <span class='comment'># Configures the index to [route documents to shards](https://www.elastic.co/guide/en/elasticsearch/reference/8.15/mapping-routing-field.html)
</span>  <span class='comment'># based on the specified field. ElasticGraph optimizes queries that filter on the shard routing field so that they only run on a
</span>  <span class='comment'># subset of nodes instead of all nodes. This can make a big difference in query performance if queries usually filter on a certain
</span>  <span class='comment'># field. Using an appropriate field for shard routing is often essential for horizontal scaling, as it avoids having every query
</span>  <span class='comment'># hit every node, allowing additional nodes to increase query throughput.
</span>  <span class='comment'>#
</span>  <span class='comment'># @note it is essential that the shards are well-balanced. If the data’s distribution is lopsided, using this feature can make
</span>  <span class='comment'>#   performance worse.
</span>  <span class='comment'># @note the routing field specified here **must be immutable**. If ElasticGraph receives an updated version of a document with a
</span>  <span class='comment'>#   different routing value, it’ll write the new version of the document to a different shard and leave the copy on the old shard
</span>  <span class='comment'>#   unchanged, leading to duplicates.
</span>  <span class='comment'># @note changing the shard routing configuration on an existing index that already has data will result in duplicate documents
</span>  <span class='comment'>#
</span>  <span class='comment'># @param routing_field_path_name [String] dot-separated path to the field used for shard routing. Note: all referenced
</span>  <span class='comment'>#   fields must exist when this is called.
</span>  <span class='comment'># @return [void]
</span>  <span class='comment'>#
</span>  <span class='comment'># @example Define a `campaigns` index to shard on `organizationId`
</span>  <span class='comment'>#   ElasticGraph.define_schema do |schema|
</span>  <span class='comment'>#     schema.object_type &quot;Campaign&quot; do |t|
</span>  <span class='comment'>#       t.field &quot;id&quot;, &quot;ID!&quot;
</span>  <span class='comment'>#       t.field &quot;name&quot;, &quot;String&quot;
</span>  <span class='comment'>#       t.field &quot;organizationId&quot;, &quot;ID&quot;
</span>  <span class='comment'>#
</span>  <span class='comment'>#       t.index &quot;campaigns&quot;do |i|
</span>  <span class='comment'>#         i.route_with &quot;organizationId&quot;
</span>  <span class='comment'>#       end
</span>  <span class='comment'>#     end
</span>  <span class='comment'>#   end
</span>  <span class='kw'>def</span> <span class='id identifier rubyid_route_with'>route_with</span><span class='lparen'>(</span><span class='id identifier rubyid_routing_field_path_name'>routing_field_path_name</span><span class='rparen'>)</span>
    <span class='id identifier rubyid_routing_field_path'>routing_field_path</span> <span class='op'>=</span> <span class='id identifier rubyid_public_field_path'>public_field_path</span><span class='lparen'>(</span><span class='id identifier rubyid_routing_field_path_name'>routing_field_path_name</span><span class='comma'>,</span> <span class='label'>explanation:</span> <span class='tstring'><span class='tstring_beg'>&quot;</span><span class='tstring_content'>it is referenced as an index `route_with` field</span><span class='tstring_end'>&quot;</span></span><span class='rparen'>)</span>

    <span class='kw'>unless</span> <span class='id identifier rubyid_routing_field_path'>routing_field_path</span><span class='period'>.</span><span class='id identifier rubyid_type'>type</span><span class='period'>.</span><span class='id identifier rubyid_leaf?'>leaf?</span>
      <span class='id identifier rubyid_raise'>raise</span> <span class='const'>Errors</span><span class='op'>::</span><span class='const'>SchemaError</span><span class='comma'>,</span> <span class='tstring'><span class='tstring_beg'>&quot;</span><span class='tstring_content'>shard routing field `</span><span class='embexpr_beg'>#{</span><span class='id identifier rubyid_routing_field_path'>routing_field_path</span><span class='period'>.</span><span class='id identifier rubyid_full_description'>full_description</span><span class='embexpr_end'>}</span><span class='tstring_content'>` cannot be used for routing since it is not a leaf field.</span><span class='tstring_end'>&quot;</span></span>
    <span class='kw'>end</span>

    <span class='kw'>self</span><span class='period'>.</span><span class='id identifier rubyid_routing_field_path'>routing_field_path</span> <span class='op'>=</span> <span class='id identifier rubyid_routing_field_path'>routing_field_path</span>

    <span class='id identifier rubyid_routing_field_path'>routing_field_path</span><span class='period'>.</span><span class='id identifier rubyid_path_parts'>path_parts</span><span class='lbracket'>[</span><span class='int'>0</span><span class='op'>..</span><span class='op'>-</span><span class='int'>2</span><span class='rbracket'>]</span><span class='period'>.</span><span class='id identifier rubyid_each'>each</span> <span class='lbrace'>{</span> <span class='op'>|</span><span class='id identifier rubyid_f'>f</span><span class='op'>|</span> <span class='id identifier rubyid_f'>f</span><span class='period'>.</span><span class='id identifier rubyid_json_schema'>json_schema</span> <span class='label'>nullable:</span> <span class='kw'>false</span> <span class='rbrace'>}</span>
    <span class='id identifier rubyid_routing_field_path'>routing_field_path</span><span class='period'>.</span><span class='id identifier rubyid_last_part'>last_part</span><span class='period'>.</span><span class='id identifier rubyid_json_schema'>json_schema</span> <span class='label'>nullable:</span> <span class='kw'>false</span><span class='comma'>,</span> <span class='label'>pattern:</span> <span class='const'>HAS_NON_WHITE_SPACE_REGEX</span>
    <span class='id identifier rubyid_indexed_type'>indexed_type</span><span class='period'>.</span><span class='id identifier rubyid_append_to_documentation'>append_to_documentation</span> <span class='tstring'><span class='tstring_beg'>&quot;</span><span class='tstring_content'>For more performant queries on this type, please filter on `</span><span class='embexpr_beg'>#{</span><span class='id identifier rubyid_routing_field_path_name'>routing_field_path_name</span><span class='embexpr_end'>}</span><span class='tstring_content'>` if possible.</span><span class='tstring_end'>&quot;</span></span>
  <span class='kw'>end</span>

  <span class='comment'># @see #route_with
</span>  <span class='comment'># @return [Boolean] whether or not this index uses custom shard routing
</span>  <span class='kw'>def</span> <span class='id identifier rubyid_uses_custom_routing?'>uses_custom_routing?</span>
    <span class='id identifier rubyid_routing_field_path'>routing_field_path</span><span class='period'>.</span><span class='id identifier rubyid_path_in_index'>path_in_index</span> <span class='op'>!=</span> <span class='tstring'><span class='tstring_beg'>&quot;</span><span class='tstring_content'>id</span><span class='tstring_end'>&quot;</span></span>
  <span class='kw'>end</span>

  <span class='comment'># @return [Hash&lt;String, Object&gt;] datastore configuration for this index for when it does not use rollover
</span>  <span class='kw'>def</span> <span class='id identifier rubyid_to_index_config'>to_index_config</span>
    <span class='lbrace'>{</span>
      <span class='tstring'><span class='tstring_beg'>&quot;</span><span class='tstring_content'>aliases</span><span class='tstring_end'>&quot;</span></span> <span class='op'>=&gt;</span> <span class='lbrace'>{</span><span class='rbrace'>}</span><span class='comma'>,</span>
      <span class='tstring'><span class='tstring_beg'>&quot;</span><span class='tstring_content'>mappings</span><span class='tstring_end'>&quot;</span></span> <span class='op'>=&gt;</span> <span class='id identifier rubyid_mappings'>mappings</span><span class='comma'>,</span>
      <span class='tstring'><span class='tstring_beg'>&quot;</span><span class='tstring_content'>settings</span><span class='tstring_end'>&quot;</span></span> <span class='op'>=&gt;</span> <span class='id identifier rubyid_settings'>settings</span>
    <span class='rbrace'>}</span><span class='period'>.</span><span class='id identifier rubyid_compact'>compact</span>
  <span class='kw'>end</span>

  <span class='comment'># @return [Hash&lt;String, Object&gt;] datastore configuration for the index template that will be defined if rollover is used
</span>  <span class='kw'>def</span> <span class='id identifier rubyid_to_index_template_config'>to_index_template_config</span>
    <span class='lbrace'>{</span>
      <span class='tstring'><span class='tstring_beg'>&quot;</span><span class='tstring_content'>index_patterns</span><span class='tstring_end'>&quot;</span></span> <span class='op'>=&gt;</span> <span class='lbracket'>[</span><span class='tstring'><span class='tstring_beg'>&quot;</span><span class='embexpr_beg'>#{</span><span class='id identifier rubyid_name'>name</span><span class='embexpr_end'>}</span><span class='embexpr_beg'>#{</span><span class='const'>ROLLOVER_INDEX_INFIX_MARKER</span><span class='embexpr_end'>}</span><span class='tstring_content'>*</span><span class='tstring_end'>&quot;</span></span><span class='rbracket'>]</span><span class='comma'>,</span>
      <span class='tstring'><span class='tstring_beg'>&quot;</span><span class='tstring_content'>template</span><span class='tstring_end'>&quot;</span></span> <span class='op'>=&gt;</span> <span class='lbrace'>{</span>
        <span class='tstring'><span class='tstring_beg'>&quot;</span><span class='tstring_content'>aliases</span><span class='tstring_end'>&quot;</span></span> <span class='op'>=&gt;</span> <span class='lbrace'>{</span><span class='rbrace'>}</span><span class='comma'>,</span>
        <span class='tstring'><span class='tstring_beg'>&quot;</span><span class='tstring_content'>mappings</span><span class='tstring_end'>&quot;</span></span> <span class='op'>=&gt;</span> <span class='id identifier rubyid_mappings'>mappings</span><span class='comma'>,</span>
        <span class='tstring'><span class='tstring_beg'>&quot;</span><span class='tstring_content'>settings</span><span class='tstring_end'>&quot;</span></span> <span class='op'>=&gt;</span> <span class='id identifier rubyid_settings'>settings</span>
      <span class='rbrace'>}</span>
    <span class='rbrace'>}</span>
  <span class='kw'>end</span>

  <span class='comment'># @return [SchemaArtifacts::RuntimeMetadata::IndexDefinition] runtime metadata for this index
</span>  <span class='kw'>def</span> <span class='id identifier rubyid_runtime_metadata'>runtime_metadata</span>
    <span class='const'>SchemaArtifacts</span><span class='op'>::</span><span class='const'>RuntimeMetadata</span><span class='op'>::</span><span class='const'>IndexDefinition</span><span class='period'>.</span><span class='id identifier rubyid_new'>new</span><span class='lparen'>(</span>
      <span class='label'>route_with:</span> <span class='id identifier rubyid_routing_field_path'>routing_field_path</span><span class='period'>.</span><span class='id identifier rubyid_path_in_index'>path_in_index</span><span class='comma'>,</span>
      <span class='label'>rollover:</span> <span class='id identifier rubyid_rollover_config'>rollover_config</span><span class='op'>&amp;.</span><span class='id identifier rubyid_runtime_metadata'>runtime_metadata</span><span class='comma'>,</span>
      <span class='label'>current_sources:</span> <span class='id identifier rubyid_indexed_type'>indexed_type</span><span class='period'>.</span><span class='id identifier rubyid_current_sources'>current_sources</span><span class='comma'>,</span>
      <span class='label'>fields_by_path:</span> <span class='id identifier rubyid_indexed_type'>indexed_type</span><span class='period'>.</span><span class='id identifier rubyid_index_field_runtime_metadata_tuples'>index_field_runtime_metadata_tuples</span><span class='period'>.</span><span class='id identifier rubyid_to_h'>to_h</span><span class='comma'>,</span>
      <span class='label'>default_sort_fields:</span> <span class='id identifier rubyid_default_sort_pairs'>default_sort_pairs</span><span class='period'>.</span><span class='id identifier rubyid_each_slice'>each_slice</span><span class='lparen'>(</span><span class='int'>2</span><span class='rparen'>)</span><span class='period'>.</span><span class='id identifier rubyid_map'>map</span> <span class='kw'>do</span> <span class='op'>|</span><span class='lparen'>(</span><span class='id identifier rubyid_graphql_field_path_name'>graphql_field_path_name</span><span class='comma'>,</span> <span class='id identifier rubyid_direction'>direction</span><span class='rparen'>)</span><span class='op'>|</span>
        <span class='const'>SchemaArtifacts</span><span class='op'>::</span><span class='const'>RuntimeMetadata</span><span class='op'>::</span><span class='const'>SortField</span><span class='period'>.</span><span class='id identifier rubyid_new'>new</span><span class='lparen'>(</span>
          <span class='label'>field_path:</span> <span class='id identifier rubyid_public_field_path'>public_field_path</span><span class='lparen'>(</span><span class='id identifier rubyid_graphql_field_path_name'>graphql_field_path_name</span><span class='comma'>,</span> <span class='label'>explanation:</span> <span class='tstring'><span class='tstring_beg'>&quot;</span><span class='tstring_content'>it is referenced as an index `default_sort` field</span><span class='tstring_end'>&quot;</span></span><span class='rparen'>)</span><span class='period'>.</span><span class='id identifier rubyid_path_in_index'>path_in_index</span><span class='comma'>,</span>
          <span class='label'>direction:</span> <span class='id identifier rubyid_direction'>direction</span>
        <span class='rparen'>)</span>
      <span class='kw'>end</span>
    <span class='rparen'>)</span>
  <span class='kw'>end</span>

  <span class='id identifier rubyid_private'>private</span>

  <span class='comment'># A regex that requires at least one non-whitespace character.
</span>  <span class='comment'># Note: this does not use the `/S` character class because it&#39;s recommended to use a small subset
</span>  <span class='comment'># of Regex syntax:
</span>  <span class='comment'>#
</span>  <span class='comment'># &gt; The regular expression syntax used is from JavaScript (ECMA 262, specifically). However, that
</span>  <span class='comment'># &gt; complete syntax is not widely supported, therefore it is recommended that you stick to the subset
</span>  <span class='comment'># &gt; of that syntax described below.
</span>  <span class='comment'>#
</span>  <span class='comment'># (From https://json-schema.org/understanding-json-schema/reference/regular_expressions.html)
</span>  <span class='const'>HAS_NON_WHITE_SPACE_REGEX</span> <span class='op'>=</span> <span class='tstring'><span class='tstring_beg'>&quot;</span><span class='tstring_content'>[^ \t\n]+</span><span class='tstring_end'>&quot;</span></span>

  <span class='const'>DEFAULT_SETTINGS</span> <span class='op'>=</span> <span class='lbrace'>{</span>
    <span class='tstring'><span class='tstring_beg'>&quot;</span><span class='tstring_content'>index.mapping.ignore_malformed</span><span class='tstring_end'>&quot;</span></span> <span class='op'>=&gt;</span> <span class='kw'>false</span><span class='comma'>,</span>
    <span class='tstring'><span class='tstring_beg'>&quot;</span><span class='tstring_content'>index.mapping.coerce</span><span class='tstring_end'>&quot;</span></span> <span class='op'>=&gt;</span> <span class='kw'>false</span><span class='comma'>,</span>
    <span class='tstring'><span class='tstring_beg'>&quot;</span><span class='tstring_content'>index.number_of_replicas</span><span class='tstring_end'>&quot;</span></span> <span class='op'>=&gt;</span> <span class='int'>1</span><span class='comma'>,</span>
    <span class='tstring'><span class='tstring_beg'>&quot;</span><span class='tstring_content'>index.number_of_shards</span><span class='tstring_end'>&quot;</span></span> <span class='op'>=&gt;</span> <span class='int'>1</span>
  <span class='rbrace'>}</span>

  <span class='kw'>def</span> <span class='id identifier rubyid_mappings'>mappings</span>
    <span class='id identifier rubyid_field_mappings'>field_mappings</span> <span class='op'>=</span> <span class='id identifier rubyid_indexed_type'>indexed_type</span>
      <span class='period'>.</span><span class='id identifier rubyid_to_indexing_field_type'>to_indexing_field_type</span>
      <span class='period'>.</span><span class='id identifier rubyid_to_mapping'>to_mapping</span>
      <span class='period'>.</span><span class='id identifier rubyid_except'>except</span><span class='lparen'>(</span><span class='tstring'><span class='tstring_beg'>&quot;</span><span class='tstring_content'>type</span><span class='tstring_end'>&quot;</span></span><span class='rparen'>)</span> <span class='comment'># `type` is invalid at the mapping root because it always has to be an object.
</span>      <span class='period'>.</span><span class='id identifier rubyid_then'>then</span> <span class='lbrace'>{</span> <span class='op'>|</span><span class='id identifier rubyid_mapping'>mapping</span><span class='op'>|</span> <span class='const'>ListCountsMapping</span><span class='period'>.</span><span class='id identifier rubyid_merged_into'>merged_into</span><span class='lparen'>(</span><span class='id identifier rubyid_mapping'>mapping</span><span class='comma'>,</span> <span class='label'>for_type:</span> <span class='id identifier rubyid_indexed_type'>indexed_type</span><span class='rparen'>)</span> <span class='rbrace'>}</span>
      <span class='period'>.</span><span class='id identifier rubyid_then'>then</span> <span class='kw'>do</span> <span class='op'>|</span><span class='id identifier rubyid_fm'>fm</span><span class='op'>|</span>
        <span class='const'><span class='object_link'><a href="../../Support.html" title="ElasticGraph::Support (module)">Support</a></span></span><span class='op'>::</span><span class='const'>HashUtil</span><span class='period'>.</span><span class='id identifier rubyid_deep_merge'>deep_merge</span><span class='lparen'>(</span><span class='id identifier rubyid_fm'>fm</span><span class='comma'>,</span> <span class='lbrace'>{</span><span class='tstring'><span class='tstring_beg'>&quot;</span><span class='tstring_content'>properties</span><span class='tstring_end'>&quot;</span></span> <span class='op'>=&gt;</span> <span class='lbrace'>{</span>
          <span class='tstring'><span class='tstring_beg'>&quot;</span><span class='tstring_content'>__sources</span><span class='tstring_end'>&quot;</span></span> <span class='op'>=&gt;</span> <span class='lbrace'>{</span><span class='tstring'><span class='tstring_beg'>&quot;</span><span class='tstring_content'>type</span><span class='tstring_end'>&quot;</span></span> <span class='op'>=&gt;</span> <span class='tstring'><span class='tstring_beg'>&quot;</span><span class='tstring_content'>keyword</span><span class='tstring_end'>&quot;</span></span><span class='rbrace'>}</span><span class='comma'>,</span>
          <span class='tstring'><span class='tstring_beg'>&quot;</span><span class='tstring_content'>__versions</span><span class='tstring_end'>&quot;</span></span> <span class='op'>=&gt;</span> <span class='lbrace'>{</span>
            <span class='tstring'><span class='tstring_beg'>&quot;</span><span class='tstring_content'>type</span><span class='tstring_end'>&quot;</span></span> <span class='op'>=&gt;</span> <span class='tstring'><span class='tstring_beg'>&quot;</span><span class='tstring_content'>object</span><span class='tstring_end'>&quot;</span></span><span class='comma'>,</span>
            <span class='comment'># __versions is map keyed by relationship name, with values that are maps keyed by id. Since it&#39;s not
</span>            <span class='comment'># a static object with known fields, we need to use dynamic here. Passing `false` allows some level
</span>            <span class='comment'># of dynamicness. As per https://www.elastic.co/guide/en/elasticsearch/reference/8.7/dynamic.html#dynamic-parameters:
</span>            <span class='comment'>#
</span>            <span class='comment'># &gt; New fields are ignored. These fields will not be indexed or searchable, but will still appear in the _source
</span>            <span class='comment'># &gt; field of returned hits. These fields will not be added to the mapping, and new fields must be added explicitly.
</span>            <span class='comment'>#
</span>            <span class='comment'># We need `__versions` to be in `_source` (so that our update scripts can operate on it), but
</span>            <span class='comment'># have no need for it to be searchable (as it&#39;s just an internal data structure used for indexing).
</span>            <span class='comment'>#
</span>            <span class='comment'># Note: we intentionally set false as a string here, because that&#39;s how the datastore echoes it back
</span>            <span class='comment'># to us when you query the mapping (even if you set it as a boolean). Our checks for index mapping
</span>            <span class='comment'># consistency fail validation if we set it as a boolean since the datastore doesn&#39;t echo it back as
</span>            <span class='comment'># a boolean.
</span>            <span class='tstring'><span class='tstring_beg'>&quot;</span><span class='tstring_content'>dynamic</span><span class='tstring_end'>&quot;</span></span> <span class='op'>=&gt;</span> <span class='tstring'><span class='tstring_beg'>&quot;</span><span class='tstring_content'>false</span><span class='tstring_end'>&quot;</span></span>
          <span class='rbrace'>}</span>
        <span class='rbrace'>}</span><span class='rbrace'>}</span><span class='rparen'>)</span>
      <span class='kw'>end</span>

    <span class='lbrace'>{</span><span class='tstring'><span class='tstring_beg'>&quot;</span><span class='tstring_content'>dynamic</span><span class='tstring_end'>&quot;</span></span> <span class='op'>=&gt;</span> <span class='tstring'><span class='tstring_beg'>&quot;</span><span class='tstring_content'>strict</span><span class='tstring_end'>&quot;</span></span><span class='rbrace'>}</span><span class='period'>.</span><span class='id identifier rubyid_merge'>merge</span><span class='lparen'>(</span><span class='id identifier rubyid_field_mappings'>field_mappings</span><span class='rparen'>)</span><span class='period'>.</span><span class='id identifier rubyid_tap'>tap</span> <span class='kw'>do</span> <span class='op'>|</span><span class='id identifier rubyid_hash'>hash</span><span class='op'>|</span>
      <span class='comment'># If we are using custom shard routing, we want to require a `routing` value to be provided
</span>      <span class='comment'># in every single index, get, delete or update request; otherwise the request might be
</span>      <span class='comment'># made against the wrong shard.
</span>      <span class='id identifier rubyid_hash'>hash</span><span class='lbracket'>[</span><span class='tstring'><span class='tstring_beg'>&quot;</span><span class='tstring_content'>_routing</span><span class='tstring_end'>&quot;</span></span><span class='rbracket'>]</span> <span class='op'>=</span> <span class='lbrace'>{</span><span class='tstring'><span class='tstring_beg'>&quot;</span><span class='tstring_content'>required</span><span class='tstring_end'>&quot;</span></span> <span class='op'>=&gt;</span> <span class='kw'>true</span><span class='rbrace'>}</span> <span class='kw'>if</span> <span class='id identifier rubyid_uses_custom_routing?'>uses_custom_routing?</span>
      <span class='id identifier rubyid_hash'>hash</span><span class='lbracket'>[</span><span class='tstring'><span class='tstring_beg'>&quot;</span><span class='tstring_content'>_size</span><span class='tstring_end'>&quot;</span></span><span class='rbracket'>]</span> <span class='op'>=</span> <span class='lbrace'>{</span><span class='tstring'><span class='tstring_beg'>&quot;</span><span class='tstring_content'>enabled</span><span class='tstring_end'>&quot;</span></span> <span class='op'>=&gt;</span> <span class='kw'>true</span><span class='rbrace'>}</span> <span class='kw'>if</span> <span class='id identifier rubyid_schema_def_state'>schema_def_state</span><span class='period'>.</span><span class='id identifier rubyid_index_document_sizes?'>index_document_sizes?</span>
    <span class='kw'>end</span>
  <span class='kw'>end</span>

  <span class='kw'>def</span> <span class='id identifier rubyid_public_field_path'>public_field_path</span><span class='lparen'>(</span><span class='id identifier rubyid_public_path_string'>public_path_string</span><span class='comma'>,</span> <span class='label'>explanation:</span><span class='rparen'>)</span>
    <span class='id identifier rubyid_parent_is_not_list'>parent_is_not_list</span> <span class='op'>=</span> <span class='tlambda'>-&gt;</span><span class='lparen'>(</span><span class='id identifier rubyid_parent_field'>parent_field</span><span class='rparen'>)</span> <span class='tlambeg'>{</span> <span class='op'>!</span><span class='id identifier rubyid_parent_field'>parent_field</span><span class='period'>.</span><span class='id identifier rubyid_type'>type</span><span class='period'>.</span><span class='id identifier rubyid_list?'>list?</span> <span class='rbrace'>}</span>
    <span class='id identifier rubyid_resolver'>resolver</span> <span class='op'>=</span> <span class='const'><span class='object_link'><a href="../SchemaElements.html" title="ElasticGraph::SchemaDefinition::SchemaElements (module)">SchemaElements</a></span></span><span class='op'>::</span><span class='const'>FieldPath</span><span class='op'>::</span><span class='const'>Resolver</span><span class='period'>.</span><span class='id identifier rubyid_new'>new</span>
    <span class='id identifier rubyid_resolved_path'>resolved_path</span> <span class='op'>=</span> <span class='id identifier rubyid_resolver'>resolver</span><span class='period'>.</span><span class='id identifier rubyid_resolve_public_path'>resolve_public_path</span><span class='lparen'>(</span><span class='id identifier rubyid_indexed_type'>indexed_type</span><span class='comma'>,</span> <span class='id identifier rubyid_public_path_string'>public_path_string</span><span class='comma'>,</span> <span class='op'>&amp;</span><span class='id identifier rubyid_parent_is_not_list'>parent_is_not_list</span><span class='rparen'>)</span>
    <span class='kw'>return</span> <span class='id identifier rubyid_resolved_path'>resolved_path</span> <span class='kw'>if</span> <span class='id identifier rubyid_resolved_path'>resolved_path</span>

    <span class='id identifier rubyid_path_parts'>path_parts</span> <span class='op'>=</span> <span class='id identifier rubyid_public_path_string'>public_path_string</span><span class='period'>.</span><span class='id identifier rubyid_split'>split</span><span class='lparen'>(</span><span class='tstring'><span class='tstring_beg'>&quot;</span><span class='tstring_content'>.</span><span class='tstring_end'>&quot;</span></span><span class='rparen'>)</span>
    <span class='id identifier rubyid_error_msg'>error_msg</span> <span class='op'>=</span> <span class='tstring'><span class='tstring_beg'>&quot;</span><span class='tstring_content'>Field `</span><span class='embexpr_beg'>#{</span><span class='id identifier rubyid_indexed_type'>indexed_type</span><span class='period'>.</span><span class='id identifier rubyid_name'>name</span><span class='embexpr_end'>}</span><span class='tstring_content'>.</span><span class='embexpr_beg'>#{</span><span class='id identifier rubyid_public_path_string'>public_path_string</span><span class='embexpr_end'>}</span><span class='tstring_content'>` cannot be resolved, but </span><span class='embexpr_beg'>#{</span><span class='id identifier rubyid_explanation'>explanation</span><span class='embexpr_end'>}</span><span class='tstring_content'>.</span><span class='tstring_end'>&quot;</span></span>

    <span class='comment'># If it is a nested field path, the problem could be that a type has been referenced which does not exist, so mention that.
</span>    <span class='kw'>if</span> <span class='id identifier rubyid_path_parts'>path_parts</span><span class='period'>.</span><span class='id identifier rubyid_size'>size</span> <span class='op'>&gt;</span> <span class='int'>1</span>
      <span class='id identifier rubyid_error_msg'>error_msg</span> <span class='op'>+=</span> <span class='tstring'><span class='tstring_beg'>&quot;</span><span class='tstring_content'> Verify that all fields and types referenced by `</span><span class='embexpr_beg'>#{</span><span class='id identifier rubyid_public_path_string'>public_path_string</span><span class='embexpr_end'>}</span><span class='tstring_content'>` are defined.</span><span class='tstring_end'>&quot;</span></span>
    <span class='kw'>end</span>

    <span class='comment'># If the first part of the path doesn&#39;t resolve, the problem could be that the field is defined after the `index` call
</span>    <span class='comment'># but it needs to be defined before it, so mention that.
</span>    <span class='kw'>if</span> <span class='id identifier rubyid_resolver'>resolver</span><span class='period'>.</span><span class='id identifier rubyid_resolve_public_path'>resolve_public_path</span><span class='lparen'>(</span><span class='id identifier rubyid_indexed_type'>indexed_type</span><span class='comma'>,</span> <span class='id identifier rubyid_path_parts'>path_parts</span><span class='period'>.</span><span class='id identifier rubyid_first'>first</span><span class='comma'>,</span> <span class='op'>&amp;</span><span class='id identifier rubyid_parent_is_not_list'>parent_is_not_list</span><span class='rparen'>)</span><span class='period'>.</span><span class='id identifier rubyid_nil?'>nil?</span>
      <span class='id identifier rubyid_error_msg'>error_msg</span> <span class='op'>+=</span> <span class='tstring'><span class='tstring_beg'>&quot;</span><span class='tstring_content'> Note: the `</span><span class='embexpr_beg'>#{</span><span class='id identifier rubyid_indexed_type'>indexed_type</span><span class='period'>.</span><span class='id identifier rubyid_name'>name</span><span class='embexpr_end'>}</span><span class='tstring_content'>.</span><span class='embexpr_beg'>#{</span><span class='id identifier rubyid_path_parts'>path_parts</span><span class='period'>.</span><span class='id identifier rubyid_first'>first</span><span class='embexpr_end'>}</span><span class='tstring_content'>` definition must come before the `index` call.</span><span class='tstring_end'>&quot;</span></span>
    <span class='kw'>end</span>

    <span class='id identifier rubyid_raise'>raise</span> <span class='const'>Errors</span><span class='op'>::</span><span class='const'>SchemaError</span><span class='comma'>,</span> <span class='id identifier rubyid_error_msg'>error_msg</span>
  <span class='kw'>end</span>

  <span class='kw'>def</span> <span class='id identifier rubyid_date_and_datetime_types'>date_and_datetime_types</span>
    <span class='ivar'>@date_and_datetime_types</span> <span class='op'>||=</span> <span class='qwords_beg'>%w[</span><span class='tstring_content'>Date</span><span class='words_sep'> </span><span class='tstring_content'>DateTime</span><span class='tstring_end'>]</span></span><span class='period'>.</span><span class='id identifier rubyid_map'>map</span> <span class='kw'>do</span> <span class='op'>|</span><span class='id identifier rubyid_type'>type</span><span class='op'>|</span>
      <span class='id identifier rubyid_schema_def_state'>schema_def_state</span><span class='period'>.</span><span class='id identifier rubyid_type_namer'>type_namer</span><span class='period'>.</span><span class='id identifier rubyid_name_for'>name_for</span><span class='lparen'>(</span><span class='id identifier rubyid_type'>type</span><span class='rparen'>)</span>
    <span class='kw'>end</span>
  <span class='kw'>end</span>
<span class='kw'>end</span></pre>
    </td>
  </tr>
</table>
</div>
    
      
      <span id=""></span>
      <div class="method_details ">
  <h3 class="signature " id="routing_field_path-instance_method">
  
    #<strong>routing_field_path</strong>  &#x21d2; <tt>Array&lt;String&gt;</tt>  <span class="extras">(readonly)</span>
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    <p>Returns path to the field used for shard routing.</p>


  </div>
</div>
<div class="tags">
  
<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt>Array&lt;String&gt;</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>path to the field used for shard routing</p>
</div>
      
    </li>
  
</ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
55
56
57
58
59
60
61
62
63
64
65
66
67
68
69
70
71
72
73
74
75
76
77
78
79
80
81
82
83
84
85
86
87
88
89
90
91
92
93
94
95
96
97
98
99
100
101
102
103
104
105
106
107
108
109
110
111
112
113
114
115
116
117
118
119
120
121
122
123
124
125
126
127
128
129
130
131
132
133
134
135
136
137
138
139
140
141
142
143
144
145
146
147
148
149
150
151
152
153
154
155
156
157
158
159
160
161
162
163
164
165
166
167
168
169
170
171
172
173
174
175
176
177
178
179
180
181
182
183
184
185
186
187
188
189
190
191
192
193
194
195
196
197
198
199
200
201
202
203
204
205
206
207
208
209
210
211
212
213
214
215
216
217
218
219
220
221
222
223
224
225
226
227
228
229
230
231
232
233
234
235
236
237
238
239
240
241
242
243
244
245
246
247
248
249
250
251
252
253
254
255
256
257
258
259
260
261
262
263
264
265
266
267
268
269
270
271
272
273
274
275
276
277
278
279
280
281
282
283
284
285
286
287
288
289
290
291
292
293
294
295
296
297
298
299
300
301
302
303
304
305
306
307
308
309
310
311
312
313
314
315</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'elasticgraph-schema_definition/lib/elastic_graph/schema_definition/indexing/index.rb', line 39</span>

<span class='kw'>class</span> <span class='const'><span class='object_link'><a href="" title="ElasticGraph::SchemaDefinition::Indexing::Index (class)">Index</a></span></span> <span class='op'>&lt;</span> <span class='const'>Struct</span><span class='period'>.</span><span class='id identifier rubyid_new'>new</span><span class='lparen'>(</span><span class='symbol'>:name</span><span class='comma'>,</span> <span class='symbol'>:default_sort_pairs</span><span class='comma'>,</span> <span class='symbol'>:settings</span><span class='comma'>,</span> <span class='symbol'>:schema_def_state</span><span class='comma'>,</span> <span class='symbol'>:indexed_type</span><span class='comma'>,</span> <span class='symbol'>:routing_field_path</span><span class='comma'>,</span> <span class='symbol'>:rollover_config</span><span class='rparen'>)</span>
  <span class='id identifier rubyid_include'>include</span> <span class='const'><span class='object_link'><a href="../Mixins.html" title="ElasticGraph::SchemaDefinition::Mixins (module)">Mixins</a></span></span><span class='op'>::</span><span class='const'>HasReadableToSAndInspect</span><span class='period'>.</span><span class='id identifier rubyid_new'>new</span> <span class='lbrace'>{</span> <span class='op'>|</span><span class='id identifier rubyid_i'>i</span><span class='op'>|</span> <span class='id identifier rubyid_i'>i</span><span class='period'>.</span><span class='id identifier rubyid_name'>name</span> <span class='rbrace'>}</span>

  <span class='comment'># @param name [String] name of the index
</span>  <span class='comment'># @param settings [Hash&lt;(String, Object)&gt;] datastore settings for the index
</span>  <span class='comment'># @param schema_def_state [State] schema definition state
</span>  <span class='comment'># @param indexed_type [SchemaElements::ObjectType, SchemaElements::InterfaceType, SchemaElements::UnionType] type backed by this index
</span>  <span class='comment'># @yield [Index] the index, for further customization
</span>  <span class='comment'># @api private
</span>  <span class='kw'>def</span> <span class='id identifier rubyid_initialize'>initialize</span><span class='lparen'>(</span><span class='id identifier rubyid_name'>name</span><span class='comma'>,</span> <span class='id identifier rubyid_settings'>settings</span><span class='comma'>,</span> <span class='id identifier rubyid_schema_def_state'>schema_def_state</span><span class='comma'>,</span> <span class='id identifier rubyid_indexed_type'>indexed_type</span><span class='rparen'>)</span>
    <span class='kw'>if</span> <span class='id identifier rubyid_name'>name</span><span class='period'>.</span><span class='id identifier rubyid_include?'>include?</span><span class='lparen'>(</span><span class='const'>ROLLOVER_INDEX_INFIX_MARKER</span><span class='rparen'>)</span>
      <span class='id identifier rubyid_raise'>raise</span> <span class='const'>Errors</span><span class='op'>::</span><span class='const'>SchemaError</span><span class='comma'>,</span> <span class='tstring'><span class='tstring_beg'>&quot;</span><span class='tstring_content'>`</span><span class='embexpr_beg'>#{</span><span class='id identifier rubyid_name'>name</span><span class='embexpr_end'>}</span><span class='tstring_content'>` is an invalid index definition name since it contains </span><span class='tstring_end'>&quot;</span></span> \
        <span class='tstring'><span class='tstring_beg'>&quot;</span><span class='tstring_content'>`</span><span class='embexpr_beg'>#{</span><span class='const'>ROLLOVER_INDEX_INFIX_MARKER</span><span class='embexpr_end'>}</span><span class='tstring_content'>` which ElasticGraph treats as special.</span><span class='tstring_end'>&quot;</span></span>
    <span class='kw'>end</span>

    <span class='id identifier rubyid_settings'>settings</span> <span class='op'>=</span> <span class='const'>DEFAULT_SETTINGS</span><span class='period'>.</span><span class='id identifier rubyid_merge'>merge</span><span class='lparen'>(</span><span class='const'><span class='object_link'><a href="../../Support.html" title="ElasticGraph::Support (module)">Support</a></span></span><span class='op'>::</span><span class='const'>HashUtil</span><span class='period'>.</span><span class='id identifier rubyid_flatten_and_stringify_keys'>flatten_and_stringify_keys</span><span class='lparen'>(</span><span class='id identifier rubyid_settings'>settings</span><span class='comma'>,</span> <span class='label'>prefix:</span> <span class='tstring'><span class='tstring_beg'>&quot;</span><span class='tstring_content'>index</span><span class='tstring_end'>&quot;</span></span><span class='rparen'>)</span><span class='rparen'>)</span>

    <span class='kw'>super</span><span class='lparen'>(</span><span class='id identifier rubyid_name'>name</span><span class='comma'>,</span> <span class='lbracket'>[</span><span class='rbracket'>]</span><span class='comma'>,</span> <span class='id identifier rubyid_settings'>settings</span><span class='comma'>,</span> <span class='id identifier rubyid_schema_def_state'>schema_def_state</span><span class='comma'>,</span> <span class='id identifier rubyid_indexed_type'>indexed_type</span><span class='comma'>,</span> <span class='lbracket'>[</span><span class='rbracket'>]</span><span class='comma'>,</span> <span class='kw'>nil</span><span class='rparen'>)</span>

    <span class='comment'># `id` is the field Elasticsearch/OpenSearch use for routing by default:
</span>    <span class='comment'># https://www.elastic.co/guide/en/elasticsearch/reference/current/mapping-routing-field.html
</span>    <span class='comment'># By using it here, it will cause queries to pass a `routing` parameter when
</span>    <span class='comment'># searching with id filtering on an index that does not use custom shard routing, giving
</span>    <span class='comment'># us a nice efficiency boost.
</span>    <span class='kw'>self</span><span class='period'>.</span><span class='id identifier rubyid_routing_field_path'>routing_field_path</span> <span class='op'>=</span> <span class='id identifier rubyid_public_field_path'>public_field_path</span><span class='lparen'>(</span><span class='tstring'><span class='tstring_beg'>&quot;</span><span class='tstring_content'>id</span><span class='tstring_end'>&quot;</span></span><span class='comma'>,</span> <span class='label'>explanation:</span> <span class='tstring'><span class='tstring_beg'>&quot;</span><span class='tstring_content'>indexed types must have an `id` field</span><span class='tstring_end'>&quot;</span></span><span class='rparen'>)</span>

    <span class='kw'>yield</span> <span class='kw'>self</span> <span class='kw'>if</span> <span class='id identifier rubyid_block_given?'>block_given?</span>
  <span class='kw'>end</span>

  <span class='comment'># Specifies how documents in this index should sort by default, when no `orderBy` argument is provided to the GraphQL query.
</span>  <span class='comment'>#
</span>  <span class='comment'># @note the field name strings can be a dot-separated nested fields, but all referenced
</span>  <span class='comment'>#   fields must exist when this is called.
</span>  <span class='comment'>#
</span>  <span class='comment'># @param field_name_direction_pairs [Array&lt;(String, Symbol)&gt;] pairs of field names and `:asc` or `:desc`
</span>  <span class='comment'># @return [void]
</span>  <span class='comment'>#
</span>  <span class='comment'># @example Sort on `name` (ascending) with `createdAt` (descending) as a tie-breaker
</span>  <span class='comment'>#   ElasticGraph.define_schema do |schema|
</span>  <span class='comment'>#     schema.object_type &quot;Campaign&quot; do |t|
</span>  <span class='comment'>#       t.field &quot;id&quot;, &quot;ID!&quot;
</span>  <span class='comment'>#       t.field &quot;name&quot;, &quot;String&quot;
</span>  <span class='comment'>#       t.field &quot;createdAt&quot;, &quot;DateTime&quot;
</span>  <span class='comment'>#
</span>  <span class='comment'>#       t.index &quot;campaigns&quot;do |i|
</span>  <span class='comment'>#         i.default_sort &quot;name&quot;, :asc, &quot;createdAt&quot;, :desc
</span>  <span class='comment'>#       end
</span>  <span class='comment'>#     end
</span>  <span class='comment'>#   end
</span>  <span class='kw'>def</span> <span class='id identifier rubyid_default_sort'>default_sort</span><span class='lparen'>(</span><span class='op'>*</span><span class='id identifier rubyid_field_name_direction_pairs'>field_name_direction_pairs</span><span class='rparen'>)</span>
    <span class='kw'>self</span><span class='period'>.</span><span class='id identifier rubyid_default_sort_pairs'>default_sort_pairs</span> <span class='op'>=</span> <span class='id identifier rubyid_field_name_direction_pairs'>field_name_direction_pairs</span>
  <span class='kw'>end</span>

  <span class='comment'># Causes this index to &quot;rollover&quot; at the provided `frequency` based on the value of the provided `timestamp_field_path_name`.
</span>  <span class='comment'># This is particularly useful for time-series data. Partitioning the data into `hourly`, `daily`, `monthly` or `yearly` buckets
</span>  <span class='comment'># allows for different index configurations, and can be necessary when a dataset is too large to fit in one dataset given
</span>  <span class='comment'># Elasticsearch/OpenSearch limitations on the number of shards in one index. In addition, ElasticGraph optimizes queries which
</span>  <span class='comment'># filter on the timestamp field to target the subset of the indices in which matching documents could reside.
</span>  <span class='comment'>#
</span>  <span class='comment'># @note the timestamp field specified here **must be immutable**. To understand why, consider a `:yearly` rollover
</span>  <span class='comment'>#   index used for data based on `createdAt`; if ElasticGraph ingests record `123` with a createdAt of `2023-12-31T23:59:59Z`, it
</span>  <span class='comment'>#   will be indexed in the `2023` index. Later if it receives an update event for record `123` with a `createdAt` of
</span>  <span class='comment'>#   `2024-01-01T00:00:00Z` (a mere one second later!), ElasticGraph will store the new version of the payment in the `2024` index,
</span>  <span class='comment'>#   and leave the old copy of the payment in the `2023` index unchanged. It’ll have duplicates for that document.
</span>  <span class='comment'># @note changing the `rollover` configuration on an existing index that already has data will result in duplicate documents
</span>  <span class='comment'>#
</span>  <span class='comment'># @param frequency [:yearly, :monthly, :daily, :hourly] how often to rollover the index
</span>  <span class='comment'># @param timestamp_field_path_name [String] dot-separated path to the timestamp field used for rollover. Note: all referenced
</span>  <span class='comment'>#   fields must exist when this is called.
</span>  <span class='comment'># @return [void]
</span>  <span class='comment'>#
</span>  <span class='comment'># @example Define a `campaigns` index to rollover yearly based on `createdAt`
</span>  <span class='comment'>#   ElasticGraph.define_schema do |schema|
</span>  <span class='comment'>#     schema.object_type &quot;Campaign&quot; do |t|
</span>  <span class='comment'>#       t.field &quot;id&quot;, &quot;ID!&quot;
</span>  <span class='comment'>#       t.field &quot;name&quot;, &quot;String&quot;
</span>  <span class='comment'>#       t.field &quot;createdAt&quot;, &quot;DateTime&quot;
</span>  <span class='comment'>#
</span>  <span class='comment'>#       t.index &quot;campaigns&quot;do |i|
</span>  <span class='comment'>#         i.rollover :yearly, &quot;createdAt&quot;
</span>  <span class='comment'>#       end
</span>  <span class='comment'>#     end
</span>  <span class='comment'>#   end
</span>  <span class='kw'>def</span> <span class='id identifier rubyid_rollover'>rollover</span><span class='lparen'>(</span><span class='id identifier rubyid_frequency'>frequency</span><span class='comma'>,</span> <span class='id identifier rubyid_timestamp_field_path_name'>timestamp_field_path_name</span><span class='rparen'>)</span>
    <span class='id identifier rubyid_timestamp_field_path'>timestamp_field_path</span> <span class='op'>=</span> <span class='id identifier rubyid_public_field_path'>public_field_path</span><span class='lparen'>(</span><span class='id identifier rubyid_timestamp_field_path_name'>timestamp_field_path_name</span><span class='comma'>,</span> <span class='label'>explanation:</span> <span class='tstring'><span class='tstring_beg'>&quot;</span><span class='tstring_content'>it is referenced as an index `rollover` field</span><span class='tstring_end'>&quot;</span></span><span class='rparen'>)</span>

    <span class='kw'>unless</span> <span class='id identifier rubyid_date_and_datetime_types'>date_and_datetime_types</span><span class='period'>.</span><span class='id identifier rubyid_include?'>include?</span><span class='lparen'>(</span><span class='id identifier rubyid_timestamp_field_path'>timestamp_field_path</span><span class='period'>.</span><span class='id identifier rubyid_type'>type</span><span class='period'>.</span><span class='id identifier rubyid_fully_unwrapped'>fully_unwrapped</span><span class='period'>.</span><span class='id identifier rubyid_name'>name</span><span class='rparen'>)</span>
      <span class='id identifier rubyid_date_or_datetime_description'>date_or_datetime_description</span> <span class='op'>=</span> <span class='id identifier rubyid_date_and_datetime_types'>date_and_datetime_types</span><span class='period'>.</span><span class='id identifier rubyid_map'>map</span> <span class='lbrace'>{</span> <span class='op'>|</span><span class='id identifier rubyid_t'>t</span><span class='op'>|</span> <span class='tstring'><span class='tstring_beg'>&quot;</span><span class='tstring_content'>`</span><span class='embexpr_beg'>#{</span><span class='id identifier rubyid_t'>t</span><span class='embexpr_end'>}</span><span class='tstring_content'>`</span><span class='tstring_end'>&quot;</span></span> <span class='rbrace'>}</span><span class='period'>.</span><span class='id identifier rubyid_join'>join</span><span class='lparen'>(</span><span class='tstring'><span class='tstring_beg'>&quot;</span><span class='tstring_content'> or </span><span class='tstring_end'>&quot;</span></span><span class='rparen'>)</span>
      <span class='id identifier rubyid_raise'>raise</span> <span class='const'>Errors</span><span class='op'>::</span><span class='const'>SchemaError</span><span class='comma'>,</span> <span class='tstring'><span class='tstring_beg'>&quot;</span><span class='tstring_content'>rollover field `</span><span class='embexpr_beg'>#{</span><span class='id identifier rubyid_timestamp_field_path'>timestamp_field_path</span><span class='period'>.</span><span class='id identifier rubyid_full_description'>full_description</span><span class='embexpr_end'>}</span><span class='tstring_content'>` cannot be used for rollover since it is not a </span><span class='embexpr_beg'>#{</span><span class='id identifier rubyid_date_or_datetime_description'>date_or_datetime_description</span><span class='embexpr_end'>}</span><span class='tstring_content'> field.</span><span class='tstring_end'>&quot;</span></span>
    <span class='kw'>end</span>

    <span class='kw'>if</span> <span class='id identifier rubyid_timestamp_field_path'>timestamp_field_path</span><span class='period'>.</span><span class='id identifier rubyid_type'>type</span><span class='period'>.</span><span class='id identifier rubyid_list?'>list?</span>
      <span class='id identifier rubyid_raise'>raise</span> <span class='const'>Errors</span><span class='op'>::</span><span class='const'>SchemaError</span><span class='comma'>,</span> <span class='tstring'><span class='tstring_beg'>&quot;</span><span class='tstring_content'>rollover field `</span><span class='embexpr_beg'>#{</span><span class='id identifier rubyid_timestamp_field_path'>timestamp_field_path</span><span class='period'>.</span><span class='id identifier rubyid_full_description'>full_description</span><span class='embexpr_end'>}</span><span class='tstring_content'>` cannot be used for rollover since it is a list field.</span><span class='tstring_end'>&quot;</span></span>
    <span class='kw'>end</span>

    <span class='id identifier rubyid_timestamp_field_path'>timestamp_field_path</span><span class='period'>.</span><span class='id identifier rubyid_path_parts'>path_parts</span><span class='period'>.</span><span class='id identifier rubyid_each'>each</span> <span class='lbrace'>{</span> <span class='op'>|</span><span class='id identifier rubyid_f'>f</span><span class='op'>|</span> <span class='id identifier rubyid_f'>f</span><span class='period'>.</span><span class='id identifier rubyid_json_schema'>json_schema</span> <span class='label'>nullable:</span> <span class='kw'>false</span> <span class='rbrace'>}</span>

    <span class='kw'>self</span><span class='period'>.</span><span class='id identifier rubyid_rollover_config'>rollover_config</span> <span class='op'>=</span> <span class='const'>RolloverConfig</span><span class='period'>.</span><span class='id identifier rubyid_new'>new</span><span class='lparen'>(</span>
      <span class='label'>frequency:</span> <span class='id identifier rubyid_frequency'>frequency</span><span class='comma'>,</span>
      <span class='label'>timestamp_field_path:</span> <span class='id identifier rubyid_timestamp_field_path'>timestamp_field_path</span>
    <span class='rparen'>)</span>
  <span class='kw'>end</span>

  <span class='comment'># Configures the index to [route documents to shards](https://www.elastic.co/guide/en/elasticsearch/reference/8.15/mapping-routing-field.html)
</span>  <span class='comment'># based on the specified field. ElasticGraph optimizes queries that filter on the shard routing field so that they only run on a
</span>  <span class='comment'># subset of nodes instead of all nodes. This can make a big difference in query performance if queries usually filter on a certain
</span>  <span class='comment'># field. Using an appropriate field for shard routing is often essential for horizontal scaling, as it avoids having every query
</span>  <span class='comment'># hit every node, allowing additional nodes to increase query throughput.
</span>  <span class='comment'>#
</span>  <span class='comment'># @note it is essential that the shards are well-balanced. If the data’s distribution is lopsided, using this feature can make
</span>  <span class='comment'>#   performance worse.
</span>  <span class='comment'># @note the routing field specified here **must be immutable**. If ElasticGraph receives an updated version of a document with a
</span>  <span class='comment'>#   different routing value, it’ll write the new version of the document to a different shard and leave the copy on the old shard
</span>  <span class='comment'>#   unchanged, leading to duplicates.
</span>  <span class='comment'># @note changing the shard routing configuration on an existing index that already has data will result in duplicate documents
</span>  <span class='comment'>#
</span>  <span class='comment'># @param routing_field_path_name [String] dot-separated path to the field used for shard routing. Note: all referenced
</span>  <span class='comment'>#   fields must exist when this is called.
</span>  <span class='comment'># @return [void]
</span>  <span class='comment'>#
</span>  <span class='comment'># @example Define a `campaigns` index to shard on `organizationId`
</span>  <span class='comment'>#   ElasticGraph.define_schema do |schema|
</span>  <span class='comment'>#     schema.object_type &quot;Campaign&quot; do |t|
</span>  <span class='comment'>#       t.field &quot;id&quot;, &quot;ID!&quot;
</span>  <span class='comment'>#       t.field &quot;name&quot;, &quot;String&quot;
</span>  <span class='comment'>#       t.field &quot;organizationId&quot;, &quot;ID&quot;
</span>  <span class='comment'>#
</span>  <span class='comment'>#       t.index &quot;campaigns&quot;do |i|
</span>  <span class='comment'>#         i.route_with &quot;organizationId&quot;
</span>  <span class='comment'>#       end
</span>  <span class='comment'>#     end
</span>  <span class='comment'>#   end
</span>  <span class='kw'>def</span> <span class='id identifier rubyid_route_with'>route_with</span><span class='lparen'>(</span><span class='id identifier rubyid_routing_field_path_name'>routing_field_path_name</span><span class='rparen'>)</span>
    <span class='id identifier rubyid_routing_field_path'>routing_field_path</span> <span class='op'>=</span> <span class='id identifier rubyid_public_field_path'>public_field_path</span><span class='lparen'>(</span><span class='id identifier rubyid_routing_field_path_name'>routing_field_path_name</span><span class='comma'>,</span> <span class='label'>explanation:</span> <span class='tstring'><span class='tstring_beg'>&quot;</span><span class='tstring_content'>it is referenced as an index `route_with` field</span><span class='tstring_end'>&quot;</span></span><span class='rparen'>)</span>

    <span class='kw'>unless</span> <span class='id identifier rubyid_routing_field_path'>routing_field_path</span><span class='period'>.</span><span class='id identifier rubyid_type'>type</span><span class='period'>.</span><span class='id identifier rubyid_leaf?'>leaf?</span>
      <span class='id identifier rubyid_raise'>raise</span> <span class='const'>Errors</span><span class='op'>::</span><span class='const'>SchemaError</span><span class='comma'>,</span> <span class='tstring'><span class='tstring_beg'>&quot;</span><span class='tstring_content'>shard routing field `</span><span class='embexpr_beg'>#{</span><span class='id identifier rubyid_routing_field_path'>routing_field_path</span><span class='period'>.</span><span class='id identifier rubyid_full_description'>full_description</span><span class='embexpr_end'>}</span><span class='tstring_content'>` cannot be used for routing since it is not a leaf field.</span><span class='tstring_end'>&quot;</span></span>
    <span class='kw'>end</span>

    <span class='kw'>self</span><span class='period'>.</span><span class='id identifier rubyid_routing_field_path'>routing_field_path</span> <span class='op'>=</span> <span class='id identifier rubyid_routing_field_path'>routing_field_path</span>

    <span class='id identifier rubyid_routing_field_path'>routing_field_path</span><span class='period'>.</span><span class='id identifier rubyid_path_parts'>path_parts</span><span class='lbracket'>[</span><span class='int'>0</span><span class='op'>..</span><span class='op'>-</span><span class='int'>2</span><span class='rbracket'>]</span><span class='period'>.</span><span class='id identifier rubyid_each'>each</span> <span class='lbrace'>{</span> <span class='op'>|</span><span class='id identifier rubyid_f'>f</span><span class='op'>|</span> <span class='id identifier rubyid_f'>f</span><span class='period'>.</span><span class='id identifier rubyid_json_schema'>json_schema</span> <span class='label'>nullable:</span> <span class='kw'>false</span> <span class='rbrace'>}</span>
    <span class='id identifier rubyid_routing_field_path'>routing_field_path</span><span class='period'>.</span><span class='id identifier rubyid_last_part'>last_part</span><span class='period'>.</span><span class='id identifier rubyid_json_schema'>json_schema</span> <span class='label'>nullable:</span> <span class='kw'>false</span><span class='comma'>,</span> <span class='label'>pattern:</span> <span class='const'>HAS_NON_WHITE_SPACE_REGEX</span>
    <span class='id identifier rubyid_indexed_type'>indexed_type</span><span class='period'>.</span><span class='id identifier rubyid_append_to_documentation'>append_to_documentation</span> <span class='tstring'><span class='tstring_beg'>&quot;</span><span class='tstring_content'>For more performant queries on this type, please filter on `</span><span class='embexpr_beg'>#{</span><span class='id identifier rubyid_routing_field_path_name'>routing_field_path_name</span><span class='embexpr_end'>}</span><span class='tstring_content'>` if possible.</span><span class='tstring_end'>&quot;</span></span>
  <span class='kw'>end</span>

  <span class='comment'># @see #route_with
</span>  <span class='comment'># @return [Boolean] whether or not this index uses custom shard routing
</span>  <span class='kw'>def</span> <span class='id identifier rubyid_uses_custom_routing?'>uses_custom_routing?</span>
    <span class='id identifier rubyid_routing_field_path'>routing_field_path</span><span class='period'>.</span><span class='id identifier rubyid_path_in_index'>path_in_index</span> <span class='op'>!=</span> <span class='tstring'><span class='tstring_beg'>&quot;</span><span class='tstring_content'>id</span><span class='tstring_end'>&quot;</span></span>
  <span class='kw'>end</span>

  <span class='comment'># @return [Hash&lt;String, Object&gt;] datastore configuration for this index for when it does not use rollover
</span>  <span class='kw'>def</span> <span class='id identifier rubyid_to_index_config'>to_index_config</span>
    <span class='lbrace'>{</span>
      <span class='tstring'><span class='tstring_beg'>&quot;</span><span class='tstring_content'>aliases</span><span class='tstring_end'>&quot;</span></span> <span class='op'>=&gt;</span> <span class='lbrace'>{</span><span class='rbrace'>}</span><span class='comma'>,</span>
      <span class='tstring'><span class='tstring_beg'>&quot;</span><span class='tstring_content'>mappings</span><span class='tstring_end'>&quot;</span></span> <span class='op'>=&gt;</span> <span class='id identifier rubyid_mappings'>mappings</span><span class='comma'>,</span>
      <span class='tstring'><span class='tstring_beg'>&quot;</span><span class='tstring_content'>settings</span><span class='tstring_end'>&quot;</span></span> <span class='op'>=&gt;</span> <span class='id identifier rubyid_settings'>settings</span>
    <span class='rbrace'>}</span><span class='period'>.</span><span class='id identifier rubyid_compact'>compact</span>
  <span class='kw'>end</span>

  <span class='comment'># @return [Hash&lt;String, Object&gt;] datastore configuration for the index template that will be defined if rollover is used
</span>  <span class='kw'>def</span> <span class='id identifier rubyid_to_index_template_config'>to_index_template_config</span>
    <span class='lbrace'>{</span>
      <span class='tstring'><span class='tstring_beg'>&quot;</span><span class='tstring_content'>index_patterns</span><span class='tstring_end'>&quot;</span></span> <span class='op'>=&gt;</span> <span class='lbracket'>[</span><span class='tstring'><span class='tstring_beg'>&quot;</span><span class='embexpr_beg'>#{</span><span class='id identifier rubyid_name'>name</span><span class='embexpr_end'>}</span><span class='embexpr_beg'>#{</span><span class='const'>ROLLOVER_INDEX_INFIX_MARKER</span><span class='embexpr_end'>}</span><span class='tstring_content'>*</span><span class='tstring_end'>&quot;</span></span><span class='rbracket'>]</span><span class='comma'>,</span>
      <span class='tstring'><span class='tstring_beg'>&quot;</span><span class='tstring_content'>template</span><span class='tstring_end'>&quot;</span></span> <span class='op'>=&gt;</span> <span class='lbrace'>{</span>
        <span class='tstring'><span class='tstring_beg'>&quot;</span><span class='tstring_content'>aliases</span><span class='tstring_end'>&quot;</span></span> <span class='op'>=&gt;</span> <span class='lbrace'>{</span><span class='rbrace'>}</span><span class='comma'>,</span>
        <span class='tstring'><span class='tstring_beg'>&quot;</span><span class='tstring_content'>mappings</span><span class='tstring_end'>&quot;</span></span> <span class='op'>=&gt;</span> <span class='id identifier rubyid_mappings'>mappings</span><span class='comma'>,</span>
        <span class='tstring'><span class='tstring_beg'>&quot;</span><span class='tstring_content'>settings</span><span class='tstring_end'>&quot;</span></span> <span class='op'>=&gt;</span> <span class='id identifier rubyid_settings'>settings</span>
      <span class='rbrace'>}</span>
    <span class='rbrace'>}</span>
  <span class='kw'>end</span>

  <span class='comment'># @return [SchemaArtifacts::RuntimeMetadata::IndexDefinition] runtime metadata for this index
</span>  <span class='kw'>def</span> <span class='id identifier rubyid_runtime_metadata'>runtime_metadata</span>
    <span class='const'>SchemaArtifacts</span><span class='op'>::</span><span class='const'>RuntimeMetadata</span><span class='op'>::</span><span class='const'>IndexDefinition</span><span class='period'>.</span><span class='id identifier rubyid_new'>new</span><span class='lparen'>(</span>
      <span class='label'>route_with:</span> <span class='id identifier rubyid_routing_field_path'>routing_field_path</span><span class='period'>.</span><span class='id identifier rubyid_path_in_index'>path_in_index</span><span class='comma'>,</span>
      <span class='label'>rollover:</span> <span class='id identifier rubyid_rollover_config'>rollover_config</span><span class='op'>&amp;.</span><span class='id identifier rubyid_runtime_metadata'>runtime_metadata</span><span class='comma'>,</span>
      <span class='label'>current_sources:</span> <span class='id identifier rubyid_indexed_type'>indexed_type</span><span class='period'>.</span><span class='id identifier rubyid_current_sources'>current_sources</span><span class='comma'>,</span>
      <span class='label'>fields_by_path:</span> <span class='id identifier rubyid_indexed_type'>indexed_type</span><span class='period'>.</span><span class='id identifier rubyid_index_field_runtime_metadata_tuples'>index_field_runtime_metadata_tuples</span><span class='period'>.</span><span class='id identifier rubyid_to_h'>to_h</span><span class='comma'>,</span>
      <span class='label'>default_sort_fields:</span> <span class='id identifier rubyid_default_sort_pairs'>default_sort_pairs</span><span class='period'>.</span><span class='id identifier rubyid_each_slice'>each_slice</span><span class='lparen'>(</span><span class='int'>2</span><span class='rparen'>)</span><span class='period'>.</span><span class='id identifier rubyid_map'>map</span> <span class='kw'>do</span> <span class='op'>|</span><span class='lparen'>(</span><span class='id identifier rubyid_graphql_field_path_name'>graphql_field_path_name</span><span class='comma'>,</span> <span class='id identifier rubyid_direction'>direction</span><span class='rparen'>)</span><span class='op'>|</span>
        <span class='const'>SchemaArtifacts</span><span class='op'>::</span><span class='const'>RuntimeMetadata</span><span class='op'>::</span><span class='const'>SortField</span><span class='period'>.</span><span class='id identifier rubyid_new'>new</span><span class='lparen'>(</span>
          <span class='label'>field_path:</span> <span class='id identifier rubyid_public_field_path'>public_field_path</span><span class='lparen'>(</span><span class='id identifier rubyid_graphql_field_path_name'>graphql_field_path_name</span><span class='comma'>,</span> <span class='label'>explanation:</span> <span class='tstring'><span class='tstring_beg'>&quot;</span><span class='tstring_content'>it is referenced as an index `default_sort` field</span><span class='tstring_end'>&quot;</span></span><span class='rparen'>)</span><span class='period'>.</span><span class='id identifier rubyid_path_in_index'>path_in_index</span><span class='comma'>,</span>
          <span class='label'>direction:</span> <span class='id identifier rubyid_direction'>direction</span>
        <span class='rparen'>)</span>
      <span class='kw'>end</span>
    <span class='rparen'>)</span>
  <span class='kw'>end</span>

  <span class='id identifier rubyid_private'>private</span>

  <span class='comment'># A regex that requires at least one non-whitespace character.
</span>  <span class='comment'># Note: this does not use the `/S` character class because it&#39;s recommended to use a small subset
</span>  <span class='comment'># of Regex syntax:
</span>  <span class='comment'>#
</span>  <span class='comment'># &gt; The regular expression syntax used is from JavaScript (ECMA 262, specifically). However, that
</span>  <span class='comment'># &gt; complete syntax is not widely supported, therefore it is recommended that you stick to the subset
</span>  <span class='comment'># &gt; of that syntax described below.
</span>  <span class='comment'>#
</span>  <span class='comment'># (From https://json-schema.org/understanding-json-schema/reference/regular_expressions.html)
</span>  <span class='const'>HAS_NON_WHITE_SPACE_REGEX</span> <span class='op'>=</span> <span class='tstring'><span class='tstring_beg'>&quot;</span><span class='tstring_content'>[^ \t\n]+</span><span class='tstring_end'>&quot;</span></span>

  <span class='const'>DEFAULT_SETTINGS</span> <span class='op'>=</span> <span class='lbrace'>{</span>
    <span class='tstring'><span class='tstring_beg'>&quot;</span><span class='tstring_content'>index.mapping.ignore_malformed</span><span class='tstring_end'>&quot;</span></span> <span class='op'>=&gt;</span> <span class='kw'>false</span><span class='comma'>,</span>
    <span class='tstring'><span class='tstring_beg'>&quot;</span><span class='tstring_content'>index.mapping.coerce</span><span class='tstring_end'>&quot;</span></span> <span class='op'>=&gt;</span> <span class='kw'>false</span><span class='comma'>,</span>
    <span class='tstring'><span class='tstring_beg'>&quot;</span><span class='tstring_content'>index.number_of_replicas</span><span class='tstring_end'>&quot;</span></span> <span class='op'>=&gt;</span> <span class='int'>1</span><span class='comma'>,</span>
    <span class='tstring'><span class='tstring_beg'>&quot;</span><span class='tstring_content'>index.number_of_shards</span><span class='tstring_end'>&quot;</span></span> <span class='op'>=&gt;</span> <span class='int'>1</span>
  <span class='rbrace'>}</span>

  <span class='kw'>def</span> <span class='id identifier rubyid_mappings'>mappings</span>
    <span class='id identifier rubyid_field_mappings'>field_mappings</span> <span class='op'>=</span> <span class='id identifier rubyid_indexed_type'>indexed_type</span>
      <span class='period'>.</span><span class='id identifier rubyid_to_indexing_field_type'>to_indexing_field_type</span>
      <span class='period'>.</span><span class='id identifier rubyid_to_mapping'>to_mapping</span>
      <span class='period'>.</span><span class='id identifier rubyid_except'>except</span><span class='lparen'>(</span><span class='tstring'><span class='tstring_beg'>&quot;</span><span class='tstring_content'>type</span><span class='tstring_end'>&quot;</span></span><span class='rparen'>)</span> <span class='comment'># `type` is invalid at the mapping root because it always has to be an object.
</span>      <span class='period'>.</span><span class='id identifier rubyid_then'>then</span> <span class='lbrace'>{</span> <span class='op'>|</span><span class='id identifier rubyid_mapping'>mapping</span><span class='op'>|</span> <span class='const'>ListCountsMapping</span><span class='period'>.</span><span class='id identifier rubyid_merged_into'>merged_into</span><span class='lparen'>(</span><span class='id identifier rubyid_mapping'>mapping</span><span class='comma'>,</span> <span class='label'>for_type:</span> <span class='id identifier rubyid_indexed_type'>indexed_type</span><span class='rparen'>)</span> <span class='rbrace'>}</span>
      <span class='period'>.</span><span class='id identifier rubyid_then'>then</span> <span class='kw'>do</span> <span class='op'>|</span><span class='id identifier rubyid_fm'>fm</span><span class='op'>|</span>
        <span class='const'><span class='object_link'><a href="../../Support.html" title="ElasticGraph::Support (module)">Support</a></span></span><span class='op'>::</span><span class='const'>HashUtil</span><span class='period'>.</span><span class='id identifier rubyid_deep_merge'>deep_merge</span><span class='lparen'>(</span><span class='id identifier rubyid_fm'>fm</span><span class='comma'>,</span> <span class='lbrace'>{</span><span class='tstring'><span class='tstring_beg'>&quot;</span><span class='tstring_content'>properties</span><span class='tstring_end'>&quot;</span></span> <span class='op'>=&gt;</span> <span class='lbrace'>{</span>
          <span class='tstring'><span class='tstring_beg'>&quot;</span><span class='tstring_content'>__sources</span><span class='tstring_end'>&quot;</span></span> <span class='op'>=&gt;</span> <span class='lbrace'>{</span><span class='tstring'><span class='tstring_beg'>&quot;</span><span class='tstring_content'>type</span><span class='tstring_end'>&quot;</span></span> <span class='op'>=&gt;</span> <span class='tstring'><span class='tstring_beg'>&quot;</span><span class='tstring_content'>keyword</span><span class='tstring_end'>&quot;</span></span><span class='rbrace'>}</span><span class='comma'>,</span>
          <span class='tstring'><span class='tstring_beg'>&quot;</span><span class='tstring_content'>__versions</span><span class='tstring_end'>&quot;</span></span> <span class='op'>=&gt;</span> <span class='lbrace'>{</span>
            <span class='tstring'><span class='tstring_beg'>&quot;</span><span class='tstring_content'>type</span><span class='tstring_end'>&quot;</span></span> <span class='op'>=&gt;</span> <span class='tstring'><span class='tstring_beg'>&quot;</span><span class='tstring_content'>object</span><span class='tstring_end'>&quot;</span></span><span class='comma'>,</span>
            <span class='comment'># __versions is map keyed by relationship name, with values that are maps keyed by id. Since it&#39;s not
</span>            <span class='comment'># a static object with known fields, we need to use dynamic here. Passing `false` allows some level
</span>            <span class='comment'># of dynamicness. As per https://www.elastic.co/guide/en/elasticsearch/reference/8.7/dynamic.html#dynamic-parameters:
</span>            <span class='comment'>#
</span>            <span class='comment'># &gt; New fields are ignored. These fields will not be indexed or searchable, but will still appear in the _source
</span>            <span class='comment'># &gt; field of returned hits. These fields will not be added to the mapping, and new fields must be added explicitly.
</span>            <span class='comment'>#
</span>            <span class='comment'># We need `__versions` to be in `_source` (so that our update scripts can operate on it), but
</span>            <span class='comment'># have no need for it to be searchable (as it&#39;s just an internal data structure used for indexing).
</span>            <span class='comment'>#
</span>            <span class='comment'># Note: we intentionally set false as a string here, because that&#39;s how the datastore echoes it back
</span>            <span class='comment'># to us when you query the mapping (even if you set it as a boolean). Our checks for index mapping
</span>            <span class='comment'># consistency fail validation if we set it as a boolean since the datastore doesn&#39;t echo it back as
</span>            <span class='comment'># a boolean.
</span>            <span class='tstring'><span class='tstring_beg'>&quot;</span><span class='tstring_content'>dynamic</span><span class='tstring_end'>&quot;</span></span> <span class='op'>=&gt;</span> <span class='tstring'><span class='tstring_beg'>&quot;</span><span class='tstring_content'>false</span><span class='tstring_end'>&quot;</span></span>
          <span class='rbrace'>}</span>
        <span class='rbrace'>}</span><span class='rbrace'>}</span><span class='rparen'>)</span>
      <span class='kw'>end</span>

    <span class='lbrace'>{</span><span class='tstring'><span class='tstring_beg'>&quot;</span><span class='tstring_content'>dynamic</span><span class='tstring_end'>&quot;</span></span> <span class='op'>=&gt;</span> <span class='tstring'><span class='tstring_beg'>&quot;</span><span class='tstring_content'>strict</span><span class='tstring_end'>&quot;</span></span><span class='rbrace'>}</span><span class='period'>.</span><span class='id identifier rubyid_merge'>merge</span><span class='lparen'>(</span><span class='id identifier rubyid_field_mappings'>field_mappings</span><span class='rparen'>)</span><span class='period'>.</span><span class='id identifier rubyid_tap'>tap</span> <span class='kw'>do</span> <span class='op'>|</span><span class='id identifier rubyid_hash'>hash</span><span class='op'>|</span>
      <span class='comment'># If we are using custom shard routing, we want to require a `routing` value to be provided
</span>      <span class='comment'># in every single index, get, delete or update request; otherwise the request might be
</span>      <span class='comment'># made against the wrong shard.
</span>      <span class='id identifier rubyid_hash'>hash</span><span class='lbracket'>[</span><span class='tstring'><span class='tstring_beg'>&quot;</span><span class='tstring_content'>_routing</span><span class='tstring_end'>&quot;</span></span><span class='rbracket'>]</span> <span class='op'>=</span> <span class='lbrace'>{</span><span class='tstring'><span class='tstring_beg'>&quot;</span><span class='tstring_content'>required</span><span class='tstring_end'>&quot;</span></span> <span class='op'>=&gt;</span> <span class='kw'>true</span><span class='rbrace'>}</span> <span class='kw'>if</span> <span class='id identifier rubyid_uses_custom_routing?'>uses_custom_routing?</span>
      <span class='id identifier rubyid_hash'>hash</span><span class='lbracket'>[</span><span class='tstring'><span class='tstring_beg'>&quot;</span><span class='tstring_content'>_size</span><span class='tstring_end'>&quot;</span></span><span class='rbracket'>]</span> <span class='op'>=</span> <span class='lbrace'>{</span><span class='tstring'><span class='tstring_beg'>&quot;</span><span class='tstring_content'>enabled</span><span class='tstring_end'>&quot;</span></span> <span class='op'>=&gt;</span> <span class='kw'>true</span><span class='rbrace'>}</span> <span class='kw'>if</span> <span class='id identifier rubyid_schema_def_state'>schema_def_state</span><span class='period'>.</span><span class='id identifier rubyid_index_document_sizes?'>index_document_sizes?</span>
    <span class='kw'>end</span>
  <span class='kw'>end</span>

  <span class='kw'>def</span> <span class='id identifier rubyid_public_field_path'>public_field_path</span><span class='lparen'>(</span><span class='id identifier rubyid_public_path_string'>public_path_string</span><span class='comma'>,</span> <span class='label'>explanation:</span><span class='rparen'>)</span>
    <span class='id identifier rubyid_parent_is_not_list'>parent_is_not_list</span> <span class='op'>=</span> <span class='tlambda'>-&gt;</span><span class='lparen'>(</span><span class='id identifier rubyid_parent_field'>parent_field</span><span class='rparen'>)</span> <span class='tlambeg'>{</span> <span class='op'>!</span><span class='id identifier rubyid_parent_field'>parent_field</span><span class='period'>.</span><span class='id identifier rubyid_type'>type</span><span class='period'>.</span><span class='id identifier rubyid_list?'>list?</span> <span class='rbrace'>}</span>
    <span class='id identifier rubyid_resolver'>resolver</span> <span class='op'>=</span> <span class='const'><span class='object_link'><a href="../SchemaElements.html" title="ElasticGraph::SchemaDefinition::SchemaElements (module)">SchemaElements</a></span></span><span class='op'>::</span><span class='const'>FieldPath</span><span class='op'>::</span><span class='const'>Resolver</span><span class='period'>.</span><span class='id identifier rubyid_new'>new</span>
    <span class='id identifier rubyid_resolved_path'>resolved_path</span> <span class='op'>=</span> <span class='id identifier rubyid_resolver'>resolver</span><span class='period'>.</span><span class='id identifier rubyid_resolve_public_path'>resolve_public_path</span><span class='lparen'>(</span><span class='id identifier rubyid_indexed_type'>indexed_type</span><span class='comma'>,</span> <span class='id identifier rubyid_public_path_string'>public_path_string</span><span class='comma'>,</span> <span class='op'>&amp;</span><span class='id identifier rubyid_parent_is_not_list'>parent_is_not_list</span><span class='rparen'>)</span>
    <span class='kw'>return</span> <span class='id identifier rubyid_resolved_path'>resolved_path</span> <span class='kw'>if</span> <span class='id identifier rubyid_resolved_path'>resolved_path</span>

    <span class='id identifier rubyid_path_parts'>path_parts</span> <span class='op'>=</span> <span class='id identifier rubyid_public_path_string'>public_path_string</span><span class='period'>.</span><span class='id identifier rubyid_split'>split</span><span class='lparen'>(</span><span class='tstring'><span class='tstring_beg'>&quot;</span><span class='tstring_content'>.</span><span class='tstring_end'>&quot;</span></span><span class='rparen'>)</span>
    <span class='id identifier rubyid_error_msg'>error_msg</span> <span class='op'>=</span> <span class='tstring'><span class='tstring_beg'>&quot;</span><span class='tstring_content'>Field `</span><span class='embexpr_beg'>#{</span><span class='id identifier rubyid_indexed_type'>indexed_type</span><span class='period'>.</span><span class='id identifier rubyid_name'>name</span><span class='embexpr_end'>}</span><span class='tstring_content'>.</span><span class='embexpr_beg'>#{</span><span class='id identifier rubyid_public_path_string'>public_path_string</span><span class='embexpr_end'>}</span><span class='tstring_content'>` cannot be resolved, but </span><span class='embexpr_beg'>#{</span><span class='id identifier rubyid_explanation'>explanation</span><span class='embexpr_end'>}</span><span class='tstring_content'>.</span><span class='tstring_end'>&quot;</span></span>

    <span class='comment'># If it is a nested field path, the problem could be that a type has been referenced which does not exist, so mention that.
</span>    <span class='kw'>if</span> <span class='id identifier rubyid_path_parts'>path_parts</span><span class='period'>.</span><span class='id identifier rubyid_size'>size</span> <span class='op'>&gt;</span> <span class='int'>1</span>
      <span class='id identifier rubyid_error_msg'>error_msg</span> <span class='op'>+=</span> <span class='tstring'><span class='tstring_beg'>&quot;</span><span class='tstring_content'> Verify that all fields and types referenced by `</span><span class='embexpr_beg'>#{</span><span class='id identifier rubyid_public_path_string'>public_path_string</span><span class='embexpr_end'>}</span><span class='tstring_content'>` are defined.</span><span class='tstring_end'>&quot;</span></span>
    <span class='kw'>end</span>

    <span class='comment'># If the first part of the path doesn&#39;t resolve, the problem could be that the field is defined after the `index` call
</span>    <span class='comment'># but it needs to be defined before it, so mention that.
</span>    <span class='kw'>if</span> <span class='id identifier rubyid_resolver'>resolver</span><span class='period'>.</span><span class='id identifier rubyid_resolve_public_path'>resolve_public_path</span><span class='lparen'>(</span><span class='id identifier rubyid_indexed_type'>indexed_type</span><span class='comma'>,</span> <span class='id identifier rubyid_path_parts'>path_parts</span><span class='period'>.</span><span class='id identifier rubyid_first'>first</span><span class='comma'>,</span> <span class='op'>&amp;</span><span class='id identifier rubyid_parent_is_not_list'>parent_is_not_list</span><span class='rparen'>)</span><span class='period'>.</span><span class='id identifier rubyid_nil?'>nil?</span>
      <span class='id identifier rubyid_error_msg'>error_msg</span> <span class='op'>+=</span> <span class='tstring'><span class='tstring_beg'>&quot;</span><span class='tstring_content'> Note: the `</span><span class='embexpr_beg'>#{</span><span class='id identifier rubyid_indexed_type'>indexed_type</span><span class='period'>.</span><span class='id identifier rubyid_name'>name</span><span class='embexpr_end'>}</span><span class='tstring_content'>.</span><span class='embexpr_beg'>#{</span><span class='id identifier rubyid_path_parts'>path_parts</span><span class='period'>.</span><span class='id identifier rubyid_first'>first</span><span class='embexpr_end'>}</span><span class='tstring_content'>` definition must come before the `index` call.</span><span class='tstring_end'>&quot;</span></span>
    <span class='kw'>end</span>

    <span class='id identifier rubyid_raise'>raise</span> <span class='const'>Errors</span><span class='op'>::</span><span class='const'>SchemaError</span><span class='comma'>,</span> <span class='id identifier rubyid_error_msg'>error_msg</span>
  <span class='kw'>end</span>

  <span class='kw'>def</span> <span class='id identifier rubyid_date_and_datetime_types'>date_and_datetime_types</span>
    <span class='ivar'>@date_and_datetime_types</span> <span class='op'>||=</span> <span class='qwords_beg'>%w[</span><span class='tstring_content'>Date</span><span class='words_sep'> </span><span class='tstring_content'>DateTime</span><span class='tstring_end'>]</span></span><span class='period'>.</span><span class='id identifier rubyid_map'>map</span> <span class='kw'>do</span> <span class='op'>|</span><span class='id identifier rubyid_type'>type</span><span class='op'>|</span>
      <span class='id identifier rubyid_schema_def_state'>schema_def_state</span><span class='period'>.</span><span class='id identifier rubyid_type_namer'>type_namer</span><span class='period'>.</span><span class='id identifier rubyid_name_for'>name_for</span><span class='lparen'>(</span><span class='id identifier rubyid_type'>type</span><span class='rparen'>)</span>
    <span class='kw'>end</span>
  <span class='kw'>end</span>
<span class='kw'>end</span></pre>
    </td>
  </tr>
</table>
</div>
    
      
      <span id=""></span>
      <div class="method_details ">
  <h3 class="signature " id="schema_def_state-instance_method">
  
    #<strong>schema_def_state</strong>  &#x21d2; <tt><span class='object_link'>State</span></tt>  <span class="extras">(readonly)</span>
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    <p>Returns schema definition state.</p>


  </div>
</div>
<div class="tags">
  
<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt><span class='object_link'>State</span></tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>schema definition state</p>
</div>
      
    </li>
  
</ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
55
56
57
58
59
60
61
62
63
64
65
66
67
68
69
70
71
72
73
74
75
76
77
78
79
80
81
82
83
84
85
86
87
88
89
90
91
92
93
94
95
96
97
98
99
100
101
102
103
104
105
106
107
108
109
110
111
112
113
114
115
116
117
118
119
120
121
122
123
124
125
126
127
128
129
130
131
132
133
134
135
136
137
138
139
140
141
142
143
144
145
146
147
148
149
150
151
152
153
154
155
156
157
158
159
160
161
162
163
164
165
166
167
168
169
170
171
172
173
174
175
176
177
178
179
180
181
182
183
184
185
186
187
188
189
190
191
192
193
194
195
196
197
198
199
200
201
202
203
204
205
206
207
208
209
210
211
212
213
214
215
216
217
218
219
220
221
222
223
224
225
226
227
228
229
230
231
232
233
234
235
236
237
238
239
240
241
242
243
244
245
246
247
248
249
250
251
252
253
254
255
256
257
258
259
260
261
262
263
264
265
266
267
268
269
270
271
272
273
274
275
276
277
278
279
280
281
282
283
284
285
286
287
288
289
290
291
292
293
294
295
296
297
298
299
300
301
302
303
304
305
306
307
308
309
310
311
312
313
314
315</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'elasticgraph-schema_definition/lib/elastic_graph/schema_definition/indexing/index.rb', line 39</span>

<span class='kw'>class</span> <span class='const'><span class='object_link'><a href="" title="ElasticGraph::SchemaDefinition::Indexing::Index (class)">Index</a></span></span> <span class='op'>&lt;</span> <span class='const'>Struct</span><span class='period'>.</span><span class='id identifier rubyid_new'>new</span><span class='lparen'>(</span><span class='symbol'>:name</span><span class='comma'>,</span> <span class='symbol'>:default_sort_pairs</span><span class='comma'>,</span> <span class='symbol'>:settings</span><span class='comma'>,</span> <span class='symbol'>:schema_def_state</span><span class='comma'>,</span> <span class='symbol'>:indexed_type</span><span class='comma'>,</span> <span class='symbol'>:routing_field_path</span><span class='comma'>,</span> <span class='symbol'>:rollover_config</span><span class='rparen'>)</span>
  <span class='id identifier rubyid_include'>include</span> <span class='const'><span class='object_link'><a href="../Mixins.html" title="ElasticGraph::SchemaDefinition::Mixins (module)">Mixins</a></span></span><span class='op'>::</span><span class='const'>HasReadableToSAndInspect</span><span class='period'>.</span><span class='id identifier rubyid_new'>new</span> <span class='lbrace'>{</span> <span class='op'>|</span><span class='id identifier rubyid_i'>i</span><span class='op'>|</span> <span class='id identifier rubyid_i'>i</span><span class='period'>.</span><span class='id identifier rubyid_name'>name</span> <span class='rbrace'>}</span>

  <span class='comment'># @param name [String] name of the index
</span>  <span class='comment'># @param settings [Hash&lt;(String, Object)&gt;] datastore settings for the index
</span>  <span class='comment'># @param schema_def_state [State] schema definition state
</span>  <span class='comment'># @param indexed_type [SchemaElements::ObjectType, SchemaElements::InterfaceType, SchemaElements::UnionType] type backed by this index
</span>  <span class='comment'># @yield [Index] the index, for further customization
</span>  <span class='comment'># @api private
</span>  <span class='kw'>def</span> <span class='id identifier rubyid_initialize'>initialize</span><span class='lparen'>(</span><span class='id identifier rubyid_name'>name</span><span class='comma'>,</span> <span class='id identifier rubyid_settings'>settings</span><span class='comma'>,</span> <span class='id identifier rubyid_schema_def_state'>schema_def_state</span><span class='comma'>,</span> <span class='id identifier rubyid_indexed_type'>indexed_type</span><span class='rparen'>)</span>
    <span class='kw'>if</span> <span class='id identifier rubyid_name'>name</span><span class='period'>.</span><span class='id identifier rubyid_include?'>include?</span><span class='lparen'>(</span><span class='const'>ROLLOVER_INDEX_INFIX_MARKER</span><span class='rparen'>)</span>
      <span class='id identifier rubyid_raise'>raise</span> <span class='const'>Errors</span><span class='op'>::</span><span class='const'>SchemaError</span><span class='comma'>,</span> <span class='tstring'><span class='tstring_beg'>&quot;</span><span class='tstring_content'>`</span><span class='embexpr_beg'>#{</span><span class='id identifier rubyid_name'>name</span><span class='embexpr_end'>}</span><span class='tstring_content'>` is an invalid index definition name since it contains </span><span class='tstring_end'>&quot;</span></span> \
        <span class='tstring'><span class='tstring_beg'>&quot;</span><span class='tstring_content'>`</span><span class='embexpr_beg'>#{</span><span class='const'>ROLLOVER_INDEX_INFIX_MARKER</span><span class='embexpr_end'>}</span><span class='tstring_content'>` which ElasticGraph treats as special.</span><span class='tstring_end'>&quot;</span></span>
    <span class='kw'>end</span>

    <span class='id identifier rubyid_settings'>settings</span> <span class='op'>=</span> <span class='const'>DEFAULT_SETTINGS</span><span class='period'>.</span><span class='id identifier rubyid_merge'>merge</span><span class='lparen'>(</span><span class='const'><span class='object_link'><a href="../../Support.html" title="ElasticGraph::Support (module)">Support</a></span></span><span class='op'>::</span><span class='const'>HashUtil</span><span class='period'>.</span><span class='id identifier rubyid_flatten_and_stringify_keys'>flatten_and_stringify_keys</span><span class='lparen'>(</span><span class='id identifier rubyid_settings'>settings</span><span class='comma'>,</span> <span class='label'>prefix:</span> <span class='tstring'><span class='tstring_beg'>&quot;</span><span class='tstring_content'>index</span><span class='tstring_end'>&quot;</span></span><span class='rparen'>)</span><span class='rparen'>)</span>

    <span class='kw'>super</span><span class='lparen'>(</span><span class='id identifier rubyid_name'>name</span><span class='comma'>,</span> <span class='lbracket'>[</span><span class='rbracket'>]</span><span class='comma'>,</span> <span class='id identifier rubyid_settings'>settings</span><span class='comma'>,</span> <span class='id identifier rubyid_schema_def_state'>schema_def_state</span><span class='comma'>,</span> <span class='id identifier rubyid_indexed_type'>indexed_type</span><span class='comma'>,</span> <span class='lbracket'>[</span><span class='rbracket'>]</span><span class='comma'>,</span> <span class='kw'>nil</span><span class='rparen'>)</span>

    <span class='comment'># `id` is the field Elasticsearch/OpenSearch use for routing by default:
</span>    <span class='comment'># https://www.elastic.co/guide/en/elasticsearch/reference/current/mapping-routing-field.html
</span>    <span class='comment'># By using it here, it will cause queries to pass a `routing` parameter when
</span>    <span class='comment'># searching with id filtering on an index that does not use custom shard routing, giving
</span>    <span class='comment'># us a nice efficiency boost.
</span>    <span class='kw'>self</span><span class='period'>.</span><span class='id identifier rubyid_routing_field_path'>routing_field_path</span> <span class='op'>=</span> <span class='id identifier rubyid_public_field_path'>public_field_path</span><span class='lparen'>(</span><span class='tstring'><span class='tstring_beg'>&quot;</span><span class='tstring_content'>id</span><span class='tstring_end'>&quot;</span></span><span class='comma'>,</span> <span class='label'>explanation:</span> <span class='tstring'><span class='tstring_beg'>&quot;</span><span class='tstring_content'>indexed types must have an `id` field</span><span class='tstring_end'>&quot;</span></span><span class='rparen'>)</span>

    <span class='kw'>yield</span> <span class='kw'>self</span> <span class='kw'>if</span> <span class='id identifier rubyid_block_given?'>block_given?</span>
  <span class='kw'>end</span>

  <span class='comment'># Specifies how documents in this index should sort by default, when no `orderBy` argument is provided to the GraphQL query.
</span>  <span class='comment'>#
</span>  <span class='comment'># @note the field name strings can be a dot-separated nested fields, but all referenced
</span>  <span class='comment'>#   fields must exist when this is called.
</span>  <span class='comment'>#
</span>  <span class='comment'># @param field_name_direction_pairs [Array&lt;(String, Symbol)&gt;] pairs of field names and `:asc` or `:desc`
</span>  <span class='comment'># @return [void]
</span>  <span class='comment'>#
</span>  <span class='comment'># @example Sort on `name` (ascending) with `createdAt` (descending) as a tie-breaker
</span>  <span class='comment'>#   ElasticGraph.define_schema do |schema|
</span>  <span class='comment'>#     schema.object_type &quot;Campaign&quot; do |t|
</span>  <span class='comment'>#       t.field &quot;id&quot;, &quot;ID!&quot;
</span>  <span class='comment'>#       t.field &quot;name&quot;, &quot;String&quot;
</span>  <span class='comment'>#       t.field &quot;createdAt&quot;, &quot;DateTime&quot;
</span>  <span class='comment'>#
</span>  <span class='comment'>#       t.index &quot;campaigns&quot;do |i|
</span>  <span class='comment'>#         i.default_sort &quot;name&quot;, :asc, &quot;createdAt&quot;, :desc
</span>  <span class='comment'>#       end
</span>  <span class='comment'>#     end
</span>  <span class='comment'>#   end
</span>  <span class='kw'>def</span> <span class='id identifier rubyid_default_sort'>default_sort</span><span class='lparen'>(</span><span class='op'>*</span><span class='id identifier rubyid_field_name_direction_pairs'>field_name_direction_pairs</span><span class='rparen'>)</span>
    <span class='kw'>self</span><span class='period'>.</span><span class='id identifier rubyid_default_sort_pairs'>default_sort_pairs</span> <span class='op'>=</span> <span class='id identifier rubyid_field_name_direction_pairs'>field_name_direction_pairs</span>
  <span class='kw'>end</span>

  <span class='comment'># Causes this index to &quot;rollover&quot; at the provided `frequency` based on the value of the provided `timestamp_field_path_name`.
</span>  <span class='comment'># This is particularly useful for time-series data. Partitioning the data into `hourly`, `daily`, `monthly` or `yearly` buckets
</span>  <span class='comment'># allows for different index configurations, and can be necessary when a dataset is too large to fit in one dataset given
</span>  <span class='comment'># Elasticsearch/OpenSearch limitations on the number of shards in one index. In addition, ElasticGraph optimizes queries which
</span>  <span class='comment'># filter on the timestamp field to target the subset of the indices in which matching documents could reside.
</span>  <span class='comment'>#
</span>  <span class='comment'># @note the timestamp field specified here **must be immutable**. To understand why, consider a `:yearly` rollover
</span>  <span class='comment'>#   index used for data based on `createdAt`; if ElasticGraph ingests record `123` with a createdAt of `2023-12-31T23:59:59Z`, it
</span>  <span class='comment'>#   will be indexed in the `2023` index. Later if it receives an update event for record `123` with a `createdAt` of
</span>  <span class='comment'>#   `2024-01-01T00:00:00Z` (a mere one second later!), ElasticGraph will store the new version of the payment in the `2024` index,
</span>  <span class='comment'>#   and leave the old copy of the payment in the `2023` index unchanged. It’ll have duplicates for that document.
</span>  <span class='comment'># @note changing the `rollover` configuration on an existing index that already has data will result in duplicate documents
</span>  <span class='comment'>#
</span>  <span class='comment'># @param frequency [:yearly, :monthly, :daily, :hourly] how often to rollover the index
</span>  <span class='comment'># @param timestamp_field_path_name [String] dot-separated path to the timestamp field used for rollover. Note: all referenced
</span>  <span class='comment'>#   fields must exist when this is called.
</span>  <span class='comment'># @return [void]
</span>  <span class='comment'>#
</span>  <span class='comment'># @example Define a `campaigns` index to rollover yearly based on `createdAt`
</span>  <span class='comment'>#   ElasticGraph.define_schema do |schema|
</span>  <span class='comment'>#     schema.object_type &quot;Campaign&quot; do |t|
</span>  <span class='comment'>#       t.field &quot;id&quot;, &quot;ID!&quot;
</span>  <span class='comment'>#       t.field &quot;name&quot;, &quot;String&quot;
</span>  <span class='comment'>#       t.field &quot;createdAt&quot;, &quot;DateTime&quot;
</span>  <span class='comment'>#
</span>  <span class='comment'>#       t.index &quot;campaigns&quot;do |i|
</span>  <span class='comment'>#         i.rollover :yearly, &quot;createdAt&quot;
</span>  <span class='comment'>#       end
</span>  <span class='comment'>#     end
</span>  <span class='comment'>#   end
</span>  <span class='kw'>def</span> <span class='id identifier rubyid_rollover'>rollover</span><span class='lparen'>(</span><span class='id identifier rubyid_frequency'>frequency</span><span class='comma'>,</span> <span class='id identifier rubyid_timestamp_field_path_name'>timestamp_field_path_name</span><span class='rparen'>)</span>
    <span class='id identifier rubyid_timestamp_field_path'>timestamp_field_path</span> <span class='op'>=</span> <span class='id identifier rubyid_public_field_path'>public_field_path</span><span class='lparen'>(</span><span class='id identifier rubyid_timestamp_field_path_name'>timestamp_field_path_name</span><span class='comma'>,</span> <span class='label'>explanation:</span> <span class='tstring'><span class='tstring_beg'>&quot;</span><span class='tstring_content'>it is referenced as an index `rollover` field</span><span class='tstring_end'>&quot;</span></span><span class='rparen'>)</span>

    <span class='kw'>unless</span> <span class='id identifier rubyid_date_and_datetime_types'>date_and_datetime_types</span><span class='period'>.</span><span class='id identifier rubyid_include?'>include?</span><span class='lparen'>(</span><span class='id identifier rubyid_timestamp_field_path'>timestamp_field_path</span><span class='period'>.</span><span class='id identifier rubyid_type'>type</span><span class='period'>.</span><span class='id identifier rubyid_fully_unwrapped'>fully_unwrapped</span><span class='period'>.</span><span class='id identifier rubyid_name'>name</span><span class='rparen'>)</span>
      <span class='id identifier rubyid_date_or_datetime_description'>date_or_datetime_description</span> <span class='op'>=</span> <span class='id identifier rubyid_date_and_datetime_types'>date_and_datetime_types</span><span class='period'>.</span><span class='id identifier rubyid_map'>map</span> <span class='lbrace'>{</span> <span class='op'>|</span><span class='id identifier rubyid_t'>t</span><span class='op'>|</span> <span class='tstring'><span class='tstring_beg'>&quot;</span><span class='tstring_content'>`</span><span class='embexpr_beg'>#{</span><span class='id identifier rubyid_t'>t</span><span class='embexpr_end'>}</span><span class='tstring_content'>`</span><span class='tstring_end'>&quot;</span></span> <span class='rbrace'>}</span><span class='period'>.</span><span class='id identifier rubyid_join'>join</span><span class='lparen'>(</span><span class='tstring'><span class='tstring_beg'>&quot;</span><span class='tstring_content'> or </span><span class='tstring_end'>&quot;</span></span><span class='rparen'>)</span>
      <span class='id identifier rubyid_raise'>raise</span> <span class='const'>Errors</span><span class='op'>::</span><span class='const'>SchemaError</span><span class='comma'>,</span> <span class='tstring'><span class='tstring_beg'>&quot;</span><span class='tstring_content'>rollover field `</span><span class='embexpr_beg'>#{</span><span class='id identifier rubyid_timestamp_field_path'>timestamp_field_path</span><span class='period'>.</span><span class='id identifier rubyid_full_description'>full_description</span><span class='embexpr_end'>}</span><span class='tstring_content'>` cannot be used for rollover since it is not a </span><span class='embexpr_beg'>#{</span><span class='id identifier rubyid_date_or_datetime_description'>date_or_datetime_description</span><span class='embexpr_end'>}</span><span class='tstring_content'> field.</span><span class='tstring_end'>&quot;</span></span>
    <span class='kw'>end</span>

    <span class='kw'>if</span> <span class='id identifier rubyid_timestamp_field_path'>timestamp_field_path</span><span class='period'>.</span><span class='id identifier rubyid_type'>type</span><span class='period'>.</span><span class='id identifier rubyid_list?'>list?</span>
      <span class='id identifier rubyid_raise'>raise</span> <span class='const'>Errors</span><span class='op'>::</span><span class='const'>SchemaError</span><span class='comma'>,</span> <span class='tstring'><span class='tstring_beg'>&quot;</span><span class='tstring_content'>rollover field `</span><span class='embexpr_beg'>#{</span><span class='id identifier rubyid_timestamp_field_path'>timestamp_field_path</span><span class='period'>.</span><span class='id identifier rubyid_full_description'>full_description</span><span class='embexpr_end'>}</span><span class='tstring_content'>` cannot be used for rollover since it is a list field.</span><span class='tstring_end'>&quot;</span></span>
    <span class='kw'>end</span>

    <span class='id identifier rubyid_timestamp_field_path'>timestamp_field_path</span><span class='period'>.</span><span class='id identifier rubyid_path_parts'>path_parts</span><span class='period'>.</span><span class='id identifier rubyid_each'>each</span> <span class='lbrace'>{</span> <span class='op'>|</span><span class='id identifier rubyid_f'>f</span><span class='op'>|</span> <span class='id identifier rubyid_f'>f</span><span class='period'>.</span><span class='id identifier rubyid_json_schema'>json_schema</span> <span class='label'>nullable:</span> <span class='kw'>false</span> <span class='rbrace'>}</span>

    <span class='kw'>self</span><span class='period'>.</span><span class='id identifier rubyid_rollover_config'>rollover_config</span> <span class='op'>=</span> <span class='const'>RolloverConfig</span><span class='period'>.</span><span class='id identifier rubyid_new'>new</span><span class='lparen'>(</span>
      <span class='label'>frequency:</span> <span class='id identifier rubyid_frequency'>frequency</span><span class='comma'>,</span>
      <span class='label'>timestamp_field_path:</span> <span class='id identifier rubyid_timestamp_field_path'>timestamp_field_path</span>
    <span class='rparen'>)</span>
  <span class='kw'>end</span>

  <span class='comment'># Configures the index to [route documents to shards](https://www.elastic.co/guide/en/elasticsearch/reference/8.15/mapping-routing-field.html)
</span>  <span class='comment'># based on the specified field. ElasticGraph optimizes queries that filter on the shard routing field so that they only run on a
</span>  <span class='comment'># subset of nodes instead of all nodes. This can make a big difference in query performance if queries usually filter on a certain
</span>  <span class='comment'># field. Using an appropriate field for shard routing is often essential for horizontal scaling, as it avoids having every query
</span>  <span class='comment'># hit every node, allowing additional nodes to increase query throughput.
</span>  <span class='comment'>#
</span>  <span class='comment'># @note it is essential that the shards are well-balanced. If the data’s distribution is lopsided, using this feature can make
</span>  <span class='comment'>#   performance worse.
</span>  <span class='comment'># @note the routing field specified here **must be immutable**. If ElasticGraph receives an updated version of a document with a
</span>  <span class='comment'>#   different routing value, it’ll write the new version of the document to a different shard and leave the copy on the old shard
</span>  <span class='comment'>#   unchanged, leading to duplicates.
</span>  <span class='comment'># @note changing the shard routing configuration on an existing index that already has data will result in duplicate documents
</span>  <span class='comment'>#
</span>  <span class='comment'># @param routing_field_path_name [String] dot-separated path to the field used for shard routing. Note: all referenced
</span>  <span class='comment'>#   fields must exist when this is called.
</span>  <span class='comment'># @return [void]
</span>  <span class='comment'>#
</span>  <span class='comment'># @example Define a `campaigns` index to shard on `organizationId`
</span>  <span class='comment'>#   ElasticGraph.define_schema do |schema|
</span>  <span class='comment'>#     schema.object_type &quot;Campaign&quot; do |t|
</span>  <span class='comment'>#       t.field &quot;id&quot;, &quot;ID!&quot;
</span>  <span class='comment'>#       t.field &quot;name&quot;, &quot;String&quot;
</span>  <span class='comment'>#       t.field &quot;organizationId&quot;, &quot;ID&quot;
</span>  <span class='comment'>#
</span>  <span class='comment'>#       t.index &quot;campaigns&quot;do |i|
</span>  <span class='comment'>#         i.route_with &quot;organizationId&quot;
</span>  <span class='comment'>#       end
</span>  <span class='comment'>#     end
</span>  <span class='comment'>#   end
</span>  <span class='kw'>def</span> <span class='id identifier rubyid_route_with'>route_with</span><span class='lparen'>(</span><span class='id identifier rubyid_routing_field_path_name'>routing_field_path_name</span><span class='rparen'>)</span>
    <span class='id identifier rubyid_routing_field_path'>routing_field_path</span> <span class='op'>=</span> <span class='id identifier rubyid_public_field_path'>public_field_path</span><span class='lparen'>(</span><span class='id identifier rubyid_routing_field_path_name'>routing_field_path_name</span><span class='comma'>,</span> <span class='label'>explanation:</span> <span class='tstring'><span class='tstring_beg'>&quot;</span><span class='tstring_content'>it is referenced as an index `route_with` field</span><span class='tstring_end'>&quot;</span></span><span class='rparen'>)</span>

    <span class='kw'>unless</span> <span class='id identifier rubyid_routing_field_path'>routing_field_path</span><span class='period'>.</span><span class='id identifier rubyid_type'>type</span><span class='period'>.</span><span class='id identifier rubyid_leaf?'>leaf?</span>
      <span class='id identifier rubyid_raise'>raise</span> <span class='const'>Errors</span><span class='op'>::</span><span class='const'>SchemaError</span><span class='comma'>,</span> <span class='tstring'><span class='tstring_beg'>&quot;</span><span class='tstring_content'>shard routing field `</span><span class='embexpr_beg'>#{</span><span class='id identifier rubyid_routing_field_path'>routing_field_path</span><span class='period'>.</span><span class='id identifier rubyid_full_description'>full_description</span><span class='embexpr_end'>}</span><span class='tstring_content'>` cannot be used for routing since it is not a leaf field.</span><span class='tstring_end'>&quot;</span></span>
    <span class='kw'>end</span>

    <span class='kw'>self</span><span class='period'>.</span><span class='id identifier rubyid_routing_field_path'>routing_field_path</span> <span class='op'>=</span> <span class='id identifier rubyid_routing_field_path'>routing_field_path</span>

    <span class='id identifier rubyid_routing_field_path'>routing_field_path</span><span class='period'>.</span><span class='id identifier rubyid_path_parts'>path_parts</span><span class='lbracket'>[</span><span class='int'>0</span><span class='op'>..</span><span class='op'>-</span><span class='int'>2</span><span class='rbracket'>]</span><span class='period'>.</span><span class='id identifier rubyid_each'>each</span> <span class='lbrace'>{</span> <span class='op'>|</span><span class='id identifier rubyid_f'>f</span><span class='op'>|</span> <span class='id identifier rubyid_f'>f</span><span class='period'>.</span><span class='id identifier rubyid_json_schema'>json_schema</span> <span class='label'>nullable:</span> <span class='kw'>false</span> <span class='rbrace'>}</span>
    <span class='id identifier rubyid_routing_field_path'>routing_field_path</span><span class='period'>.</span><span class='id identifier rubyid_last_part'>last_part</span><span class='period'>.</span><span class='id identifier rubyid_json_schema'>json_schema</span> <span class='label'>nullable:</span> <span class='kw'>false</span><span class='comma'>,</span> <span class='label'>pattern:</span> <span class='const'>HAS_NON_WHITE_SPACE_REGEX</span>
    <span class='id identifier rubyid_indexed_type'>indexed_type</span><span class='period'>.</span><span class='id identifier rubyid_append_to_documentation'>append_to_documentation</span> <span class='tstring'><span class='tstring_beg'>&quot;</span><span class='tstring_content'>For more performant queries on this type, please filter on `</span><span class='embexpr_beg'>#{</span><span class='id identifier rubyid_routing_field_path_name'>routing_field_path_name</span><span class='embexpr_end'>}</span><span class='tstring_content'>` if possible.</span><span class='tstring_end'>&quot;</span></span>
  <span class='kw'>end</span>

  <span class='comment'># @see #route_with
</span>  <span class='comment'># @return [Boolean] whether or not this index uses custom shard routing
</span>  <span class='kw'>def</span> <span class='id identifier rubyid_uses_custom_routing?'>uses_custom_routing?</span>
    <span class='id identifier rubyid_routing_field_path'>routing_field_path</span><span class='period'>.</span><span class='id identifier rubyid_path_in_index'>path_in_index</span> <span class='op'>!=</span> <span class='tstring'><span class='tstring_beg'>&quot;</span><span class='tstring_content'>id</span><span class='tstring_end'>&quot;</span></span>
  <span class='kw'>end</span>

  <span class='comment'># @return [Hash&lt;String, Object&gt;] datastore configuration for this index for when it does not use rollover
</span>  <span class='kw'>def</span> <span class='id identifier rubyid_to_index_config'>to_index_config</span>
    <span class='lbrace'>{</span>
      <span class='tstring'><span class='tstring_beg'>&quot;</span><span class='tstring_content'>aliases</span><span class='tstring_end'>&quot;</span></span> <span class='op'>=&gt;</span> <span class='lbrace'>{</span><span class='rbrace'>}</span><span class='comma'>,</span>
      <span class='tstring'><span class='tstring_beg'>&quot;</span><span class='tstring_content'>mappings</span><span class='tstring_end'>&quot;</span></span> <span class='op'>=&gt;</span> <span class='id identifier rubyid_mappings'>mappings</span><span class='comma'>,</span>
      <span class='tstring'><span class='tstring_beg'>&quot;</span><span class='tstring_content'>settings</span><span class='tstring_end'>&quot;</span></span> <span class='op'>=&gt;</span> <span class='id identifier rubyid_settings'>settings</span>
    <span class='rbrace'>}</span><span class='period'>.</span><span class='id identifier rubyid_compact'>compact</span>
  <span class='kw'>end</span>

  <span class='comment'># @return [Hash&lt;String, Object&gt;] datastore configuration for the index template that will be defined if rollover is used
</span>  <span class='kw'>def</span> <span class='id identifier rubyid_to_index_template_config'>to_index_template_config</span>
    <span class='lbrace'>{</span>
      <span class='tstring'><span class='tstring_beg'>&quot;</span><span class='tstring_content'>index_patterns</span><span class='tstring_end'>&quot;</span></span> <span class='op'>=&gt;</span> <span class='lbracket'>[</span><span class='tstring'><span class='tstring_beg'>&quot;</span><span class='embexpr_beg'>#{</span><span class='id identifier rubyid_name'>name</span><span class='embexpr_end'>}</span><span class='embexpr_beg'>#{</span><span class='const'>ROLLOVER_INDEX_INFIX_MARKER</span><span class='embexpr_end'>}</span><span class='tstring_content'>*</span><span class='tstring_end'>&quot;</span></span><span class='rbracket'>]</span><span class='comma'>,</span>
      <span class='tstring'><span class='tstring_beg'>&quot;</span><span class='tstring_content'>template</span><span class='tstring_end'>&quot;</span></span> <span class='op'>=&gt;</span> <span class='lbrace'>{</span>
        <span class='tstring'><span class='tstring_beg'>&quot;</span><span class='tstring_content'>aliases</span><span class='tstring_end'>&quot;</span></span> <span class='op'>=&gt;</span> <span class='lbrace'>{</span><span class='rbrace'>}</span><span class='comma'>,</span>
        <span class='tstring'><span class='tstring_beg'>&quot;</span><span class='tstring_content'>mappings</span><span class='tstring_end'>&quot;</span></span> <span class='op'>=&gt;</span> <span class='id identifier rubyid_mappings'>mappings</span><span class='comma'>,</span>
        <span class='tstring'><span class='tstring_beg'>&quot;</span><span class='tstring_content'>settings</span><span class='tstring_end'>&quot;</span></span> <span class='op'>=&gt;</span> <span class='id identifier rubyid_settings'>settings</span>
      <span class='rbrace'>}</span>
    <span class='rbrace'>}</span>
  <span class='kw'>end</span>

  <span class='comment'># @return [SchemaArtifacts::RuntimeMetadata::IndexDefinition] runtime metadata for this index
</span>  <span class='kw'>def</span> <span class='id identifier rubyid_runtime_metadata'>runtime_metadata</span>
    <span class='const'>SchemaArtifacts</span><span class='op'>::</span><span class='const'>RuntimeMetadata</span><span class='op'>::</span><span class='const'>IndexDefinition</span><span class='period'>.</span><span class='id identifier rubyid_new'>new</span><span class='lparen'>(</span>
      <span class='label'>route_with:</span> <span class='id identifier rubyid_routing_field_path'>routing_field_path</span><span class='period'>.</span><span class='id identifier rubyid_path_in_index'>path_in_index</span><span class='comma'>,</span>
      <span class='label'>rollover:</span> <span class='id identifier rubyid_rollover_config'>rollover_config</span><span class='op'>&amp;.</span><span class='id identifier rubyid_runtime_metadata'>runtime_metadata</span><span class='comma'>,</span>
      <span class='label'>current_sources:</span> <span class='id identifier rubyid_indexed_type'>indexed_type</span><span class='period'>.</span><span class='id identifier rubyid_current_sources'>current_sources</span><span class='comma'>,</span>
      <span class='label'>fields_by_path:</span> <span class='id identifier rubyid_indexed_type'>indexed_type</span><span class='period'>.</span><span class='id identifier rubyid_index_field_runtime_metadata_tuples'>index_field_runtime_metadata_tuples</span><span class='period'>.</span><span class='id identifier rubyid_to_h'>to_h</span><span class='comma'>,</span>
      <span class='label'>default_sort_fields:</span> <span class='id identifier rubyid_default_sort_pairs'>default_sort_pairs</span><span class='period'>.</span><span class='id identifier rubyid_each_slice'>each_slice</span><span class='lparen'>(</span><span class='int'>2</span><span class='rparen'>)</span><span class='period'>.</span><span class='id identifier rubyid_map'>map</span> <span class='kw'>do</span> <span class='op'>|</span><span class='lparen'>(</span><span class='id identifier rubyid_graphql_field_path_name'>graphql_field_path_name</span><span class='comma'>,</span> <span class='id identifier rubyid_direction'>direction</span><span class='rparen'>)</span><span class='op'>|</span>
        <span class='const'>SchemaArtifacts</span><span class='op'>::</span><span class='const'>RuntimeMetadata</span><span class='op'>::</span><span class='const'>SortField</span><span class='period'>.</span><span class='id identifier rubyid_new'>new</span><span class='lparen'>(</span>
          <span class='label'>field_path:</span> <span class='id identifier rubyid_public_field_path'>public_field_path</span><span class='lparen'>(</span><span class='id identifier rubyid_graphql_field_path_name'>graphql_field_path_name</span><span class='comma'>,</span> <span class='label'>explanation:</span> <span class='tstring'><span class='tstring_beg'>&quot;</span><span class='tstring_content'>it is referenced as an index `default_sort` field</span><span class='tstring_end'>&quot;</span></span><span class='rparen'>)</span><span class='period'>.</span><span class='id identifier rubyid_path_in_index'>path_in_index</span><span class='comma'>,</span>
          <span class='label'>direction:</span> <span class='id identifier rubyid_direction'>direction</span>
        <span class='rparen'>)</span>
      <span class='kw'>end</span>
    <span class='rparen'>)</span>
  <span class='kw'>end</span>

  <span class='id identifier rubyid_private'>private</span>

  <span class='comment'># A regex that requires at least one non-whitespace character.
</span>  <span class='comment'># Note: this does not use the `/S` character class because it&#39;s recommended to use a small subset
</span>  <span class='comment'># of Regex syntax:
</span>  <span class='comment'>#
</span>  <span class='comment'># &gt; The regular expression syntax used is from JavaScript (ECMA 262, specifically). However, that
</span>  <span class='comment'># &gt; complete syntax is not widely supported, therefore it is recommended that you stick to the subset
</span>  <span class='comment'># &gt; of that syntax described below.
</span>  <span class='comment'>#
</span>  <span class='comment'># (From https://json-schema.org/understanding-json-schema/reference/regular_expressions.html)
</span>  <span class='const'>HAS_NON_WHITE_SPACE_REGEX</span> <span class='op'>=</span> <span class='tstring'><span class='tstring_beg'>&quot;</span><span class='tstring_content'>[^ \t\n]+</span><span class='tstring_end'>&quot;</span></span>

  <span class='const'>DEFAULT_SETTINGS</span> <span class='op'>=</span> <span class='lbrace'>{</span>
    <span class='tstring'><span class='tstring_beg'>&quot;</span><span class='tstring_content'>index.mapping.ignore_malformed</span><span class='tstring_end'>&quot;</span></span> <span class='op'>=&gt;</span> <span class='kw'>false</span><span class='comma'>,</span>
    <span class='tstring'><span class='tstring_beg'>&quot;</span><span class='tstring_content'>index.mapping.coerce</span><span class='tstring_end'>&quot;</span></span> <span class='op'>=&gt;</span> <span class='kw'>false</span><span class='comma'>,</span>
    <span class='tstring'><span class='tstring_beg'>&quot;</span><span class='tstring_content'>index.number_of_replicas</span><span class='tstring_end'>&quot;</span></span> <span class='op'>=&gt;</span> <span class='int'>1</span><span class='comma'>,</span>
    <span class='tstring'><span class='tstring_beg'>&quot;</span><span class='tstring_content'>index.number_of_shards</span><span class='tstring_end'>&quot;</span></span> <span class='op'>=&gt;</span> <span class='int'>1</span>
  <span class='rbrace'>}</span>

  <span class='kw'>def</span> <span class='id identifier rubyid_mappings'>mappings</span>
    <span class='id identifier rubyid_field_mappings'>field_mappings</span> <span class='op'>=</span> <span class='id identifier rubyid_indexed_type'>indexed_type</span>
      <span class='period'>.</span><span class='id identifier rubyid_to_indexing_field_type'>to_indexing_field_type</span>
      <span class='period'>.</span><span class='id identifier rubyid_to_mapping'>to_mapping</span>
      <span class='period'>.</span><span class='id identifier rubyid_except'>except</span><span class='lparen'>(</span><span class='tstring'><span class='tstring_beg'>&quot;</span><span class='tstring_content'>type</span><span class='tstring_end'>&quot;</span></span><span class='rparen'>)</span> <span class='comment'># `type` is invalid at the mapping root because it always has to be an object.
</span>      <span class='period'>.</span><span class='id identifier rubyid_then'>then</span> <span class='lbrace'>{</span> <span class='op'>|</span><span class='id identifier rubyid_mapping'>mapping</span><span class='op'>|</span> <span class='const'>ListCountsMapping</span><span class='period'>.</span><span class='id identifier rubyid_merged_into'>merged_into</span><span class='lparen'>(</span><span class='id identifier rubyid_mapping'>mapping</span><span class='comma'>,</span> <span class='label'>for_type:</span> <span class='id identifier rubyid_indexed_type'>indexed_type</span><span class='rparen'>)</span> <span class='rbrace'>}</span>
      <span class='period'>.</span><span class='id identifier rubyid_then'>then</span> <span class='kw'>do</span> <span class='op'>|</span><span class='id identifier rubyid_fm'>fm</span><span class='op'>|</span>
        <span class='const'><span class='object_link'><a href="../../Support.html" title="ElasticGraph::Support (module)">Support</a></span></span><span class='op'>::</span><span class='const'>HashUtil</span><span class='period'>.</span><span class='id identifier rubyid_deep_merge'>deep_merge</span><span class='lparen'>(</span><span class='id identifier rubyid_fm'>fm</span><span class='comma'>,</span> <span class='lbrace'>{</span><span class='tstring'><span class='tstring_beg'>&quot;</span><span class='tstring_content'>properties</span><span class='tstring_end'>&quot;</span></span> <span class='op'>=&gt;</span> <span class='lbrace'>{</span>
          <span class='tstring'><span class='tstring_beg'>&quot;</span><span class='tstring_content'>__sources</span><span class='tstring_end'>&quot;</span></span> <span class='op'>=&gt;</span> <span class='lbrace'>{</span><span class='tstring'><span class='tstring_beg'>&quot;</span><span class='tstring_content'>type</span><span class='tstring_end'>&quot;</span></span> <span class='op'>=&gt;</span> <span class='tstring'><span class='tstring_beg'>&quot;</span><span class='tstring_content'>keyword</span><span class='tstring_end'>&quot;</span></span><span class='rbrace'>}</span><span class='comma'>,</span>
          <span class='tstring'><span class='tstring_beg'>&quot;</span><span class='tstring_content'>__versions</span><span class='tstring_end'>&quot;</span></span> <span class='op'>=&gt;</span> <span class='lbrace'>{</span>
            <span class='tstring'><span class='tstring_beg'>&quot;</span><span class='tstring_content'>type</span><span class='tstring_end'>&quot;</span></span> <span class='op'>=&gt;</span> <span class='tstring'><span class='tstring_beg'>&quot;</span><span class='tstring_content'>object</span><span class='tstring_end'>&quot;</span></span><span class='comma'>,</span>
            <span class='comment'># __versions is map keyed by relationship name, with values that are maps keyed by id. Since it&#39;s not
</span>            <span class='comment'># a static object with known fields, we need to use dynamic here. Passing `false` allows some level
</span>            <span class='comment'># of dynamicness. As per https://www.elastic.co/guide/en/elasticsearch/reference/8.7/dynamic.html#dynamic-parameters:
</span>            <span class='comment'>#
</span>            <span class='comment'># &gt; New fields are ignored. These fields will not be indexed or searchable, but will still appear in the _source
</span>            <span class='comment'># &gt; field of returned hits. These fields will not be added to the mapping, and new fields must be added explicitly.
</span>            <span class='comment'>#
</span>            <span class='comment'># We need `__versions` to be in `_source` (so that our update scripts can operate on it), but
</span>            <span class='comment'># have no need for it to be searchable (as it&#39;s just an internal data structure used for indexing).
</span>            <span class='comment'>#
</span>            <span class='comment'># Note: we intentionally set false as a string here, because that&#39;s how the datastore echoes it back
</span>            <span class='comment'># to us when you query the mapping (even if you set it as a boolean). Our checks for index mapping
</span>            <span class='comment'># consistency fail validation if we set it as a boolean since the datastore doesn&#39;t echo it back as
</span>            <span class='comment'># a boolean.
</span>            <span class='tstring'><span class='tstring_beg'>&quot;</span><span class='tstring_content'>dynamic</span><span class='tstring_end'>&quot;</span></span> <span class='op'>=&gt;</span> <span class='tstring'><span class='tstring_beg'>&quot;</span><span class='tstring_content'>false</span><span class='tstring_end'>&quot;</span></span>
          <span class='rbrace'>}</span>
        <span class='rbrace'>}</span><span class='rbrace'>}</span><span class='rparen'>)</span>
      <span class='kw'>end</span>

    <span class='lbrace'>{</span><span class='tstring'><span class='tstring_beg'>&quot;</span><span class='tstring_content'>dynamic</span><span class='tstring_end'>&quot;</span></span> <span class='op'>=&gt;</span> <span class='tstring'><span class='tstring_beg'>&quot;</span><span class='tstring_content'>strict</span><span class='tstring_end'>&quot;</span></span><span class='rbrace'>}</span><span class='period'>.</span><span class='id identifier rubyid_merge'>merge</span><span class='lparen'>(</span><span class='id identifier rubyid_field_mappings'>field_mappings</span><span class='rparen'>)</span><span class='period'>.</span><span class='id identifier rubyid_tap'>tap</span> <span class='kw'>do</span> <span class='op'>|</span><span class='id identifier rubyid_hash'>hash</span><span class='op'>|</span>
      <span class='comment'># If we are using custom shard routing, we want to require a `routing` value to be provided
</span>      <span class='comment'># in every single index, get, delete or update request; otherwise the request might be
</span>      <span class='comment'># made against the wrong shard.
</span>      <span class='id identifier rubyid_hash'>hash</span><span class='lbracket'>[</span><span class='tstring'><span class='tstring_beg'>&quot;</span><span class='tstring_content'>_routing</span><span class='tstring_end'>&quot;</span></span><span class='rbracket'>]</span> <span class='op'>=</span> <span class='lbrace'>{</span><span class='tstring'><span class='tstring_beg'>&quot;</span><span class='tstring_content'>required</span><span class='tstring_end'>&quot;</span></span> <span class='op'>=&gt;</span> <span class='kw'>true</span><span class='rbrace'>}</span> <span class='kw'>if</span> <span class='id identifier rubyid_uses_custom_routing?'>uses_custom_routing?</span>
      <span class='id identifier rubyid_hash'>hash</span><span class='lbracket'>[</span><span class='tstring'><span class='tstring_beg'>&quot;</span><span class='tstring_content'>_size</span><span class='tstring_end'>&quot;</span></span><span class='rbracket'>]</span> <span class='op'>=</span> <span class='lbrace'>{</span><span class='tstring'><span class='tstring_beg'>&quot;</span><span class='tstring_content'>enabled</span><span class='tstring_end'>&quot;</span></span> <span class='op'>=&gt;</span> <span class='kw'>true</span><span class='rbrace'>}</span> <span class='kw'>if</span> <span class='id identifier rubyid_schema_def_state'>schema_def_state</span><span class='period'>.</span><span class='id identifier rubyid_index_document_sizes?'>index_document_sizes?</span>
    <span class='kw'>end</span>
  <span class='kw'>end</span>

  <span class='kw'>def</span> <span class='id identifier rubyid_public_field_path'>public_field_path</span><span class='lparen'>(</span><span class='id identifier rubyid_public_path_string'>public_path_string</span><span class='comma'>,</span> <span class='label'>explanation:</span><span class='rparen'>)</span>
    <span class='id identifier rubyid_parent_is_not_list'>parent_is_not_list</span> <span class='op'>=</span> <span class='tlambda'>-&gt;</span><span class='lparen'>(</span><span class='id identifier rubyid_parent_field'>parent_field</span><span class='rparen'>)</span> <span class='tlambeg'>{</span> <span class='op'>!</span><span class='id identifier rubyid_parent_field'>parent_field</span><span class='period'>.</span><span class='id identifier rubyid_type'>type</span><span class='period'>.</span><span class='id identifier rubyid_list?'>list?</span> <span class='rbrace'>}</span>
    <span class='id identifier rubyid_resolver'>resolver</span> <span class='op'>=</span> <span class='const'><span class='object_link'><a href="../SchemaElements.html" title="ElasticGraph::SchemaDefinition::SchemaElements (module)">SchemaElements</a></span></span><span class='op'>::</span><span class='const'>FieldPath</span><span class='op'>::</span><span class='const'>Resolver</span><span class='period'>.</span><span class='id identifier rubyid_new'>new</span>
    <span class='id identifier rubyid_resolved_path'>resolved_path</span> <span class='op'>=</span> <span class='id identifier rubyid_resolver'>resolver</span><span class='period'>.</span><span class='id identifier rubyid_resolve_public_path'>resolve_public_path</span><span class='lparen'>(</span><span class='id identifier rubyid_indexed_type'>indexed_type</span><span class='comma'>,</span> <span class='id identifier rubyid_public_path_string'>public_path_string</span><span class='comma'>,</span> <span class='op'>&amp;</span><span class='id identifier rubyid_parent_is_not_list'>parent_is_not_list</span><span class='rparen'>)</span>
    <span class='kw'>return</span> <span class='id identifier rubyid_resolved_path'>resolved_path</span> <span class='kw'>if</span> <span class='id identifier rubyid_resolved_path'>resolved_path</span>

    <span class='id identifier rubyid_path_parts'>path_parts</span> <span class='op'>=</span> <span class='id identifier rubyid_public_path_string'>public_path_string</span><span class='period'>.</span><span class='id identifier rubyid_split'>split</span><span class='lparen'>(</span><span class='tstring'><span class='tstring_beg'>&quot;</span><span class='tstring_content'>.</span><span class='tstring_end'>&quot;</span></span><span class='rparen'>)</span>
    <span class='id identifier rubyid_error_msg'>error_msg</span> <span class='op'>=</span> <span class='tstring'><span class='tstring_beg'>&quot;</span><span class='tstring_content'>Field `</span><span class='embexpr_beg'>#{</span><span class='id identifier rubyid_indexed_type'>indexed_type</span><span class='period'>.</span><span class='id identifier rubyid_name'>name</span><span class='embexpr_end'>}</span><span class='tstring_content'>.</span><span class='embexpr_beg'>#{</span><span class='id identifier rubyid_public_path_string'>public_path_string</span><span class='embexpr_end'>}</span><span class='tstring_content'>` cannot be resolved, but </span><span class='embexpr_beg'>#{</span><span class='id identifier rubyid_explanation'>explanation</span><span class='embexpr_end'>}</span><span class='tstring_content'>.</span><span class='tstring_end'>&quot;</span></span>

    <span class='comment'># If it is a nested field path, the problem could be that a type has been referenced which does not exist, so mention that.
</span>    <span class='kw'>if</span> <span class='id identifier rubyid_path_parts'>path_parts</span><span class='period'>.</span><span class='id identifier rubyid_size'>size</span> <span class='op'>&gt;</span> <span class='int'>1</span>
      <span class='id identifier rubyid_error_msg'>error_msg</span> <span class='op'>+=</span> <span class='tstring'><span class='tstring_beg'>&quot;</span><span class='tstring_content'> Verify that all fields and types referenced by `</span><span class='embexpr_beg'>#{</span><span class='id identifier rubyid_public_path_string'>public_path_string</span><span class='embexpr_end'>}</span><span class='tstring_content'>` are defined.</span><span class='tstring_end'>&quot;</span></span>
    <span class='kw'>end</span>

    <span class='comment'># If the first part of the path doesn&#39;t resolve, the problem could be that the field is defined after the `index` call
</span>    <span class='comment'># but it needs to be defined before it, so mention that.
</span>    <span class='kw'>if</span> <span class='id identifier rubyid_resolver'>resolver</span><span class='period'>.</span><span class='id identifier rubyid_resolve_public_path'>resolve_public_path</span><span class='lparen'>(</span><span class='id identifier rubyid_indexed_type'>indexed_type</span><span class='comma'>,</span> <span class='id identifier rubyid_path_parts'>path_parts</span><span class='period'>.</span><span class='id identifier rubyid_first'>first</span><span class='comma'>,</span> <span class='op'>&amp;</span><span class='id identifier rubyid_parent_is_not_list'>parent_is_not_list</span><span class='rparen'>)</span><span class='period'>.</span><span class='id identifier rubyid_nil?'>nil?</span>
      <span class='id identifier rubyid_error_msg'>error_msg</span> <span class='op'>+=</span> <span class='tstring'><span class='tstring_beg'>&quot;</span><span class='tstring_content'> Note: the `</span><span class='embexpr_beg'>#{</span><span class='id identifier rubyid_indexed_type'>indexed_type</span><span class='period'>.</span><span class='id identifier rubyid_name'>name</span><span class='embexpr_end'>}</span><span class='tstring_content'>.</span><span class='embexpr_beg'>#{</span><span class='id identifier rubyid_path_parts'>path_parts</span><span class='period'>.</span><span class='id identifier rubyid_first'>first</span><span class='embexpr_end'>}</span><span class='tstring_content'>` definition must come before the `index` call.</span><span class='tstring_end'>&quot;</span></span>
    <span class='kw'>end</span>

    <span class='id identifier rubyid_raise'>raise</span> <span class='const'>Errors</span><span class='op'>::</span><span class='const'>SchemaError</span><span class='comma'>,</span> <span class='id identifier rubyid_error_msg'>error_msg</span>
  <span class='kw'>end</span>

  <span class='kw'>def</span> <span class='id identifier rubyid_date_and_datetime_types'>date_and_datetime_types</span>
    <span class='ivar'>@date_and_datetime_types</span> <span class='op'>||=</span> <span class='qwords_beg'>%w[</span><span class='tstring_content'>Date</span><span class='words_sep'> </span><span class='tstring_content'>DateTime</span><span class='tstring_end'>]</span></span><span class='period'>.</span><span class='id identifier rubyid_map'>map</span> <span class='kw'>do</span> <span class='op'>|</span><span class='id identifier rubyid_type'>type</span><span class='op'>|</span>
      <span class='id identifier rubyid_schema_def_state'>schema_def_state</span><span class='period'>.</span><span class='id identifier rubyid_type_namer'>type_namer</span><span class='period'>.</span><span class='id identifier rubyid_name_for'>name_for</span><span class='lparen'>(</span><span class='id identifier rubyid_type'>type</span><span class='rparen'>)</span>
    <span class='kw'>end</span>
  <span class='kw'>end</span>
<span class='kw'>end</span></pre>
    </td>
  </tr>
</table>
</div>
    
      
      <span id=""></span>
      <div class="method_details ">
  <h3 class="signature " id="settings-instance_method">
  
    #<strong>settings</strong>  &#x21d2; <tt>Hash&lt;(String, Object)&gt;</tt>  <span class="extras">(readonly)</span>
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    <p>Returns datastore settings for the index.</p>


  </div>
</div>
<div class="tags">
  
<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt>Hash&lt;(String, Object)&gt;</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>datastore settings for the index</p>
</div>
      
    </li>
  
</ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
55
56
57
58
59
60
61
62
63
64
65
66
67
68
69
70
71
72
73
74
75
76
77
78
79
80
81
82
83
84
85
86
87
88
89
90
91
92
93
94
95
96
97
98
99
100
101
102
103
104
105
106
107
108
109
110
111
112
113
114
115
116
117
118
119
120
121
122
123
124
125
126
127
128
129
130
131
132
133
134
135
136
137
138
139
140
141
142
143
144
145
146
147
148
149
150
151
152
153
154
155
156
157
158
159
160
161
162
163
164
165
166
167
168
169
170
171
172
173
174
175
176
177
178
179
180
181
182
183
184
185
186
187
188
189
190
191
192
193
194
195
196
197
198
199
200
201
202
203
204
205
206
207
208
209
210
211
212
213
214
215
216
217
218
219
220
221
222
223
224
225
226
227
228
229
230
231
232
233
234
235
236
237
238
239
240
241
242
243
244
245
246
247
248
249
250
251
252
253
254
255
256
257
258
259
260
261
262
263
264
265
266
267
268
269
270
271
272
273
274
275
276
277
278
279
280
281
282
283
284
285
286
287
288
289
290
291
292
293
294
295
296
297
298
299
300
301
302
303
304
305
306
307
308
309
310
311
312
313
314
315</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'elasticgraph-schema_definition/lib/elastic_graph/schema_definition/indexing/index.rb', line 39</span>

<span class='kw'>class</span> <span class='const'><span class='object_link'><a href="" title="ElasticGraph::SchemaDefinition::Indexing::Index (class)">Index</a></span></span> <span class='op'>&lt;</span> <span class='const'>Struct</span><span class='period'>.</span><span class='id identifier rubyid_new'>new</span><span class='lparen'>(</span><span class='symbol'>:name</span><span class='comma'>,</span> <span class='symbol'>:default_sort_pairs</span><span class='comma'>,</span> <span class='symbol'>:settings</span><span class='comma'>,</span> <span class='symbol'>:schema_def_state</span><span class='comma'>,</span> <span class='symbol'>:indexed_type</span><span class='comma'>,</span> <span class='symbol'>:routing_field_path</span><span class='comma'>,</span> <span class='symbol'>:rollover_config</span><span class='rparen'>)</span>
  <span class='id identifier rubyid_include'>include</span> <span class='const'><span class='object_link'><a href="../Mixins.html" title="ElasticGraph::SchemaDefinition::Mixins (module)">Mixins</a></span></span><span class='op'>::</span><span class='const'>HasReadableToSAndInspect</span><span class='period'>.</span><span class='id identifier rubyid_new'>new</span> <span class='lbrace'>{</span> <span class='op'>|</span><span class='id identifier rubyid_i'>i</span><span class='op'>|</span> <span class='id identifier rubyid_i'>i</span><span class='period'>.</span><span class='id identifier rubyid_name'>name</span> <span class='rbrace'>}</span>

  <span class='comment'># @param name [String] name of the index
</span>  <span class='comment'># @param settings [Hash&lt;(String, Object)&gt;] datastore settings for the index
</span>  <span class='comment'># @param schema_def_state [State] schema definition state
</span>  <span class='comment'># @param indexed_type [SchemaElements::ObjectType, SchemaElements::InterfaceType, SchemaElements::UnionType] type backed by this index
</span>  <span class='comment'># @yield [Index] the index, for further customization
</span>  <span class='comment'># @api private
</span>  <span class='kw'>def</span> <span class='id identifier rubyid_initialize'>initialize</span><span class='lparen'>(</span><span class='id identifier rubyid_name'>name</span><span class='comma'>,</span> <span class='id identifier rubyid_settings'>settings</span><span class='comma'>,</span> <span class='id identifier rubyid_schema_def_state'>schema_def_state</span><span class='comma'>,</span> <span class='id identifier rubyid_indexed_type'>indexed_type</span><span class='rparen'>)</span>
    <span class='kw'>if</span> <span class='id identifier rubyid_name'>name</span><span class='period'>.</span><span class='id identifier rubyid_include?'>include?</span><span class='lparen'>(</span><span class='const'>ROLLOVER_INDEX_INFIX_MARKER</span><span class='rparen'>)</span>
      <span class='id identifier rubyid_raise'>raise</span> <span class='const'>Errors</span><span class='op'>::</span><span class='const'>SchemaError</span><span class='comma'>,</span> <span class='tstring'><span class='tstring_beg'>&quot;</span><span class='tstring_content'>`</span><span class='embexpr_beg'>#{</span><span class='id identifier rubyid_name'>name</span><span class='embexpr_end'>}</span><span class='tstring_content'>` is an invalid index definition name since it contains </span><span class='tstring_end'>&quot;</span></span> \
        <span class='tstring'><span class='tstring_beg'>&quot;</span><span class='tstring_content'>`</span><span class='embexpr_beg'>#{</span><span class='const'>ROLLOVER_INDEX_INFIX_MARKER</span><span class='embexpr_end'>}</span><span class='tstring_content'>` which ElasticGraph treats as special.</span><span class='tstring_end'>&quot;</span></span>
    <span class='kw'>end</span>

    <span class='id identifier rubyid_settings'>settings</span> <span class='op'>=</span> <span class='const'>DEFAULT_SETTINGS</span><span class='period'>.</span><span class='id identifier rubyid_merge'>merge</span><span class='lparen'>(</span><span class='const'><span class='object_link'><a href="../../Support.html" title="ElasticGraph::Support (module)">Support</a></span></span><span class='op'>::</span><span class='const'>HashUtil</span><span class='period'>.</span><span class='id identifier rubyid_flatten_and_stringify_keys'>flatten_and_stringify_keys</span><span class='lparen'>(</span><span class='id identifier rubyid_settings'>settings</span><span class='comma'>,</span> <span class='label'>prefix:</span> <span class='tstring'><span class='tstring_beg'>&quot;</span><span class='tstring_content'>index</span><span class='tstring_end'>&quot;</span></span><span class='rparen'>)</span><span class='rparen'>)</span>

    <span class='kw'>super</span><span class='lparen'>(</span><span class='id identifier rubyid_name'>name</span><span class='comma'>,</span> <span class='lbracket'>[</span><span class='rbracket'>]</span><span class='comma'>,</span> <span class='id identifier rubyid_settings'>settings</span><span class='comma'>,</span> <span class='id identifier rubyid_schema_def_state'>schema_def_state</span><span class='comma'>,</span> <span class='id identifier rubyid_indexed_type'>indexed_type</span><span class='comma'>,</span> <span class='lbracket'>[</span><span class='rbracket'>]</span><span class='comma'>,</span> <span class='kw'>nil</span><span class='rparen'>)</span>

    <span class='comment'># `id` is the field Elasticsearch/OpenSearch use for routing by default:
</span>    <span class='comment'># https://www.elastic.co/guide/en/elasticsearch/reference/current/mapping-routing-field.html
</span>    <span class='comment'># By using it here, it will cause queries to pass a `routing` parameter when
</span>    <span class='comment'># searching with id filtering on an index that does not use custom shard routing, giving
</span>    <span class='comment'># us a nice efficiency boost.
</span>    <span class='kw'>self</span><span class='period'>.</span><span class='id identifier rubyid_routing_field_path'>routing_field_path</span> <span class='op'>=</span> <span class='id identifier rubyid_public_field_path'>public_field_path</span><span class='lparen'>(</span><span class='tstring'><span class='tstring_beg'>&quot;</span><span class='tstring_content'>id</span><span class='tstring_end'>&quot;</span></span><span class='comma'>,</span> <span class='label'>explanation:</span> <span class='tstring'><span class='tstring_beg'>&quot;</span><span class='tstring_content'>indexed types must have an `id` field</span><span class='tstring_end'>&quot;</span></span><span class='rparen'>)</span>

    <span class='kw'>yield</span> <span class='kw'>self</span> <span class='kw'>if</span> <span class='id identifier rubyid_block_given?'>block_given?</span>
  <span class='kw'>end</span>

  <span class='comment'># Specifies how documents in this index should sort by default, when no `orderBy` argument is provided to the GraphQL query.
</span>  <span class='comment'>#
</span>  <span class='comment'># @note the field name strings can be a dot-separated nested fields, but all referenced
</span>  <span class='comment'>#   fields must exist when this is called.
</span>  <span class='comment'>#
</span>  <span class='comment'># @param field_name_direction_pairs [Array&lt;(String, Symbol)&gt;] pairs of field names and `:asc` or `:desc`
</span>  <span class='comment'># @return [void]
</span>  <span class='comment'>#
</span>  <span class='comment'># @example Sort on `name` (ascending) with `createdAt` (descending) as a tie-breaker
</span>  <span class='comment'>#   ElasticGraph.define_schema do |schema|
</span>  <span class='comment'>#     schema.object_type &quot;Campaign&quot; do |t|
</span>  <span class='comment'>#       t.field &quot;id&quot;, &quot;ID!&quot;
</span>  <span class='comment'>#       t.field &quot;name&quot;, &quot;String&quot;
</span>  <span class='comment'>#       t.field &quot;createdAt&quot;, &quot;DateTime&quot;
</span>  <span class='comment'>#
</span>  <span class='comment'>#       t.index &quot;campaigns&quot;do |i|
</span>  <span class='comment'>#         i.default_sort &quot;name&quot;, :asc, &quot;createdAt&quot;, :desc
</span>  <span class='comment'>#       end
</span>  <span class='comment'>#     end
</span>  <span class='comment'>#   end
</span>  <span class='kw'>def</span> <span class='id identifier rubyid_default_sort'>default_sort</span><span class='lparen'>(</span><span class='op'>*</span><span class='id identifier rubyid_field_name_direction_pairs'>field_name_direction_pairs</span><span class='rparen'>)</span>
    <span class='kw'>self</span><span class='period'>.</span><span class='id identifier rubyid_default_sort_pairs'>default_sort_pairs</span> <span class='op'>=</span> <span class='id identifier rubyid_field_name_direction_pairs'>field_name_direction_pairs</span>
  <span class='kw'>end</span>

  <span class='comment'># Causes this index to &quot;rollover&quot; at the provided `frequency` based on the value of the provided `timestamp_field_path_name`.
</span>  <span class='comment'># This is particularly useful for time-series data. Partitioning the data into `hourly`, `daily`, `monthly` or `yearly` buckets
</span>  <span class='comment'># allows for different index configurations, and can be necessary when a dataset is too large to fit in one dataset given
</span>  <span class='comment'># Elasticsearch/OpenSearch limitations on the number of shards in one index. In addition, ElasticGraph optimizes queries which
</span>  <span class='comment'># filter on the timestamp field to target the subset of the indices in which matching documents could reside.
</span>  <span class='comment'>#
</span>  <span class='comment'># @note the timestamp field specified here **must be immutable**. To understand why, consider a `:yearly` rollover
</span>  <span class='comment'>#   index used for data based on `createdAt`; if ElasticGraph ingests record `123` with a createdAt of `2023-12-31T23:59:59Z`, it
</span>  <span class='comment'>#   will be indexed in the `2023` index. Later if it receives an update event for record `123` with a `createdAt` of
</span>  <span class='comment'>#   `2024-01-01T00:00:00Z` (a mere one second later!), ElasticGraph will store the new version of the payment in the `2024` index,
</span>  <span class='comment'>#   and leave the old copy of the payment in the `2023` index unchanged. It’ll have duplicates for that document.
</span>  <span class='comment'># @note changing the `rollover` configuration on an existing index that already has data will result in duplicate documents
</span>  <span class='comment'>#
</span>  <span class='comment'># @param frequency [:yearly, :monthly, :daily, :hourly] how often to rollover the index
</span>  <span class='comment'># @param timestamp_field_path_name [String] dot-separated path to the timestamp field used for rollover. Note: all referenced
</span>  <span class='comment'>#   fields must exist when this is called.
</span>  <span class='comment'># @return [void]
</span>  <span class='comment'>#
</span>  <span class='comment'># @example Define a `campaigns` index to rollover yearly based on `createdAt`
</span>  <span class='comment'>#   ElasticGraph.define_schema do |schema|
</span>  <span class='comment'>#     schema.object_type &quot;Campaign&quot; do |t|
</span>  <span class='comment'>#       t.field &quot;id&quot;, &quot;ID!&quot;
</span>  <span class='comment'>#       t.field &quot;name&quot;, &quot;String&quot;
</span>  <span class='comment'>#       t.field &quot;createdAt&quot;, &quot;DateTime&quot;
</span>  <span class='comment'>#
</span>  <span class='comment'>#       t.index &quot;campaigns&quot;do |i|
</span>  <span class='comment'>#         i.rollover :yearly, &quot;createdAt&quot;
</span>  <span class='comment'>#       end
</span>  <span class='comment'>#     end
</span>  <span class='comment'>#   end
</span>  <span class='kw'>def</span> <span class='id identifier rubyid_rollover'>rollover</span><span class='lparen'>(</span><span class='id identifier rubyid_frequency'>frequency</span><span class='comma'>,</span> <span class='id identifier rubyid_timestamp_field_path_name'>timestamp_field_path_name</span><span class='rparen'>)</span>
    <span class='id identifier rubyid_timestamp_field_path'>timestamp_field_path</span> <span class='op'>=</span> <span class='id identifier rubyid_public_field_path'>public_field_path</span><span class='lparen'>(</span><span class='id identifier rubyid_timestamp_field_path_name'>timestamp_field_path_name</span><span class='comma'>,</span> <span class='label'>explanation:</span> <span class='tstring'><span class='tstring_beg'>&quot;</span><span class='tstring_content'>it is referenced as an index `rollover` field</span><span class='tstring_end'>&quot;</span></span><span class='rparen'>)</span>

    <span class='kw'>unless</span> <span class='id identifier rubyid_date_and_datetime_types'>date_and_datetime_types</span><span class='period'>.</span><span class='id identifier rubyid_include?'>include?</span><span class='lparen'>(</span><span class='id identifier rubyid_timestamp_field_path'>timestamp_field_path</span><span class='period'>.</span><span class='id identifier rubyid_type'>type</span><span class='period'>.</span><span class='id identifier rubyid_fully_unwrapped'>fully_unwrapped</span><span class='period'>.</span><span class='id identifier rubyid_name'>name</span><span class='rparen'>)</span>
      <span class='id identifier rubyid_date_or_datetime_description'>date_or_datetime_description</span> <span class='op'>=</span> <span class='id identifier rubyid_date_and_datetime_types'>date_and_datetime_types</span><span class='period'>.</span><span class='id identifier rubyid_map'>map</span> <span class='lbrace'>{</span> <span class='op'>|</span><span class='id identifier rubyid_t'>t</span><span class='op'>|</span> <span class='tstring'><span class='tstring_beg'>&quot;</span><span class='tstring_content'>`</span><span class='embexpr_beg'>#{</span><span class='id identifier rubyid_t'>t</span><span class='embexpr_end'>}</span><span class='tstring_content'>`</span><span class='tstring_end'>&quot;</span></span> <span class='rbrace'>}</span><span class='period'>.</span><span class='id identifier rubyid_join'>join</span><span class='lparen'>(</span><span class='tstring'><span class='tstring_beg'>&quot;</span><span class='tstring_content'> or </span><span class='tstring_end'>&quot;</span></span><span class='rparen'>)</span>
      <span class='id identifier rubyid_raise'>raise</span> <span class='const'>Errors</span><span class='op'>::</span><span class='const'>SchemaError</span><span class='comma'>,</span> <span class='tstring'><span class='tstring_beg'>&quot;</span><span class='tstring_content'>rollover field `</span><span class='embexpr_beg'>#{</span><span class='id identifier rubyid_timestamp_field_path'>timestamp_field_path</span><span class='period'>.</span><span class='id identifier rubyid_full_description'>full_description</span><span class='embexpr_end'>}</span><span class='tstring_content'>` cannot be used for rollover since it is not a </span><span class='embexpr_beg'>#{</span><span class='id identifier rubyid_date_or_datetime_description'>date_or_datetime_description</span><span class='embexpr_end'>}</span><span class='tstring_content'> field.</span><span class='tstring_end'>&quot;</span></span>
    <span class='kw'>end</span>

    <span class='kw'>if</span> <span class='id identifier rubyid_timestamp_field_path'>timestamp_field_path</span><span class='period'>.</span><span class='id identifier rubyid_type'>type</span><span class='period'>.</span><span class='id identifier rubyid_list?'>list?</span>
      <span class='id identifier rubyid_raise'>raise</span> <span class='const'>Errors</span><span class='op'>::</span><span class='const'>SchemaError</span><span class='comma'>,</span> <span class='tstring'><span class='tstring_beg'>&quot;</span><span class='tstring_content'>rollover field `</span><span class='embexpr_beg'>#{</span><span class='id identifier rubyid_timestamp_field_path'>timestamp_field_path</span><span class='period'>.</span><span class='id identifier rubyid_full_description'>full_description</span><span class='embexpr_end'>}</span><span class='tstring_content'>` cannot be used for rollover since it is a list field.</span><span class='tstring_end'>&quot;</span></span>
    <span class='kw'>end</span>

    <span class='id identifier rubyid_timestamp_field_path'>timestamp_field_path</span><span class='period'>.</span><span class='id identifier rubyid_path_parts'>path_parts</span><span class='period'>.</span><span class='id identifier rubyid_each'>each</span> <span class='lbrace'>{</span> <span class='op'>|</span><span class='id identifier rubyid_f'>f</span><span class='op'>|</span> <span class='id identifier rubyid_f'>f</span><span class='period'>.</span><span class='id identifier rubyid_json_schema'>json_schema</span> <span class='label'>nullable:</span> <span class='kw'>false</span> <span class='rbrace'>}</span>

    <span class='kw'>self</span><span class='period'>.</span><span class='id identifier rubyid_rollover_config'>rollover_config</span> <span class='op'>=</span> <span class='const'>RolloverConfig</span><span class='period'>.</span><span class='id identifier rubyid_new'>new</span><span class='lparen'>(</span>
      <span class='label'>frequency:</span> <span class='id identifier rubyid_frequency'>frequency</span><span class='comma'>,</span>
      <span class='label'>timestamp_field_path:</span> <span class='id identifier rubyid_timestamp_field_path'>timestamp_field_path</span>
    <span class='rparen'>)</span>
  <span class='kw'>end</span>

  <span class='comment'># Configures the index to [route documents to shards](https://www.elastic.co/guide/en/elasticsearch/reference/8.15/mapping-routing-field.html)
</span>  <span class='comment'># based on the specified field. ElasticGraph optimizes queries that filter on the shard routing field so that they only run on a
</span>  <span class='comment'># subset of nodes instead of all nodes. This can make a big difference in query performance if queries usually filter on a certain
</span>  <span class='comment'># field. Using an appropriate field for shard routing is often essential for horizontal scaling, as it avoids having every query
</span>  <span class='comment'># hit every node, allowing additional nodes to increase query throughput.
</span>  <span class='comment'>#
</span>  <span class='comment'># @note it is essential that the shards are well-balanced. If the data’s distribution is lopsided, using this feature can make
</span>  <span class='comment'>#   performance worse.
</span>  <span class='comment'># @note the routing field specified here **must be immutable**. If ElasticGraph receives an updated version of a document with a
</span>  <span class='comment'>#   different routing value, it’ll write the new version of the document to a different shard and leave the copy on the old shard
</span>  <span class='comment'>#   unchanged, leading to duplicates.
</span>  <span class='comment'># @note changing the shard routing configuration on an existing index that already has data will result in duplicate documents
</span>  <span class='comment'>#
</span>  <span class='comment'># @param routing_field_path_name [String] dot-separated path to the field used for shard routing. Note: all referenced
</span>  <span class='comment'>#   fields must exist when this is called.
</span>  <span class='comment'># @return [void]
</span>  <span class='comment'>#
</span>  <span class='comment'># @example Define a `campaigns` index to shard on `organizationId`
</span>  <span class='comment'>#   ElasticGraph.define_schema do |schema|
</span>  <span class='comment'>#     schema.object_type &quot;Campaign&quot; do |t|
</span>  <span class='comment'>#       t.field &quot;id&quot;, &quot;ID!&quot;
</span>  <span class='comment'>#       t.field &quot;name&quot;, &quot;String&quot;
</span>  <span class='comment'>#       t.field &quot;organizationId&quot;, &quot;ID&quot;
</span>  <span class='comment'>#
</span>  <span class='comment'>#       t.index &quot;campaigns&quot;do |i|
</span>  <span class='comment'>#         i.route_with &quot;organizationId&quot;
</span>  <span class='comment'>#       end
</span>  <span class='comment'>#     end
</span>  <span class='comment'>#   end
</span>  <span class='kw'>def</span> <span class='id identifier rubyid_route_with'>route_with</span><span class='lparen'>(</span><span class='id identifier rubyid_routing_field_path_name'>routing_field_path_name</span><span class='rparen'>)</span>
    <span class='id identifier rubyid_routing_field_path'>routing_field_path</span> <span class='op'>=</span> <span class='id identifier rubyid_public_field_path'>public_field_path</span><span class='lparen'>(</span><span class='id identifier rubyid_routing_field_path_name'>routing_field_path_name</span><span class='comma'>,</span> <span class='label'>explanation:</span> <span class='tstring'><span class='tstring_beg'>&quot;</span><span class='tstring_content'>it is referenced as an index `route_with` field</span><span class='tstring_end'>&quot;</span></span><span class='rparen'>)</span>

    <span class='kw'>unless</span> <span class='id identifier rubyid_routing_field_path'>routing_field_path</span><span class='period'>.</span><span class='id identifier rubyid_type'>type</span><span class='period'>.</span><span class='id identifier rubyid_leaf?'>leaf?</span>
      <span class='id identifier rubyid_raise'>raise</span> <span class='const'>Errors</span><span class='op'>::</span><span class='const'>SchemaError</span><span class='comma'>,</span> <span class='tstring'><span class='tstring_beg'>&quot;</span><span class='tstring_content'>shard routing field `</span><span class='embexpr_beg'>#{</span><span class='id identifier rubyid_routing_field_path'>routing_field_path</span><span class='period'>.</span><span class='id identifier rubyid_full_description'>full_description</span><span class='embexpr_end'>}</span><span class='tstring_content'>` cannot be used for routing since it is not a leaf field.</span><span class='tstring_end'>&quot;</span></span>
    <span class='kw'>end</span>

    <span class='kw'>self</span><span class='period'>.</span><span class='id identifier rubyid_routing_field_path'>routing_field_path</span> <span class='op'>=</span> <span class='id identifier rubyid_routing_field_path'>routing_field_path</span>

    <span class='id identifier rubyid_routing_field_path'>routing_field_path</span><span class='period'>.</span><span class='id identifier rubyid_path_parts'>path_parts</span><span class='lbracket'>[</span><span class='int'>0</span><span class='op'>..</span><span class='op'>-</span><span class='int'>2</span><span class='rbracket'>]</span><span class='period'>.</span><span class='id identifier rubyid_each'>each</span> <span class='lbrace'>{</span> <span class='op'>|</span><span class='id identifier rubyid_f'>f</span><span class='op'>|</span> <span class='id identifier rubyid_f'>f</span><span class='period'>.</span><span class='id identifier rubyid_json_schema'>json_schema</span> <span class='label'>nullable:</span> <span class='kw'>false</span> <span class='rbrace'>}</span>
    <span class='id identifier rubyid_routing_field_path'>routing_field_path</span><span class='period'>.</span><span class='id identifier rubyid_last_part'>last_part</span><span class='period'>.</span><span class='id identifier rubyid_json_schema'>json_schema</span> <span class='label'>nullable:</span> <span class='kw'>false</span><span class='comma'>,</span> <span class='label'>pattern:</span> <span class='const'>HAS_NON_WHITE_SPACE_REGEX</span>
    <span class='id identifier rubyid_indexed_type'>indexed_type</span><span class='period'>.</span><span class='id identifier rubyid_append_to_documentation'>append_to_documentation</span> <span class='tstring'><span class='tstring_beg'>&quot;</span><span class='tstring_content'>For more performant queries on this type, please filter on `</span><span class='embexpr_beg'>#{</span><span class='id identifier rubyid_routing_field_path_name'>routing_field_path_name</span><span class='embexpr_end'>}</span><span class='tstring_content'>` if possible.</span><span class='tstring_end'>&quot;</span></span>
  <span class='kw'>end</span>

  <span class='comment'># @see #route_with
</span>  <span class='comment'># @return [Boolean] whether or not this index uses custom shard routing
</span>  <span class='kw'>def</span> <span class='id identifier rubyid_uses_custom_routing?'>uses_custom_routing?</span>
    <span class='id identifier rubyid_routing_field_path'>routing_field_path</span><span class='period'>.</span><span class='id identifier rubyid_path_in_index'>path_in_index</span> <span class='op'>!=</span> <span class='tstring'><span class='tstring_beg'>&quot;</span><span class='tstring_content'>id</span><span class='tstring_end'>&quot;</span></span>
  <span class='kw'>end</span>

  <span class='comment'># @return [Hash&lt;String, Object&gt;] datastore configuration for this index for when it does not use rollover
</span>  <span class='kw'>def</span> <span class='id identifier rubyid_to_index_config'>to_index_config</span>
    <span class='lbrace'>{</span>
      <span class='tstring'><span class='tstring_beg'>&quot;</span><span class='tstring_content'>aliases</span><span class='tstring_end'>&quot;</span></span> <span class='op'>=&gt;</span> <span class='lbrace'>{</span><span class='rbrace'>}</span><span class='comma'>,</span>
      <span class='tstring'><span class='tstring_beg'>&quot;</span><span class='tstring_content'>mappings</span><span class='tstring_end'>&quot;</span></span> <span class='op'>=&gt;</span> <span class='id identifier rubyid_mappings'>mappings</span><span class='comma'>,</span>
      <span class='tstring'><span class='tstring_beg'>&quot;</span><span class='tstring_content'>settings</span><span class='tstring_end'>&quot;</span></span> <span class='op'>=&gt;</span> <span class='id identifier rubyid_settings'>settings</span>
    <span class='rbrace'>}</span><span class='period'>.</span><span class='id identifier rubyid_compact'>compact</span>
  <span class='kw'>end</span>

  <span class='comment'># @return [Hash&lt;String, Object&gt;] datastore configuration for the index template that will be defined if rollover is used
</span>  <span class='kw'>def</span> <span class='id identifier rubyid_to_index_template_config'>to_index_template_config</span>
    <span class='lbrace'>{</span>
      <span class='tstring'><span class='tstring_beg'>&quot;</span><span class='tstring_content'>index_patterns</span><span class='tstring_end'>&quot;</span></span> <span class='op'>=&gt;</span> <span class='lbracket'>[</span><span class='tstring'><span class='tstring_beg'>&quot;</span><span class='embexpr_beg'>#{</span><span class='id identifier rubyid_name'>name</span><span class='embexpr_end'>}</span><span class='embexpr_beg'>#{</span><span class='const'>ROLLOVER_INDEX_INFIX_MARKER</span><span class='embexpr_end'>}</span><span class='tstring_content'>*</span><span class='tstring_end'>&quot;</span></span><span class='rbracket'>]</span><span class='comma'>,</span>
      <span class='tstring'><span class='tstring_beg'>&quot;</span><span class='tstring_content'>template</span><span class='tstring_end'>&quot;</span></span> <span class='op'>=&gt;</span> <span class='lbrace'>{</span>
        <span class='tstring'><span class='tstring_beg'>&quot;</span><span class='tstring_content'>aliases</span><span class='tstring_end'>&quot;</span></span> <span class='op'>=&gt;</span> <span class='lbrace'>{</span><span class='rbrace'>}</span><span class='comma'>,</span>
        <span class='tstring'><span class='tstring_beg'>&quot;</span><span class='tstring_content'>mappings</span><span class='tstring_end'>&quot;</span></span> <span class='op'>=&gt;</span> <span class='id identifier rubyid_mappings'>mappings</span><span class='comma'>,</span>
        <span class='tstring'><span class='tstring_beg'>&quot;</span><span class='tstring_content'>settings</span><span class='tstring_end'>&quot;</span></span> <span class='op'>=&gt;</span> <span class='id identifier rubyid_settings'>settings</span>
      <span class='rbrace'>}</span>
    <span class='rbrace'>}</span>
  <span class='kw'>end</span>

  <span class='comment'># @return [SchemaArtifacts::RuntimeMetadata::IndexDefinition] runtime metadata for this index
</span>  <span class='kw'>def</span> <span class='id identifier rubyid_runtime_metadata'>runtime_metadata</span>
    <span class='const'>SchemaArtifacts</span><span class='op'>::</span><span class='const'>RuntimeMetadata</span><span class='op'>::</span><span class='const'>IndexDefinition</span><span class='period'>.</span><span class='id identifier rubyid_new'>new</span><span class='lparen'>(</span>
      <span class='label'>route_with:</span> <span class='id identifier rubyid_routing_field_path'>routing_field_path</span><span class='period'>.</span><span class='id identifier rubyid_path_in_index'>path_in_index</span><span class='comma'>,</span>
      <span class='label'>rollover:</span> <span class='id identifier rubyid_rollover_config'>rollover_config</span><span class='op'>&amp;.</span><span class='id identifier rubyid_runtime_metadata'>runtime_metadata</span><span class='comma'>,</span>
      <span class='label'>current_sources:</span> <span class='id identifier rubyid_indexed_type'>indexed_type</span><span class='period'>.</span><span class='id identifier rubyid_current_sources'>current_sources</span><span class='comma'>,</span>
      <span class='label'>fields_by_path:</span> <span class='id identifier rubyid_indexed_type'>indexed_type</span><span class='period'>.</span><span class='id identifier rubyid_index_field_runtime_metadata_tuples'>index_field_runtime_metadata_tuples</span><span class='period'>.</span><span class='id identifier rubyid_to_h'>to_h</span><span class='comma'>,</span>
      <span class='label'>default_sort_fields:</span> <span class='id identifier rubyid_default_sort_pairs'>default_sort_pairs</span><span class='period'>.</span><span class='id identifier rubyid_each_slice'>each_slice</span><span class='lparen'>(</span><span class='int'>2</span><span class='rparen'>)</span><span class='period'>.</span><span class='id identifier rubyid_map'>map</span> <span class='kw'>do</span> <span class='op'>|</span><span class='lparen'>(</span><span class='id identifier rubyid_graphql_field_path_name'>graphql_field_path_name</span><span class='comma'>,</span> <span class='id identifier rubyid_direction'>direction</span><span class='rparen'>)</span><span class='op'>|</span>
        <span class='const'>SchemaArtifacts</span><span class='op'>::</span><span class='const'>RuntimeMetadata</span><span class='op'>::</span><span class='const'>SortField</span><span class='period'>.</span><span class='id identifier rubyid_new'>new</span><span class='lparen'>(</span>
          <span class='label'>field_path:</span> <span class='id identifier rubyid_public_field_path'>public_field_path</span><span class='lparen'>(</span><span class='id identifier rubyid_graphql_field_path_name'>graphql_field_path_name</span><span class='comma'>,</span> <span class='label'>explanation:</span> <span class='tstring'><span class='tstring_beg'>&quot;</span><span class='tstring_content'>it is referenced as an index `default_sort` field</span><span class='tstring_end'>&quot;</span></span><span class='rparen'>)</span><span class='period'>.</span><span class='id identifier rubyid_path_in_index'>path_in_index</span><span class='comma'>,</span>
          <span class='label'>direction:</span> <span class='id identifier rubyid_direction'>direction</span>
        <span class='rparen'>)</span>
      <span class='kw'>end</span>
    <span class='rparen'>)</span>
  <span class='kw'>end</span>

  <span class='id identifier rubyid_private'>private</span>

  <span class='comment'># A regex that requires at least one non-whitespace character.
</span>  <span class='comment'># Note: this does not use the `/S` character class because it&#39;s recommended to use a small subset
</span>  <span class='comment'># of Regex syntax:
</span>  <span class='comment'>#
</span>  <span class='comment'># &gt; The regular expression syntax used is from JavaScript (ECMA 262, specifically). However, that
</span>  <span class='comment'># &gt; complete syntax is not widely supported, therefore it is recommended that you stick to the subset
</span>  <span class='comment'># &gt; of that syntax described below.
</span>  <span class='comment'>#
</span>  <span class='comment'># (From https://json-schema.org/understanding-json-schema/reference/regular_expressions.html)
</span>  <span class='const'>HAS_NON_WHITE_SPACE_REGEX</span> <span class='op'>=</span> <span class='tstring'><span class='tstring_beg'>&quot;</span><span class='tstring_content'>[^ \t\n]+</span><span class='tstring_end'>&quot;</span></span>

  <span class='const'>DEFAULT_SETTINGS</span> <span class='op'>=</span> <span class='lbrace'>{</span>
    <span class='tstring'><span class='tstring_beg'>&quot;</span><span class='tstring_content'>index.mapping.ignore_malformed</span><span class='tstring_end'>&quot;</span></span> <span class='op'>=&gt;</span> <span class='kw'>false</span><span class='comma'>,</span>
    <span class='tstring'><span class='tstring_beg'>&quot;</span><span class='tstring_content'>index.mapping.coerce</span><span class='tstring_end'>&quot;</span></span> <span class='op'>=&gt;</span> <span class='kw'>false</span><span class='comma'>,</span>
    <span class='tstring'><span class='tstring_beg'>&quot;</span><span class='tstring_content'>index.number_of_replicas</span><span class='tstring_end'>&quot;</span></span> <span class='op'>=&gt;</span> <span class='int'>1</span><span class='comma'>,</span>
    <span class='tstring'><span class='tstring_beg'>&quot;</span><span class='tstring_content'>index.number_of_shards</span><span class='tstring_end'>&quot;</span></span> <span class='op'>=&gt;</span> <span class='int'>1</span>
  <span class='rbrace'>}</span>

  <span class='kw'>def</span> <span class='id identifier rubyid_mappings'>mappings</span>
    <span class='id identifier rubyid_field_mappings'>field_mappings</span> <span class='op'>=</span> <span class='id identifier rubyid_indexed_type'>indexed_type</span>
      <span class='period'>.</span><span class='id identifier rubyid_to_indexing_field_type'>to_indexing_field_type</span>
      <span class='period'>.</span><span class='id identifier rubyid_to_mapping'>to_mapping</span>
      <span class='period'>.</span><span class='id identifier rubyid_except'>except</span><span class='lparen'>(</span><span class='tstring'><span class='tstring_beg'>&quot;</span><span class='tstring_content'>type</span><span class='tstring_end'>&quot;</span></span><span class='rparen'>)</span> <span class='comment'># `type` is invalid at the mapping root because it always has to be an object.
</span>      <span class='period'>.</span><span class='id identifier rubyid_then'>then</span> <span class='lbrace'>{</span> <span class='op'>|</span><span class='id identifier rubyid_mapping'>mapping</span><span class='op'>|</span> <span class='const'>ListCountsMapping</span><span class='period'>.</span><span class='id identifier rubyid_merged_into'>merged_into</span><span class='lparen'>(</span><span class='id identifier rubyid_mapping'>mapping</span><span class='comma'>,</span> <span class='label'>for_type:</span> <span class='id identifier rubyid_indexed_type'>indexed_type</span><span class='rparen'>)</span> <span class='rbrace'>}</span>
      <span class='period'>.</span><span class='id identifier rubyid_then'>then</span> <span class='kw'>do</span> <span class='op'>|</span><span class='id identifier rubyid_fm'>fm</span><span class='op'>|</span>
        <span class='const'><span class='object_link'><a href="../../Support.html" title="ElasticGraph::Support (module)">Support</a></span></span><span class='op'>::</span><span class='const'>HashUtil</span><span class='period'>.</span><span class='id identifier rubyid_deep_merge'>deep_merge</span><span class='lparen'>(</span><span class='id identifier rubyid_fm'>fm</span><span class='comma'>,</span> <span class='lbrace'>{</span><span class='tstring'><span class='tstring_beg'>&quot;</span><span class='tstring_content'>properties</span><span class='tstring_end'>&quot;</span></span> <span class='op'>=&gt;</span> <span class='lbrace'>{</span>
          <span class='tstring'><span class='tstring_beg'>&quot;</span><span class='tstring_content'>__sources</span><span class='tstring_end'>&quot;</span></span> <span class='op'>=&gt;</span> <span class='lbrace'>{</span><span class='tstring'><span class='tstring_beg'>&quot;</span><span class='tstring_content'>type</span><span class='tstring_end'>&quot;</span></span> <span class='op'>=&gt;</span> <span class='tstring'><span class='tstring_beg'>&quot;</span><span class='tstring_content'>keyword</span><span class='tstring_end'>&quot;</span></span><span class='rbrace'>}</span><span class='comma'>,</span>
          <span class='tstring'><span class='tstring_beg'>&quot;</span><span class='tstring_content'>__versions</span><span class='tstring_end'>&quot;</span></span> <span class='op'>=&gt;</span> <span class='lbrace'>{</span>
            <span class='tstring'><span class='tstring_beg'>&quot;</span><span class='tstring_content'>type</span><span class='tstring_end'>&quot;</span></span> <span class='op'>=&gt;</span> <span class='tstring'><span class='tstring_beg'>&quot;</span><span class='tstring_content'>object</span><span class='tstring_end'>&quot;</span></span><span class='comma'>,</span>
            <span class='comment'># __versions is map keyed by relationship name, with values that are maps keyed by id. Since it&#39;s not
</span>            <span class='comment'># a static object with known fields, we need to use dynamic here. Passing `false` allows some level
</span>            <span class='comment'># of dynamicness. As per https://www.elastic.co/guide/en/elasticsearch/reference/8.7/dynamic.html#dynamic-parameters:
</span>            <span class='comment'>#
</span>            <span class='comment'># &gt; New fields are ignored. These fields will not be indexed or searchable, but will still appear in the _source
</span>            <span class='comment'># &gt; field of returned hits. These fields will not be added to the mapping, and new fields must be added explicitly.
</span>            <span class='comment'>#
</span>            <span class='comment'># We need `__versions` to be in `_source` (so that our update scripts can operate on it), but
</span>            <span class='comment'># have no need for it to be searchable (as it&#39;s just an internal data structure used for indexing).
</span>            <span class='comment'>#
</span>            <span class='comment'># Note: we intentionally set false as a string here, because that&#39;s how the datastore echoes it back
</span>            <span class='comment'># to us when you query the mapping (even if you set it as a boolean). Our checks for index mapping
</span>            <span class='comment'># consistency fail validation if we set it as a boolean since the datastore doesn&#39;t echo it back as
</span>            <span class='comment'># a boolean.
</span>            <span class='tstring'><span class='tstring_beg'>&quot;</span><span class='tstring_content'>dynamic</span><span class='tstring_end'>&quot;</span></span> <span class='op'>=&gt;</span> <span class='tstring'><span class='tstring_beg'>&quot;</span><span class='tstring_content'>false</span><span class='tstring_end'>&quot;</span></span>
          <span class='rbrace'>}</span>
        <span class='rbrace'>}</span><span class='rbrace'>}</span><span class='rparen'>)</span>
      <span class='kw'>end</span>

    <span class='lbrace'>{</span><span class='tstring'><span class='tstring_beg'>&quot;</span><span class='tstring_content'>dynamic</span><span class='tstring_end'>&quot;</span></span> <span class='op'>=&gt;</span> <span class='tstring'><span class='tstring_beg'>&quot;</span><span class='tstring_content'>strict</span><span class='tstring_end'>&quot;</span></span><span class='rbrace'>}</span><span class='period'>.</span><span class='id identifier rubyid_merge'>merge</span><span class='lparen'>(</span><span class='id identifier rubyid_field_mappings'>field_mappings</span><span class='rparen'>)</span><span class='period'>.</span><span class='id identifier rubyid_tap'>tap</span> <span class='kw'>do</span> <span class='op'>|</span><span class='id identifier rubyid_hash'>hash</span><span class='op'>|</span>
      <span class='comment'># If we are using custom shard routing, we want to require a `routing` value to be provided
</span>      <span class='comment'># in every single index, get, delete or update request; otherwise the request might be
</span>      <span class='comment'># made against the wrong shard.
</span>      <span class='id identifier rubyid_hash'>hash</span><span class='lbracket'>[</span><span class='tstring'><span class='tstring_beg'>&quot;</span><span class='tstring_content'>_routing</span><span class='tstring_end'>&quot;</span></span><span class='rbracket'>]</span> <span class='op'>=</span> <span class='lbrace'>{</span><span class='tstring'><span class='tstring_beg'>&quot;</span><span class='tstring_content'>required</span><span class='tstring_end'>&quot;</span></span> <span class='op'>=&gt;</span> <span class='kw'>true</span><span class='rbrace'>}</span> <span class='kw'>if</span> <span class='id identifier rubyid_uses_custom_routing?'>uses_custom_routing?</span>
      <span class='id identifier rubyid_hash'>hash</span><span class='lbracket'>[</span><span class='tstring'><span class='tstring_beg'>&quot;</span><span class='tstring_content'>_size</span><span class='tstring_end'>&quot;</span></span><span class='rbracket'>]</span> <span class='op'>=</span> <span class='lbrace'>{</span><span class='tstring'><span class='tstring_beg'>&quot;</span><span class='tstring_content'>enabled</span><span class='tstring_end'>&quot;</span></span> <span class='op'>=&gt;</span> <span class='kw'>true</span><span class='rbrace'>}</span> <span class='kw'>if</span> <span class='id identifier rubyid_schema_def_state'>schema_def_state</span><span class='period'>.</span><span class='id identifier rubyid_index_document_sizes?'>index_document_sizes?</span>
    <span class='kw'>end</span>
  <span class='kw'>end</span>

  <span class='kw'>def</span> <span class='id identifier rubyid_public_field_path'>public_field_path</span><span class='lparen'>(</span><span class='id identifier rubyid_public_path_string'>public_path_string</span><span class='comma'>,</span> <span class='label'>explanation:</span><span class='rparen'>)</span>
    <span class='id identifier rubyid_parent_is_not_list'>parent_is_not_list</span> <span class='op'>=</span> <span class='tlambda'>-&gt;</span><span class='lparen'>(</span><span class='id identifier rubyid_parent_field'>parent_field</span><span class='rparen'>)</span> <span class='tlambeg'>{</span> <span class='op'>!</span><span class='id identifier rubyid_parent_field'>parent_field</span><span class='period'>.</span><span class='id identifier rubyid_type'>type</span><span class='period'>.</span><span class='id identifier rubyid_list?'>list?</span> <span class='rbrace'>}</span>
    <span class='id identifier rubyid_resolver'>resolver</span> <span class='op'>=</span> <span class='const'><span class='object_link'><a href="../SchemaElements.html" title="ElasticGraph::SchemaDefinition::SchemaElements (module)">SchemaElements</a></span></span><span class='op'>::</span><span class='const'>FieldPath</span><span class='op'>::</span><span class='const'>Resolver</span><span class='period'>.</span><span class='id identifier rubyid_new'>new</span>
    <span class='id identifier rubyid_resolved_path'>resolved_path</span> <span class='op'>=</span> <span class='id identifier rubyid_resolver'>resolver</span><span class='period'>.</span><span class='id identifier rubyid_resolve_public_path'>resolve_public_path</span><span class='lparen'>(</span><span class='id identifier rubyid_indexed_type'>indexed_type</span><span class='comma'>,</span> <span class='id identifier rubyid_public_path_string'>public_path_string</span><span class='comma'>,</span> <span class='op'>&amp;</span><span class='id identifier rubyid_parent_is_not_list'>parent_is_not_list</span><span class='rparen'>)</span>
    <span class='kw'>return</span> <span class='id identifier rubyid_resolved_path'>resolved_path</span> <span class='kw'>if</span> <span class='id identifier rubyid_resolved_path'>resolved_path</span>

    <span class='id identifier rubyid_path_parts'>path_parts</span> <span class='op'>=</span> <span class='id identifier rubyid_public_path_string'>public_path_string</span><span class='period'>.</span><span class='id identifier rubyid_split'>split</span><span class='lparen'>(</span><span class='tstring'><span class='tstring_beg'>&quot;</span><span class='tstring_content'>.</span><span class='tstring_end'>&quot;</span></span><span class='rparen'>)</span>
    <span class='id identifier rubyid_error_msg'>error_msg</span> <span class='op'>=</span> <span class='tstring'><span class='tstring_beg'>&quot;</span><span class='tstring_content'>Field `</span><span class='embexpr_beg'>#{</span><span class='id identifier rubyid_indexed_type'>indexed_type</span><span class='period'>.</span><span class='id identifier rubyid_name'>name</span><span class='embexpr_end'>}</span><span class='tstring_content'>.</span><span class='embexpr_beg'>#{</span><span class='id identifier rubyid_public_path_string'>public_path_string</span><span class='embexpr_end'>}</span><span class='tstring_content'>` cannot be resolved, but </span><span class='embexpr_beg'>#{</span><span class='id identifier rubyid_explanation'>explanation</span><span class='embexpr_end'>}</span><span class='tstring_content'>.</span><span class='tstring_end'>&quot;</span></span>

    <span class='comment'># If it is a nested field path, the problem could be that a type has been referenced which does not exist, so mention that.
</span>    <span class='kw'>if</span> <span class='id identifier rubyid_path_parts'>path_parts</span><span class='period'>.</span><span class='id identifier rubyid_size'>size</span> <span class='op'>&gt;</span> <span class='int'>1</span>
      <span class='id identifier rubyid_error_msg'>error_msg</span> <span class='op'>+=</span> <span class='tstring'><span class='tstring_beg'>&quot;</span><span class='tstring_content'> Verify that all fields and types referenced by `</span><span class='embexpr_beg'>#{</span><span class='id identifier rubyid_public_path_string'>public_path_string</span><span class='embexpr_end'>}</span><span class='tstring_content'>` are defined.</span><span class='tstring_end'>&quot;</span></span>
    <span class='kw'>end</span>

    <span class='comment'># If the first part of the path doesn&#39;t resolve, the problem could be that the field is defined after the `index` call
</span>    <span class='comment'># but it needs to be defined before it, so mention that.
</span>    <span class='kw'>if</span> <span class='id identifier rubyid_resolver'>resolver</span><span class='period'>.</span><span class='id identifier rubyid_resolve_public_path'>resolve_public_path</span><span class='lparen'>(</span><span class='id identifier rubyid_indexed_type'>indexed_type</span><span class='comma'>,</span> <span class='id identifier rubyid_path_parts'>path_parts</span><span class='period'>.</span><span class='id identifier rubyid_first'>first</span><span class='comma'>,</span> <span class='op'>&amp;</span><span class='id identifier rubyid_parent_is_not_list'>parent_is_not_list</span><span class='rparen'>)</span><span class='period'>.</span><span class='id identifier rubyid_nil?'>nil?</span>
      <span class='id identifier rubyid_error_msg'>error_msg</span> <span class='op'>+=</span> <span class='tstring'><span class='tstring_beg'>&quot;</span><span class='tstring_content'> Note: the `</span><span class='embexpr_beg'>#{</span><span class='id identifier rubyid_indexed_type'>indexed_type</span><span class='period'>.</span><span class='id identifier rubyid_name'>name</span><span class='embexpr_end'>}</span><span class='tstring_content'>.</span><span class='embexpr_beg'>#{</span><span class='id identifier rubyid_path_parts'>path_parts</span><span class='period'>.</span><span class='id identifier rubyid_first'>first</span><span class='embexpr_end'>}</span><span class='tstring_content'>` definition must come before the `index` call.</span><span class='tstring_end'>&quot;</span></span>
    <span class='kw'>end</span>

    <span class='id identifier rubyid_raise'>raise</span> <span class='const'>Errors</span><span class='op'>::</span><span class='const'>SchemaError</span><span class='comma'>,</span> <span class='id identifier rubyid_error_msg'>error_msg</span>
  <span class='kw'>end</span>

  <span class='kw'>def</span> <span class='id identifier rubyid_date_and_datetime_types'>date_and_datetime_types</span>
    <span class='ivar'>@date_and_datetime_types</span> <span class='op'>||=</span> <span class='qwords_beg'>%w[</span><span class='tstring_content'>Date</span><span class='words_sep'> </span><span class='tstring_content'>DateTime</span><span class='tstring_end'>]</span></span><span class='period'>.</span><span class='id identifier rubyid_map'>map</span> <span class='kw'>do</span> <span class='op'>|</span><span class='id identifier rubyid_type'>type</span><span class='op'>|</span>
      <span class='id identifier rubyid_schema_def_state'>schema_def_state</span><span class='period'>.</span><span class='id identifier rubyid_type_namer'>type_namer</span><span class='period'>.</span><span class='id identifier rubyid_name_for'>name_for</span><span class='lparen'>(</span><span class='id identifier rubyid_type'>type</span><span class='rparen'>)</span>
    <span class='kw'>end</span>
  <span class='kw'>end</span>
<span class='kw'>end</span></pre>
    </td>
  </tr>
</table>
</div>
    
  </div>


  <div id="instance_method_details" class="method_details_list">
    <h2>Instance Method Details</h2>

    
      <div class="method_details first">
  <h3 class="signature first" id="default_sort-instance_method">
  
    #<strong>default_sort</strong>(*field_name_direction_pairs)  &#x21d2; <tt>void</tt> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    
  <div class="note notetag">
    <strong>Note:</strong>
    <div class='inline'><p>the field name strings can be a dot-separated nested fields, but all referenced
fields must exist when this is called.</p>
</div>
  </div>

<p class="note returns_void">This method returns an undefined value.</p><p>Specifies how documents in this index should sort by default, when no <code>orderBy</code> argument is provided to the GraphQL query.</p>


  </div>
</div>
<div class="tags">
  
  <div class="examples">
    <h4 class="tag_title">Examples:</h4>
    
      
        <h5 class="example_title"><div class='inline'><p>Sort on <code>name</code> (ascending) with <code>createdAt</code> (descending) as a tie-breaker</p>
</div></h5>
      
      <pre class="example code"><code><span class='const'><span class='object_link'><a href="../../../ElasticGraph.html" title="ElasticGraph (module)">ElasticGraph</a></span></span><span class='period'>.</span><span class='id identifier rubyid_define_schema'><span class='object_link'><a href="../../../ElasticGraph.html#define_schema-class_method" title="ElasticGraph.define_schema (method)">define_schema</a></span></span> <span class='kw'>do</span> <span class='op'>|</span><span class='id identifier rubyid_schema'>schema</span><span class='op'>|</span>
  <span class='id identifier rubyid_schema'>schema</span><span class='period'>.</span><span class='id identifier rubyid_object_type'>object_type</span> <span class='tstring'><span class='tstring_beg'>&quot;</span><span class='tstring_content'>Campaign</span><span class='tstring_end'>&quot;</span></span> <span class='kw'>do</span> <span class='op'>|</span><span class='id identifier rubyid_t'>t</span><span class='op'>|</span>
    <span class='id identifier rubyid_t'>t</span><span class='period'>.</span><span class='id identifier rubyid_field'>field</span> <span class='tstring'><span class='tstring_beg'>&quot;</span><span class='tstring_content'>id</span><span class='tstring_end'>&quot;</span></span><span class='comma'>,</span> <span class='tstring'><span class='tstring_beg'>&quot;</span><span class='tstring_content'>ID!</span><span class='tstring_end'>&quot;</span></span>
    <span class='id identifier rubyid_t'>t</span><span class='period'>.</span><span class='id identifier rubyid_field'>field</span> <span class='tstring'><span class='tstring_beg'>&quot;</span><span class='tstring_content'>name</span><span class='tstring_end'>&quot;</span></span><span class='comma'>,</span> <span class='tstring'><span class='tstring_beg'>&quot;</span><span class='tstring_content'>String</span><span class='tstring_end'>&quot;</span></span>
    <span class='id identifier rubyid_t'>t</span><span class='period'>.</span><span class='id identifier rubyid_field'>field</span> <span class='tstring'><span class='tstring_beg'>&quot;</span><span class='tstring_content'>createdAt</span><span class='tstring_end'>&quot;</span></span><span class='comma'>,</span> <span class='tstring'><span class='tstring_beg'>&quot;</span><span class='tstring_content'>DateTime</span><span class='tstring_end'>&quot;</span></span>

    <span class='id identifier rubyid_t'>t</span><span class='period'>.</span><span class='id identifier rubyid_index'>index</span> <span class='tstring'><span class='tstring_beg'>&quot;</span><span class='tstring_content'>campaigns</span><span class='tstring_end'>&quot;</span></span><span class='kw'>do</span> <span class='op'>|</span><span class='id identifier rubyid_i'>i</span><span class='op'>|</span>
      <span class='id identifier rubyid_i'>i</span><span class='period'>.</span><span class='id identifier rubyid_default_sort'>default_sort</span> <span class='tstring'><span class='tstring_beg'>&quot;</span><span class='tstring_content'>name</span><span class='tstring_end'>&quot;</span></span><span class='comma'>,</span> <span class='symbol'>:asc</span><span class='comma'>,</span> <span class='tstring'><span class='tstring_beg'>&quot;</span><span class='tstring_content'>createdAt</span><span class='tstring_end'>&quot;</span></span><span class='comma'>,</span> <span class='symbol'>:desc</span>
    <span class='kw'>end</span>
  <span class='kw'>end</span>
<span class='kw'>end</span></code></pre>
    
  </div>
<p class="tag_title">Parameters:</p>
<ul class="param">
  
    <li>
      
        <span class='name'>field_name_direction_pairs</span>
      
      
        <span class='type'>(<tt>Array&lt;(String, Symbol)&gt;</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>pairs of field names and <code>:asc</code> or <code>:desc</code></p>
</div>
      
    </li>
  
</ul>


</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


88
89
90</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'elasticgraph-schema_definition/lib/elastic_graph/schema_definition/indexing/index.rb', line 88</span>

<span class='kw'>def</span> <span class='id identifier rubyid_default_sort'>default_sort</span><span class='lparen'>(</span><span class='op'>*</span><span class='id identifier rubyid_field_name_direction_pairs'>field_name_direction_pairs</span><span class='rparen'>)</span>
  <span class='kw'>self</span><span class='period'>.</span><span class='id identifier rubyid_default_sort_pairs'>default_sort_pairs</span> <span class='op'>=</span> <span class='id identifier rubyid_field_name_direction_pairs'>field_name_direction_pairs</span>
<span class='kw'>end</span></pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="rollover-instance_method">
  
    #<strong>rollover</strong>(frequency, timestamp_field_path_name)  &#x21d2; <tt>void</tt> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    
  <div class="note notetag">
    <strong>Note:</strong>
    <div class='inline'><p>the timestamp field specified here <strong>must be immutable</strong>. To understand why, consider a <code>:yearly</code> rollover
index used for data based on <code>createdAt</code>; if ElasticGraph ingests record <code>123</code> with a createdAt of <code>2023-12-31T23:59:59Z</code>, it
will be indexed in the <code>2023</code> index. Later if it receives an update event for record <code>123</code> with a <code>createdAt</code> of
<code>2024-01-01T00:00:00Z</code> (a mere one second later!), ElasticGraph will store the new version of the payment in the <code>2024</code> index,
and leave the old copy of the payment in the <code>2023</code> index unchanged. It’ll have duplicates for that document.</p>
</div>
  </div>

  <div class="note notetag">
    <strong>Note:</strong>
    <div class='inline'><p>changing the <code>rollover</code> configuration on an existing index that already has data will result in duplicate documents</p>
</div>
  </div>

<p class="note returns_void">This method returns an undefined value.</p><p>Causes this index to “rollover” at the provided <code>frequency</code> based on the value of the provided <code>timestamp_field_path_name</code>.
This is particularly useful for time-series data. Partitioning the data into <code>hourly</code>, <code>daily</code>, <code>monthly</code> or <code>yearly</code> buckets
allows for different index configurations, and can be necessary when a dataset is too large to fit in one dataset given
Elasticsearch/OpenSearch limitations on the number of shards in one index. In addition, ElasticGraph optimizes queries which
filter on the timestamp field to target the subset of the indices in which matching documents could reside.</p>


  </div>
</div>
<div class="tags">
  
  <div class="examples">
    <h4 class="tag_title">Examples:</h4>
    
      
        <h5 class="example_title"><div class='inline'><p>Define a <code>campaigns</code> index to rollover yearly based on <code>createdAt</code></p>
</div></h5>
      
      <pre class="example code"><code><span class='const'><span class='object_link'><a href="../../../ElasticGraph.html" title="ElasticGraph (module)">ElasticGraph</a></span></span><span class='period'>.</span><span class='id identifier rubyid_define_schema'><span class='object_link'><a href="../../../ElasticGraph.html#define_schema-class_method" title="ElasticGraph.define_schema (method)">define_schema</a></span></span> <span class='kw'>do</span> <span class='op'>|</span><span class='id identifier rubyid_schema'>schema</span><span class='op'>|</span>
  <span class='id identifier rubyid_schema'>schema</span><span class='period'>.</span><span class='id identifier rubyid_object_type'>object_type</span> <span class='tstring'><span class='tstring_beg'>&quot;</span><span class='tstring_content'>Campaign</span><span class='tstring_end'>&quot;</span></span> <span class='kw'>do</span> <span class='op'>|</span><span class='id identifier rubyid_t'>t</span><span class='op'>|</span>
    <span class='id identifier rubyid_t'>t</span><span class='period'>.</span><span class='id identifier rubyid_field'>field</span> <span class='tstring'><span class='tstring_beg'>&quot;</span><span class='tstring_content'>id</span><span class='tstring_end'>&quot;</span></span><span class='comma'>,</span> <span class='tstring'><span class='tstring_beg'>&quot;</span><span class='tstring_content'>ID!</span><span class='tstring_end'>&quot;</span></span>
    <span class='id identifier rubyid_t'>t</span><span class='period'>.</span><span class='id identifier rubyid_field'>field</span> <span class='tstring'><span class='tstring_beg'>&quot;</span><span class='tstring_content'>name</span><span class='tstring_end'>&quot;</span></span><span class='comma'>,</span> <span class='tstring'><span class='tstring_beg'>&quot;</span><span class='tstring_content'>String</span><span class='tstring_end'>&quot;</span></span>
    <span class='id identifier rubyid_t'>t</span><span class='period'>.</span><span class='id identifier rubyid_field'>field</span> <span class='tstring'><span class='tstring_beg'>&quot;</span><span class='tstring_content'>createdAt</span><span class='tstring_end'>&quot;</span></span><span class='comma'>,</span> <span class='tstring'><span class='tstring_beg'>&quot;</span><span class='tstring_content'>DateTime</span><span class='tstring_end'>&quot;</span></span>

    <span class='id identifier rubyid_t'>t</span><span class='period'>.</span><span class='id identifier rubyid_index'>index</span> <span class='tstring'><span class='tstring_beg'>&quot;</span><span class='tstring_content'>campaigns</span><span class='tstring_end'>&quot;</span></span><span class='kw'>do</span> <span class='op'>|</span><span class='id identifier rubyid_i'>i</span><span class='op'>|</span>
      <span class='id identifier rubyid_i'>i</span><span class='period'>.</span><span class='id identifier rubyid_rollover'>rollover</span> <span class='symbol'>:yearly</span><span class='comma'>,</span> <span class='tstring'><span class='tstring_beg'>&quot;</span><span class='tstring_content'>createdAt</span><span class='tstring_end'>&quot;</span></span>
    <span class='kw'>end</span>
  <span class='kw'>end</span>
<span class='kw'>end</span></code></pre>
    
  </div>
<p class="tag_title">Parameters:</p>
<ul class="param">
  
    <li>
      
        <span class='name'>frequency</span>
      
      
        <span class='type'>(<tt>:yearly</tt>, <tt>:monthly</tt>, <tt>:daily</tt>, <tt>:hourly</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>how often to rollover the index</p>
</div>
      
    </li>
  
    <li>
      
        <span class='name'>timestamp_field_path_name</span>
      
      
        <span class='type'>(<tt>String</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>dot-separated path to the timestamp field used for rollover. Note: all referenced
fields must exist when this is called.</p>
</div>
      
    </li>
  
</ul>


</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


122
123
124
125
126
127
128
129
130
131
132
133
134
135
136
137
138
139
140</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'elasticgraph-schema_definition/lib/elastic_graph/schema_definition/indexing/index.rb', line 122</span>

<span class='kw'>def</span> <span class='id identifier rubyid_rollover'>rollover</span><span class='lparen'>(</span><span class='id identifier rubyid_frequency'>frequency</span><span class='comma'>,</span> <span class='id identifier rubyid_timestamp_field_path_name'>timestamp_field_path_name</span><span class='rparen'>)</span>
  <span class='id identifier rubyid_timestamp_field_path'>timestamp_field_path</span> <span class='op'>=</span> <span class='id identifier rubyid_public_field_path'>public_field_path</span><span class='lparen'>(</span><span class='id identifier rubyid_timestamp_field_path_name'>timestamp_field_path_name</span><span class='comma'>,</span> <span class='label'>explanation:</span> <span class='tstring'><span class='tstring_beg'>&quot;</span><span class='tstring_content'>it is referenced as an index `rollover` field</span><span class='tstring_end'>&quot;</span></span><span class='rparen'>)</span>

  <span class='kw'>unless</span> <span class='id identifier rubyid_date_and_datetime_types'>date_and_datetime_types</span><span class='period'>.</span><span class='id identifier rubyid_include?'>include?</span><span class='lparen'>(</span><span class='id identifier rubyid_timestamp_field_path'>timestamp_field_path</span><span class='period'>.</span><span class='id identifier rubyid_type'>type</span><span class='period'>.</span><span class='id identifier rubyid_fully_unwrapped'>fully_unwrapped</span><span class='period'>.</span><span class='id identifier rubyid_name'>name</span><span class='rparen'>)</span>
    <span class='id identifier rubyid_date_or_datetime_description'>date_or_datetime_description</span> <span class='op'>=</span> <span class='id identifier rubyid_date_and_datetime_types'>date_and_datetime_types</span><span class='period'>.</span><span class='id identifier rubyid_map'>map</span> <span class='lbrace'>{</span> <span class='op'>|</span><span class='id identifier rubyid_t'>t</span><span class='op'>|</span> <span class='tstring'><span class='tstring_beg'>&quot;</span><span class='tstring_content'>`</span><span class='embexpr_beg'>#{</span><span class='id identifier rubyid_t'>t</span><span class='embexpr_end'>}</span><span class='tstring_content'>`</span><span class='tstring_end'>&quot;</span></span> <span class='rbrace'>}</span><span class='period'>.</span><span class='id identifier rubyid_join'>join</span><span class='lparen'>(</span><span class='tstring'><span class='tstring_beg'>&quot;</span><span class='tstring_content'> or </span><span class='tstring_end'>&quot;</span></span><span class='rparen'>)</span>
    <span class='id identifier rubyid_raise'>raise</span> <span class='const'>Errors</span><span class='op'>::</span><span class='const'>SchemaError</span><span class='comma'>,</span> <span class='tstring'><span class='tstring_beg'>&quot;</span><span class='tstring_content'>rollover field `</span><span class='embexpr_beg'>#{</span><span class='id identifier rubyid_timestamp_field_path'>timestamp_field_path</span><span class='period'>.</span><span class='id identifier rubyid_full_description'>full_description</span><span class='embexpr_end'>}</span><span class='tstring_content'>` cannot be used for rollover since it is not a </span><span class='embexpr_beg'>#{</span><span class='id identifier rubyid_date_or_datetime_description'>date_or_datetime_description</span><span class='embexpr_end'>}</span><span class='tstring_content'> field.</span><span class='tstring_end'>&quot;</span></span>
  <span class='kw'>end</span>

  <span class='kw'>if</span> <span class='id identifier rubyid_timestamp_field_path'>timestamp_field_path</span><span class='period'>.</span><span class='id identifier rubyid_type'>type</span><span class='period'>.</span><span class='id identifier rubyid_list?'>list?</span>
    <span class='id identifier rubyid_raise'>raise</span> <span class='const'>Errors</span><span class='op'>::</span><span class='const'>SchemaError</span><span class='comma'>,</span> <span class='tstring'><span class='tstring_beg'>&quot;</span><span class='tstring_content'>rollover field `</span><span class='embexpr_beg'>#{</span><span class='id identifier rubyid_timestamp_field_path'>timestamp_field_path</span><span class='period'>.</span><span class='id identifier rubyid_full_description'>full_description</span><span class='embexpr_end'>}</span><span class='tstring_content'>` cannot be used for rollover since it is a list field.</span><span class='tstring_end'>&quot;</span></span>
  <span class='kw'>end</span>

  <span class='id identifier rubyid_timestamp_field_path'>timestamp_field_path</span><span class='period'>.</span><span class='id identifier rubyid_path_parts'>path_parts</span><span class='period'>.</span><span class='id identifier rubyid_each'>each</span> <span class='lbrace'>{</span> <span class='op'>|</span><span class='id identifier rubyid_f'>f</span><span class='op'>|</span> <span class='id identifier rubyid_f'>f</span><span class='period'>.</span><span class='id identifier rubyid_json_schema'>json_schema</span> <span class='label'>nullable:</span> <span class='kw'>false</span> <span class='rbrace'>}</span>

  <span class='kw'>self</span><span class='period'>.</span><span class='id identifier rubyid_rollover_config'>rollover_config</span> <span class='op'>=</span> <span class='const'>RolloverConfig</span><span class='period'>.</span><span class='id identifier rubyid_new'>new</span><span class='lparen'>(</span>
    <span class='label'>frequency:</span> <span class='id identifier rubyid_frequency'>frequency</span><span class='comma'>,</span>
    <span class='label'>timestamp_field_path:</span> <span class='id identifier rubyid_timestamp_field_path'>timestamp_field_path</span>
  <span class='rparen'>)</span>
<span class='kw'>end</span></pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="route_with-instance_method">
  
    #<strong>route_with</strong>(routing_field_path_name)  &#x21d2; <tt>void</tt> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    
  <div class="note notetag">
    <strong>Note:</strong>
    <div class='inline'><p>it is essential that the shards are well-balanced. If the data’s distribution is lopsided, using this feature can make
performance worse.</p>
</div>
  </div>

  <div class="note notetag">
    <strong>Note:</strong>
    <div class='inline'><p>the routing field specified here <strong>must be immutable</strong>. If ElasticGraph receives an updated version of a document with a
different routing value, it’ll write the new version of the document to a different shard and leave the copy on the old shard
unchanged, leading to duplicates.</p>
</div>
  </div>

  <div class="note notetag">
    <strong>Note:</strong>
    <div class='inline'><p>changing the shard routing configuration on an existing index that already has data will result in duplicate documents</p>
</div>
  </div>

<p class="note returns_void">This method returns an undefined value.</p><p>Configures the index to <a href="https://www.elastic.co/guide/en/elasticsearch/reference/8.15/mapping-routing-field.html">route documents to shards</a>
based on the specified field. ElasticGraph optimizes queries that filter on the shard routing field so that they only run on a
subset of nodes instead of all nodes. This can make a big difference in query performance if queries usually filter on a certain
field. Using an appropriate field for shard routing is often essential for horizontal scaling, as it avoids having every query
hit every node, allowing additional nodes to increase query throughput.</p>


  </div>
</div>
<div class="tags">
  
  <div class="examples">
    <h4 class="tag_title">Examples:</h4>
    
      
        <h5 class="example_title"><div class='inline'><p>Define a <code>campaigns</code> index to shard on <code>organizationId</code></p>
</div></h5>
      
      <pre class="example code"><code><span class='const'><span class='object_link'><a href="../../../ElasticGraph.html" title="ElasticGraph (module)">ElasticGraph</a></span></span><span class='period'>.</span><span class='id identifier rubyid_define_schema'><span class='object_link'><a href="../../../ElasticGraph.html#define_schema-class_method" title="ElasticGraph.define_schema (method)">define_schema</a></span></span> <span class='kw'>do</span> <span class='op'>|</span><span class='id identifier rubyid_schema'>schema</span><span class='op'>|</span>
  <span class='id identifier rubyid_schema'>schema</span><span class='period'>.</span><span class='id identifier rubyid_object_type'>object_type</span> <span class='tstring'><span class='tstring_beg'>&quot;</span><span class='tstring_content'>Campaign</span><span class='tstring_end'>&quot;</span></span> <span class='kw'>do</span> <span class='op'>|</span><span class='id identifier rubyid_t'>t</span><span class='op'>|</span>
    <span class='id identifier rubyid_t'>t</span><span class='period'>.</span><span class='id identifier rubyid_field'>field</span> <span class='tstring'><span class='tstring_beg'>&quot;</span><span class='tstring_content'>id</span><span class='tstring_end'>&quot;</span></span><span class='comma'>,</span> <span class='tstring'><span class='tstring_beg'>&quot;</span><span class='tstring_content'>ID!</span><span class='tstring_end'>&quot;</span></span>
    <span class='id identifier rubyid_t'>t</span><span class='period'>.</span><span class='id identifier rubyid_field'>field</span> <span class='tstring'><span class='tstring_beg'>&quot;</span><span class='tstring_content'>name</span><span class='tstring_end'>&quot;</span></span><span class='comma'>,</span> <span class='tstring'><span class='tstring_beg'>&quot;</span><span class='tstring_content'>String</span><span class='tstring_end'>&quot;</span></span>
    <span class='id identifier rubyid_t'>t</span><span class='period'>.</span><span class='id identifier rubyid_field'>field</span> <span class='tstring'><span class='tstring_beg'>&quot;</span><span class='tstring_content'>organizationId</span><span class='tstring_end'>&quot;</span></span><span class='comma'>,</span> <span class='tstring'><span class='tstring_beg'>&quot;</span><span class='tstring_content'>ID</span><span class='tstring_end'>&quot;</span></span>

    <span class='id identifier rubyid_t'>t</span><span class='period'>.</span><span class='id identifier rubyid_index'>index</span> <span class='tstring'><span class='tstring_beg'>&quot;</span><span class='tstring_content'>campaigns</span><span class='tstring_end'>&quot;</span></span><span class='kw'>do</span> <span class='op'>|</span><span class='id identifier rubyid_i'>i</span><span class='op'>|</span>
      <span class='id identifier rubyid_i'>i</span><span class='period'>.</span><span class='id identifier rubyid_route_with'>route_with</span> <span class='tstring'><span class='tstring_beg'>&quot;</span><span class='tstring_content'>organizationId</span><span class='tstring_end'>&quot;</span></span>
    <span class='kw'>end</span>
  <span class='kw'>end</span>
<span class='kw'>end</span></code></pre>
    
  </div>
<p class="tag_title">Parameters:</p>
<ul class="param">
  
    <li>
      
        <span class='name'>routing_field_path_name</span>
      
      
        <span class='type'>(<tt>String</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>dot-separated path to the field used for shard routing. Note: all referenced
fields must exist when this is called.</p>
</div>
      
    </li>
  
</ul>


</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


171
172
173
174
175
176
177
178
179
180
181
182
183</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'elasticgraph-schema_definition/lib/elastic_graph/schema_definition/indexing/index.rb', line 171</span>

<span class='kw'>def</span> <span class='id identifier rubyid_route_with'>route_with</span><span class='lparen'>(</span><span class='id identifier rubyid_routing_field_path_name'>routing_field_path_name</span><span class='rparen'>)</span>
  <span class='id identifier rubyid_routing_field_path'>routing_field_path</span> <span class='op'>=</span> <span class='id identifier rubyid_public_field_path'>public_field_path</span><span class='lparen'>(</span><span class='id identifier rubyid_routing_field_path_name'>routing_field_path_name</span><span class='comma'>,</span> <span class='label'>explanation:</span> <span class='tstring'><span class='tstring_beg'>&quot;</span><span class='tstring_content'>it is referenced as an index `route_with` field</span><span class='tstring_end'>&quot;</span></span><span class='rparen'>)</span>

  <span class='kw'>unless</span> <span class='id identifier rubyid_routing_field_path'>routing_field_path</span><span class='period'>.</span><span class='id identifier rubyid_type'>type</span><span class='period'>.</span><span class='id identifier rubyid_leaf?'>leaf?</span>
    <span class='id identifier rubyid_raise'>raise</span> <span class='const'>Errors</span><span class='op'>::</span><span class='const'>SchemaError</span><span class='comma'>,</span> <span class='tstring'><span class='tstring_beg'>&quot;</span><span class='tstring_content'>shard routing field `</span><span class='embexpr_beg'>#{</span><span class='id identifier rubyid_routing_field_path'>routing_field_path</span><span class='period'>.</span><span class='id identifier rubyid_full_description'>full_description</span><span class='embexpr_end'>}</span><span class='tstring_content'>` cannot be used for routing since it is not a leaf field.</span><span class='tstring_end'>&quot;</span></span>
  <span class='kw'>end</span>

  <span class='kw'>self</span><span class='period'>.</span><span class='id identifier rubyid_routing_field_path'>routing_field_path</span> <span class='op'>=</span> <span class='id identifier rubyid_routing_field_path'>routing_field_path</span>

  <span class='id identifier rubyid_routing_field_path'>routing_field_path</span><span class='period'>.</span><span class='id identifier rubyid_path_parts'>path_parts</span><span class='lbracket'>[</span><span class='int'>0</span><span class='op'>..</span><span class='op'>-</span><span class='int'>2</span><span class='rbracket'>]</span><span class='period'>.</span><span class='id identifier rubyid_each'>each</span> <span class='lbrace'>{</span> <span class='op'>|</span><span class='id identifier rubyid_f'>f</span><span class='op'>|</span> <span class='id identifier rubyid_f'>f</span><span class='period'>.</span><span class='id identifier rubyid_json_schema'>json_schema</span> <span class='label'>nullable:</span> <span class='kw'>false</span> <span class='rbrace'>}</span>
  <span class='id identifier rubyid_routing_field_path'>routing_field_path</span><span class='period'>.</span><span class='id identifier rubyid_last_part'>last_part</span><span class='period'>.</span><span class='id identifier rubyid_json_schema'>json_schema</span> <span class='label'>nullable:</span> <span class='kw'>false</span><span class='comma'>,</span> <span class='label'>pattern:</span> <span class='const'>HAS_NON_WHITE_SPACE_REGEX</span>
  <span class='id identifier rubyid_indexed_type'>indexed_type</span><span class='period'>.</span><span class='id identifier rubyid_append_to_documentation'>append_to_documentation</span> <span class='tstring'><span class='tstring_beg'>&quot;</span><span class='tstring_content'>For more performant queries on this type, please filter on `</span><span class='embexpr_beg'>#{</span><span class='id identifier rubyid_routing_field_path_name'>routing_field_path_name</span><span class='embexpr_end'>}</span><span class='tstring_content'>` if possible.</span><span class='tstring_end'>&quot;</span></span>
<span class='kw'>end</span></pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="runtime_metadata-instance_method">
  
    #<strong>runtime_metadata</strong>  &#x21d2; <tt>SchemaArtifacts::RuntimeMetadata::IndexDefinition</tt> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    <p>Returns runtime metadata for this index.</p>


  </div>
</div>
<div class="tags">
  
<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt>SchemaArtifacts::RuntimeMetadata::IndexDefinition</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>runtime metadata for this index</p>
</div>
      
    </li>
  
</ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


213
214
215
216
217
218
219
220
221
222
223
224
225
226</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'elasticgraph-schema_definition/lib/elastic_graph/schema_definition/indexing/index.rb', line 213</span>

<span class='kw'>def</span> <span class='id identifier rubyid_runtime_metadata'>runtime_metadata</span>
  <span class='const'>SchemaArtifacts</span><span class='op'>::</span><span class='const'>RuntimeMetadata</span><span class='op'>::</span><span class='const'>IndexDefinition</span><span class='period'>.</span><span class='id identifier rubyid_new'>new</span><span class='lparen'>(</span>
    <span class='label'>route_with:</span> <span class='id identifier rubyid_routing_field_path'>routing_field_path</span><span class='period'>.</span><span class='id identifier rubyid_path_in_index'>path_in_index</span><span class='comma'>,</span>
    <span class='label'>rollover:</span> <span class='id identifier rubyid_rollover_config'>rollover_config</span><span class='op'>&amp;.</span><span class='id identifier rubyid_runtime_metadata'>runtime_metadata</span><span class='comma'>,</span>
    <span class='label'>current_sources:</span> <span class='id identifier rubyid_indexed_type'>indexed_type</span><span class='period'>.</span><span class='id identifier rubyid_current_sources'>current_sources</span><span class='comma'>,</span>
    <span class='label'>fields_by_path:</span> <span class='id identifier rubyid_indexed_type'>indexed_type</span><span class='period'>.</span><span class='id identifier rubyid_index_field_runtime_metadata_tuples'>index_field_runtime_metadata_tuples</span><span class='period'>.</span><span class='id identifier rubyid_to_h'>to_h</span><span class='comma'>,</span>
    <span class='label'>default_sort_fields:</span> <span class='id identifier rubyid_default_sort_pairs'>default_sort_pairs</span><span class='period'>.</span><span class='id identifier rubyid_each_slice'>each_slice</span><span class='lparen'>(</span><span class='int'>2</span><span class='rparen'>)</span><span class='period'>.</span><span class='id identifier rubyid_map'>map</span> <span class='kw'>do</span> <span class='op'>|</span><span class='lparen'>(</span><span class='id identifier rubyid_graphql_field_path_name'>graphql_field_path_name</span><span class='comma'>,</span> <span class='id identifier rubyid_direction'>direction</span><span class='rparen'>)</span><span class='op'>|</span>
      <span class='const'>SchemaArtifacts</span><span class='op'>::</span><span class='const'>RuntimeMetadata</span><span class='op'>::</span><span class='const'>SortField</span><span class='period'>.</span><span class='id identifier rubyid_new'>new</span><span class='lparen'>(</span>
        <span class='label'>field_path:</span> <span class='id identifier rubyid_public_field_path'>public_field_path</span><span class='lparen'>(</span><span class='id identifier rubyid_graphql_field_path_name'>graphql_field_path_name</span><span class='comma'>,</span> <span class='label'>explanation:</span> <span class='tstring'><span class='tstring_beg'>&quot;</span><span class='tstring_content'>it is referenced as an index `default_sort` field</span><span class='tstring_end'>&quot;</span></span><span class='rparen'>)</span><span class='period'>.</span><span class='id identifier rubyid_path_in_index'>path_in_index</span><span class='comma'>,</span>
        <span class='label'>direction:</span> <span class='id identifier rubyid_direction'>direction</span>
      <span class='rparen'>)</span>
    <span class='kw'>end</span>
  <span class='rparen'>)</span>
<span class='kw'>end</span></pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="to_index_config-instance_method">
  
    #<strong>to_index_config</strong>  &#x21d2; <tt>Hash&lt;String, Object&gt;</tt> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    <p>Returns datastore configuration for this index for when it does not use rollover.</p>


  </div>
</div>
<div class="tags">
  
<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt>Hash&lt;String, Object&gt;</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>datastore configuration for this index for when it does not use rollover</p>
</div>
      
    </li>
  
</ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


192
193
194
195
196
197
198</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'elasticgraph-schema_definition/lib/elastic_graph/schema_definition/indexing/index.rb', line 192</span>

<span class='kw'>def</span> <span class='id identifier rubyid_to_index_config'>to_index_config</span>
  <span class='lbrace'>{</span>
    <span class='tstring'><span class='tstring_beg'>&quot;</span><span class='tstring_content'>aliases</span><span class='tstring_end'>&quot;</span></span> <span class='op'>=&gt;</span> <span class='lbrace'>{</span><span class='rbrace'>}</span><span class='comma'>,</span>
    <span class='tstring'><span class='tstring_beg'>&quot;</span><span class='tstring_content'>mappings</span><span class='tstring_end'>&quot;</span></span> <span class='op'>=&gt;</span> <span class='id identifier rubyid_mappings'>mappings</span><span class='comma'>,</span>
    <span class='tstring'><span class='tstring_beg'>&quot;</span><span class='tstring_content'>settings</span><span class='tstring_end'>&quot;</span></span> <span class='op'>=&gt;</span> <span class='id identifier rubyid_settings'>settings</span>
  <span class='rbrace'>}</span><span class='period'>.</span><span class='id identifier rubyid_compact'>compact</span>
<span class='kw'>end</span></pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="to_index_template_config-instance_method">
  
    #<strong>to_index_template_config</strong>  &#x21d2; <tt>Hash&lt;String, Object&gt;</tt> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    <p>Returns datastore configuration for the index template that will be defined if rollover is used.</p>


  </div>
</div>
<div class="tags">
  
<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt>Hash&lt;String, Object&gt;</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>datastore configuration for the index template that will be defined if rollover is used</p>
</div>
      
    </li>
  
</ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


201
202
203
204
205
206
207
208
209
210</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'elasticgraph-schema_definition/lib/elastic_graph/schema_definition/indexing/index.rb', line 201</span>

<span class='kw'>def</span> <span class='id identifier rubyid_to_index_template_config'>to_index_template_config</span>
  <span class='lbrace'>{</span>
    <span class='tstring'><span class='tstring_beg'>&quot;</span><span class='tstring_content'>index_patterns</span><span class='tstring_end'>&quot;</span></span> <span class='op'>=&gt;</span> <span class='lbracket'>[</span><span class='tstring'><span class='tstring_beg'>&quot;</span><span class='embexpr_beg'>#{</span><span class='id identifier rubyid_name'>name</span><span class='embexpr_end'>}</span><span class='embexpr_beg'>#{</span><span class='const'>ROLLOVER_INDEX_INFIX_MARKER</span><span class='embexpr_end'>}</span><span class='tstring_content'>*</span><span class='tstring_end'>&quot;</span></span><span class='rbracket'>]</span><span class='comma'>,</span>
    <span class='tstring'><span class='tstring_beg'>&quot;</span><span class='tstring_content'>template</span><span class='tstring_end'>&quot;</span></span> <span class='op'>=&gt;</span> <span class='lbrace'>{</span>
      <span class='tstring'><span class='tstring_beg'>&quot;</span><span class='tstring_content'>aliases</span><span class='tstring_end'>&quot;</span></span> <span class='op'>=&gt;</span> <span class='lbrace'>{</span><span class='rbrace'>}</span><span class='comma'>,</span>
      <span class='tstring'><span class='tstring_beg'>&quot;</span><span class='tstring_content'>mappings</span><span class='tstring_end'>&quot;</span></span> <span class='op'>=&gt;</span> <span class='id identifier rubyid_mappings'>mappings</span><span class='comma'>,</span>
      <span class='tstring'><span class='tstring_beg'>&quot;</span><span class='tstring_content'>settings</span><span class='tstring_end'>&quot;</span></span> <span class='op'>=&gt;</span> <span class='id identifier rubyid_settings'>settings</span>
    <span class='rbrace'>}</span>
  <span class='rbrace'>}</span>
<span class='kw'>end</span></pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="uses_custom_routing?-instance_method">
  
    #<strong>uses_custom_routing?</strong>  &#x21d2; <tt>Boolean</tt> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    <p>Returns whether or not this index uses custom shard routing.</p>


  </div>
</div>
<div class="tags">
  
<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt>Boolean</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>whether or not this index uses custom shard routing</p>
</div>
      
    </li>
  
</ul>

  <p class="tag_title">See Also:</p>
  <ul class="see">
    
      <li><span class='object_link'><a href="#route_with-instance_method" title="ElasticGraph::SchemaDefinition::Indexing::Index#route_with (method)">#route_with</a></span></li>
    
  </ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


187
188
189</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'elasticgraph-schema_definition/lib/elastic_graph/schema_definition/indexing/index.rb', line 187</span>

<span class='kw'>def</span> <span class='id identifier rubyid_uses_custom_routing?'>uses_custom_routing?</span>
  <span class='id identifier rubyid_routing_field_path'>routing_field_path</span><span class='period'>.</span><span class='id identifier rubyid_path_in_index'>path_in_index</span> <span class='op'>!=</span> <span class='tstring'><span class='tstring_beg'>&quot;</span><span class='tstring_content'>id</span><span class='tstring_end'>&quot;</span></span>
<span class='kw'>end</span></pre>
    </td>
  </tr>
</table>
</div>
    
  </div>

</div>

      <div id="footer">
  Generated on Thu Nov 14 16:44:19 2024 by
  <a href="https://yardoc.org" title="Yay! A Ruby Documentation Tool" target="_parent">yard</a>
  0.9.37 (ruby-3.3.6).
</div>

    </div>
  </body>
</html>